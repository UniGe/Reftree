!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("ThreeGLTFViewer", [], t) : "object" == typeof exports ? exports.ThreeGLTFViewer = t() : e.ThreeGLTFViewer = t() }(this, (() => (() => { "use strict"; var e = { 56: (e, t, i) => { e.exports = function (e) { var t = i.nc; t && e.setAttribute("nonce", t) } }, 72: e => { var t = []; function i(e) { for (var i = -1, n = 0; n < t.length; n++)if (t[n].identifier === e) { i = n; break } return i } function n(e, n) { for (var a = {}, s = [], o = 0; o < e.length; o++) { var l = e[o], c = n.base ? l[0] + n.base : l[0], h = a[c] || 0, d = "".concat(c, " ").concat(h); a[c] = h + 1; var u = i(d), A = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] }; if (-1 !== u) t[u].references++, t[u].updater(A); else { var p = r(A, n); n.byIndex = o, t.splice(o, 0, { identifier: d, updater: p, references: 1 }) } s.push(d) } return s } function r(e, t) { var i = t.domAPI(t); i.update(e); return function (t) { if (t) { if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return; i.update(e = t) } else i.remove() } } e.exports = function (e, r) { var a = n(e = e || [], r = r || {}); return function (e) { e = e || []; for (var s = 0; s < a.length; s++) { var o = i(a[s]); t[o].references-- } for (var l = n(e, r), c = 0; c < a.length; c++) { var h = i(a[c]); 0 === t[h].references && (t[h].updater(), t.splice(h, 1)) } a = l } } }, 113: e => { e.exports = function (e, t) { if (t.styleSheet) t.styleSheet.cssText = e; else { for (; t.firstChild;)t.removeChild(t.firstChild); t.appendChild(document.createTextNode(e)) } } }, 208: (e, t, i) => { i.d(t, { A: () => o }); var n = i(354), r = i.n(n), a = i(314), s = i.n(a)()(r()); s.push([e.id, ".gltf-viewer-container {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n  \n  .viewer {\n    width: 100%;\n    height: 100%;\n    position: relative;\n  }\n  \n  .axes {\n    position: absolute;\n    bottom: 1em;\n    right: 1em;\n    width: 5em;\n    height: 5em;\n    pointer-events: none;\n  }\n  \n  .gui-stats {\n    list-style: none;\n  }\n  \n  .gui-wrap {\n    position: absolute;\n    top: 0;\n    right: 0;\n    z-index: 100;\n  }\n\n  .spinner {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    width: 40px;\n    height: 40px;\n    border: 4px solid rgba(0, 0, 0, 0.1);\n    border-radius: 50%;\n    border-top: 4px solid #96BF0D;\n    animation: spin 1s linear infinite;\n    z-index: 1000;\n  }\n\n  @keyframes spin {\n    0% { transform: translate(-50%, -50%) rotate(0deg); }\n    100% { transform: translate(-50%, -50%) rotate(360deg); }\n  }", "", { version: 3, sources: ["webpack://./src/style.css"], names: [], mappings: "AAAA;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,gBAAgB;EAClB;;EAEA;IACE,WAAW;IACX,YAAY;IACZ,kBAAkB;EACpB;;EAEA;IACE,kBAAkB;IAClB,WAAW;IACX,UAAU;IACV,UAAU;IACV,WAAW;IACX,oBAAoB;EACtB;;EAEA;IACE,gBAAgB;EAClB;;EAEA;IACE,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,YAAY;EACd;;EAEA;IACE,kBAAkB;IAClB,QAAQ;IACR,SAAS;IACT,gCAAgC;IAChC,WAAW;IACX,YAAY;IACZ,oCAAoC;IACpC,kBAAkB;IAClB,6BAA6B;IAC7B,kCAAkC;IAClC,aAAa;EACf;;EAEA;IACE,KAAK,6CAA6C,EAAE;IACpD,OAAO,+CAA+C,EAAE;EAC1D", sourcesContent: [".gltf-viewer-container {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n  \n  .viewer {\n    width: 100%;\n    height: 100%;\n    position: relative;\n  }\n  \n  .axes {\n    position: absolute;\n    bottom: 1em;\n    right: 1em;\n    width: 5em;\n    height: 5em;\n    pointer-events: none;\n  }\n  \n  .gui-stats {\n    list-style: none;\n  }\n  \n  .gui-wrap {\n    position: absolute;\n    top: 0;\n    right: 0;\n    z-index: 100;\n  }\n\n  .spinner {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    width: 40px;\n    height: 40px;\n    border: 4px solid rgba(0, 0, 0, 0.1);\n    border-radius: 50%;\n    border-top: 4px solid #96BF0D;\n    animation: spin 1s linear infinite;\n    z-index: 1000;\n  }\n\n  @keyframes spin {\n    0% { transform: translate(-50%, -50%) rotate(0deg); }\n    100% { transform: translate(-50%, -50%) rotate(360deg); }\n  }"], sourceRoot: "" }]); const o = s }, 314: e => { e.exports = function (e) { var t = []; return t.toString = function () { return this.map((function (t) { var i = "", n = void 0 !== t[5]; return t[4] && (i += "@supports (".concat(t[4], ") {")), t[2] && (i += "@media ".concat(t[2], " {")), n && (i += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")), i += e(t), n && (i += "}"), t[2] && (i += "}"), t[4] && (i += "}"), i })).join("") }, t.i = function (e, i, n, r, a) { "string" == typeof e && (e = [[null, e, void 0]]); var s = {}; if (n) for (var o = 0; o < this.length; o++) { var l = this[o][0]; null != l && (s[l] = !0) } for (var c = 0; c < e.length; c++) { var h = [].concat(e[c]); n && s[h[0]] || (void 0 !== a && (void 0 === h[5] || (h[1] = "@layer".concat(h[5].length > 0 ? " ".concat(h[5]) : "", " {").concat(h[1], "}")), h[5] = a), i && (h[2] ? (h[1] = "@media ".concat(h[2], " {").concat(h[1], "}"), h[2] = i) : h[2] = i), r && (h[4] ? (h[1] = "@supports (".concat(h[4], ") {").concat(h[1], "}"), h[4] = r) : h[4] = "".concat(r)), t.push(h)) } }, t } }, 354: e => { e.exports = function (e) { var t = e[1], i = e[3]; if (!i) return t; if ("function" == typeof btoa) { var n = btoa(unescape(encodeURIComponent(JSON.stringify(i)))), r = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(n), a = "/*# ".concat(r, " */"); return [t].concat([a]).join("\n") } return [t].join("\n") } }, 540: e => { e.exports = function (e) { var t = document.createElement("style"); return e.setAttributes(t, e.attributes), e.insert(t, e.options), t } }, 659: e => { var t = {}; e.exports = function (e, i) { var n = function (e) { if (void 0 === t[e]) { var i = document.querySelector(e); if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) try { i = i.contentDocument.head } catch (e) { i = null } t[e] = i } return t[e] }(e); if (!n) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); n.appendChild(i) } }, 825: e => { e.exports = function (e) { if ("undefined" == typeof document) return { update: function () { }, remove: function () { } }; var t = e.insertStyleElement(e); return { update: function (i) { !function (e, t, i) { var n = ""; i.supports && (n += "@supports (".concat(i.supports, ") {")), i.media && (n += "@media ".concat(i.media, " {")); var r = void 0 !== i.layer; r && (n += "@layer".concat(i.layer.length > 0 ? " ".concat(i.layer) : "", " {")), n += i.css, r && (n += "}"), i.media && (n += "}"), i.supports && (n += "}"); var a = i.sourceMap; a && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))), " */")), t.styleTagTransform(n, e, t.options) }(t, e, i) }, remove: function () { !function (e) { if (null === e.parentNode) return !1; e.parentNode.removeChild(e) }(t) } } } } }, t = {}; function i(n) { var r = t[n]; if (void 0 !== r) return r.exports; var a = t[n] = { id: n, exports: {} }; return e[n](a, a.exports, i), a.exports } i.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return i.d(t, { a: t }), t }, i.d = (e, t) => { for (var n in t) i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, i.nc = void 0; var n = {}; i.r(n), i.d(n, { GLTFViewer: () => Ip }); const r = "175", a = 0, s = 1, o = 2, l = 0, c = 1, h = 2, d = 3, u = 0, A = 1, p = 2, f = 100, g = 101, m = 102, _ = 200, b = 201, v = 202, E = 203, y = 204, x = 205, C = 206, I = 207, S = 208, w = 209, M = 210, B = 211, T = 212, R = 213, D = 214, L = 0, U = 1, P = 2, Q = 3, F = 4, N = 5, k = 6, O = 7, G = "attached", H = 301, z = 302, V = 303, W = 304, j = 306, q = 1e3, X = 1001, Y = 1002, K = 1003, J = 1004, Z = 1005, $ = 1006, ee = 1007, te = 1008, ie = 1009, ne = 1010, re = 1011, ae = 1012, se = 1013, oe = 1014, le = 1015, ce = 1016, he = 1017, de = 1018, ue = 1020, Ae = 35902, pe = 1023, fe = 1026, ge = 1027, me = 1028, _e = 1029, be = 1030, ve = 1031, Ee = 1033, ye = 33776, xe = 33777, Ce = 33778, Ie = 33779, Se = 35840, we = 35841, Me = 35842, Be = 35843, Te = 36196, Re = 37492, De = 37496, Le = 37808, Ue = 37809, Pe = 37810, Qe = 37811, Fe = 37812, Ne = 37813, ke = 37814, Oe = 37815, Ge = 37816, He = 37817, ze = 37818, Ve = 37819, We = 37820, je = 37821, qe = 36492, Xe = 36494, Ye = 36495, Ke = 36284, Je = 36285, Ze = 36286, $e = 2300, et = 2301, tt = 2302, it = 2400, nt = 2401, rt = 2402, at = 2500, st = "", ot = "srgb", lt = "srgb-linear", ct = "linear", ht = "srgb", dt = 7680, ut = 512, At = 513, pt = 514, ft = 515, gt = 516, mt = 517, _t = 518, bt = 519, vt = 35044, Et = "300 es", yt = 2e3, xt = 2001; class Ct { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) } hasEventListener(e, t) { const i = this._listeners; return void 0 !== i && (void 0 !== i[e] && -1 !== i[e].indexOf(t)) } removeEventListener(e, t) { const i = this._listeners; if (void 0 === i) return; const n = i[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } dispatchEvent(e) { const t = this._listeners; if (void 0 === t) return; const i = t[e.type]; if (void 0 !== i) { e.target = this; const t = i.slice(0); for (let i = 0, n = t.length; i < n; i++)t[i].call(this, e); e.target = null } } } const It = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let St = 1234567; const wt = Math.PI / 180, Mt = 180 / Math.PI; function Bt() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0; return (It[255 & e] + It[e >> 8 & 255] + It[e >> 16 & 255] + It[e >> 24 & 255] + "-" + It[255 & t] + It[t >> 8 & 255] + "-" + It[t >> 16 & 15 | 64] + It[t >> 24 & 255] + "-" + It[63 & i | 128] + It[i >> 8 & 255] + "-" + It[i >> 16 & 255] + It[i >> 24 & 255] + It[255 & n] + It[n >> 8 & 255] + It[n >> 16 & 255] + It[n >> 24 & 255]).toLowerCase() } function Tt(e, t, i) { return Math.max(t, Math.min(i, e)) } function Rt(e, t) { return (e % t + t) % t } function Dt(e, t, i) { return (1 - i) * e + i * t } function Lt(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return e / 4294967295; case Uint16Array: return e / 65535; case Uint8Array: return e / 255; case Int32Array: return Math.max(e / 2147483647, -1); case Int16Array: return Math.max(e / 32767, -1); case Int8Array: return Math.max(e / 127, -1); default: throw new Error("Invalid component type.") } } function Ut(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return Math.round(4294967295 * e); case Uint16Array: return Math.round(65535 * e); case Uint8Array: return Math.round(255 * e); case Int32Array: return Math.round(2147483647 * e); case Int16Array: return Math.round(32767 * e); case Int8Array: return Math.round(127 * e); default: throw new Error("Invalid component type.") } } const Pt = { DEG2RAD: wt, RAD2DEG: Mt, generateUUID: Bt, clamp: Tt, euclideanModulo: Rt, mapLinear: function (e, t, i, n, r) { return n + (e - t) * (r - n) / (i - t) }, inverseLerp: function (e, t, i) { return e !== t ? (i - e) / (t - e) : 0 }, lerp: Dt, damp: function (e, t, i, n) { return Dt(e, t, 1 - Math.exp(-i * n)) }, pingpong: function (e, t = 1) { return t - Math.abs(Rt(e, 2 * t) - t) }, smoothstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { void 0 !== e && (St = e); let t = St += 1831565813; return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296 }, degToRad: function (e) { return e * wt }, radToDeg: function (e) { return e * Mt }, isPowerOfTwo: function (e) { return !(e & e - 1) && 0 !== e }, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function (e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, setQuaternionFromProperEuler: function (e, t, i, n, r) { const a = Math.cos, s = Math.sin, o = a(i / 2), l = s(i / 2), c = a((t + n) / 2), h = s((t + n) / 2), d = a((t - n) / 2), u = s((t - n) / 2), A = a((n - t) / 2), p = s((n - t) / 2); switch (r) { case "XYX": e.set(o * h, l * d, l * u, o * c); break; case "YZY": e.set(l * u, o * h, l * d, o * c); break; case "ZXZ": e.set(l * d, l * u, o * h, o * c); break; case "XZX": e.set(o * h, l * p, l * A, o * c); break; case "YXY": e.set(l * A, o * h, l * p, o * c); break; case "ZYZ": e.set(l * p, l * A, o * h, o * c) } }, normalize: Ut, denormalize: Lt }; class Qt { constructor(e = 0, t = 0) { Qt.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, i = this.y, n = e.elements; return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Tt(this.x, e.x, t.x), this.y = Tt(this.y, e.y, t.y), this } clampScalar(e, t) { return this.x = Tt(this.x, e, t), this.y = Tt(this.y, e, t), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Tt(i, e, t)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const i = this.dot(e) / t; return Math.acos(Tt(i, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y; return t * t + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y; return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class Ft { constructor(e, t, i, n, r, a, s, o, l) { Ft.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, i, n, r, a, s, o, l) } set(e, t, i, n, r, a, s, o, l) { const c = this.elements; return c[0] = e, c[1] = n, c[2] = s, c[3] = t, c[4] = r, c[5] = o, c[6] = i, c[7] = a, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this } extractBasis(e, t, i) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, n = t.elements, r = this.elements, a = i[0], s = i[3], o = i[6], l = i[1], c = i[4], h = i[7], d = i[2], u = i[5], A = i[8], p = n[0], f = n[3], g = n[6], m = n[1], _ = n[4], b = n[7], v = n[2], E = n[5], y = n[8]; return r[0] = a * p + s * m + o * v, r[3] = a * f + s * _ + o * E, r[6] = a * g + s * b + o * y, r[1] = l * p + c * m + h * v, r[4] = l * f + c * _ + h * E, r[7] = l * g + c * b + h * y, r[2] = d * p + u * m + A * v, r[5] = d * f + u * _ + A * E, r[8] = d * g + u * b + A * y, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], s = e[5], o = e[6], l = e[7], c = e[8]; return t * a * c - t * s * l - i * r * c + i * s * o + n * r * l - n * a * o } invert() { const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], s = e[5], o = e[6], l = e[7], c = e[8], h = c * a - s * l, d = s * o - c * r, u = l * r - a * o, A = t * h + i * d + n * u; if (0 === A) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const p = 1 / A; return e[0] = h * p, e[1] = (n * l - c * i) * p, e[2] = (s * i - n * a) * p, e[3] = d * p, e[4] = (c * t - n * o) * p, e[5] = (n * r - s * t) * p, e[6] = u * p, e[7] = (i * o - l * t) * p, e[8] = (a * t - i * r) * p, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, i, n, r, a, s) { const o = Math.cos(r), l = Math.sin(r); return this.set(i * o, i * l, -i * (o * a + l * s) + a + e, -n * l, n * o, -n * (-l * a + o * s) + s + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(Nt.makeScale(e, t)), this } rotate(e) { return this.premultiply(Nt.makeRotation(-e)), this } translate(e, t) { return this.premultiply(Nt.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, i = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 9; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } const Nt = new Ft; function kt(e) { for (let t = e.length - 1; t >= 0; --t)if (e[t] >= 65535) return !0; return !1 } Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; function Ot(e) { return document.createElementNS("http://www.w3.org/1999/xhtml", e) } function Gt() { const e = Ot("canvas"); return e.style.display = "block", e } const Ht = {}; function zt(e) { e in Ht || (Ht[e] = !0) } const Vt = (new Ft).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), Wt = (new Ft).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715); function jt() { const e = { enabled: !0, workingColorSpace: lt, spaces: {}, convert: function (e, t, i) { return !1 !== this.enabled && t !== i && t && i ? (this.spaces[t].transfer === ht && (e.r = Xt(e.r), e.g = Xt(e.g), e.b = Xt(e.b)), this.spaces[t].primaries !== this.spaces[i].primaries && (e.applyMatrix3(this.spaces[t].toXYZ), e.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === ht && (e.r = Yt(e.r), e.g = Yt(e.g), e.b = Yt(e.b)), e) : e }, fromWorkingColorSpace: function (e, t) { return this.convert(e, this.workingColorSpace, t) }, toWorkingColorSpace: function (e, t) { return this.convert(e, t, this.workingColorSpace) }, getPrimaries: function (e) { return this.spaces[e].primaries }, getTransfer: function (e) { return e === st ? ct : this.spaces[e].transfer }, getLuminanceCoefficients: function (e, t = this.workingColorSpace) { return e.fromArray(this.spaces[t].luminanceCoefficients) }, define: function (e) { Object.assign(this.spaces, e) }, _getMatrix: function (e, t, i) { return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[i].fromXYZ) }, _getDrawingBufferColorSpace: function (e) { return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace }, _getUnpackColorSpace: function (e = this.workingColorSpace) { return this.spaces[e].workingColorSpaceConfig.unpackColorSpace } }, t = [.64, .33, .3, .6, .15, .06], i = [.2126, .7152, .0722], n = [.3127, .329]; return e.define({ [lt]: { primaries: t, whitePoint: n, transfer: ct, toXYZ: Vt, fromXYZ: Wt, luminanceCoefficients: i, workingColorSpaceConfig: { unpackColorSpace: ot }, outputColorSpaceConfig: { drawingBufferColorSpace: ot } }, [ot]: { primaries: t, whitePoint: n, transfer: ht, toXYZ: Vt, fromXYZ: Wt, luminanceCoefficients: i, outputColorSpaceConfig: { drawingBufferColorSpace: ot } } }), e } const qt = jt(); function Xt(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function Yt(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } let Kt; class Jt { static getDataURL(e, t = "image/png") { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let i; if (e instanceof HTMLCanvasElement) i = e; else { void 0 === Kt && (Kt = Ot("canvas")), Kt.width = e.width, Kt.height = e.height; const t = Kt.getContext("2d"); e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), i = Kt } return i.toDataURL(t) } static sRGBToLinear(e) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const t = Ot("canvas"); t.width = e.width, t.height = e.height; const i = t.getContext("2d"); i.drawImage(e, 0, 0, e.width, e.height); const n = i.getImageData(0, 0, e.width, e.height), r = n.data; for (let e = 0; e < r.length; e++)r[e] = 255 * Xt(r[e] / 255); return i.putImageData(n, 0, 0), t } if (e.data) { const t = e.data.slice(0); for (let e = 0; e < t.length; e++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Xt(t[e] / 255)) : t[e] = Xt(t[e]); return { data: t, width: e.width, height: e.height } } return e } } let Zt = 0; class $t { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: Zt++ }), this.uuid = Bt(), this.data = e, this.dataReady = !0, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid]; const i = { uuid: this.uuid, url: "" }, n = this.data; if (null !== n) { let e; if (Array.isArray(n)) { e = []; for (let t = 0, i = n.length; t < i; t++)n[t].isDataTexture ? e.push(ei(n[t].image)) : e.push(ei(n[t])) } else e = ei(n); i.url = e } return t || (e.images[this.uuid] = i), i } } function ei(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Jt.getDataURL(e) : e.data ? { data: Array.from(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : {} } let ti = 0; class ii extends Ct { constructor(e = ii.DEFAULT_IMAGE, t = ii.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, a = 1008, s = 1023, o = 1009, l = ii.DEFAULT_ANISOTROPY, c = "") { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: ti++ }), this.uuid = Bt(), this.name = "", this.source = new $t(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new Qt(0, 0), this.repeat = new Qt(1, 1), this.center = new Qt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ft, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const i = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case q: e.x = e.x - Math.floor(e.x); break; case X: e.x = e.x < 0 ? 0 : 1; break; case Y: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case q: e.y = e.y - Math.floor(e.y); break; case X: e.y = e.y < 0 ? 0 : 1; break; case Y: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && (this.version++, this.source.needsUpdate = !0) } set needsPMREMUpdate(e) { !0 === e && this.pmremVersion++ } } ii.DEFAULT_IMAGE = null, ii.DEFAULT_MAPPING = 300, ii.DEFAULT_ANISOTROPY = 1; class ni { constructor(e = 0, t = 0, i = 0, n = 1) { ni.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = n } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, i, n) { return this.x = e, this.y = t, this.z = i, this.w = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements; return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, i, n, r; const a = .01, s = .1, o = e.elements, l = o[0], c = o[4], h = o[8], d = o[1], u = o[5], A = o[9], p = o[2], f = o[6], g = o[10]; if (Math.abs(c - d) < a && Math.abs(h - p) < a && Math.abs(A - f) < a) { if (Math.abs(c + d) < s && Math.abs(h + p) < s && Math.abs(A + f) < s && Math.abs(l + u + g - 3) < s) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (l + 1) / 2, o = (u + 1) / 2, m = (g + 1) / 2, _ = (c + d) / 4, b = (h + p) / 4, v = (A + f) / 4; return e > o && e > m ? e < a ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(e), n = _ / i, r = b / i) : o > m ? o < a ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(o), i = _ / n, r = v / n) : m < a ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(m), i = b / r, n = v / r), this.set(i, n, r, t), this } let m = Math.sqrt((f - A) * (f - A) + (h - p) * (h - p) + (d - c) * (d - c)); return Math.abs(m) < .001 && (m = 1), this.x = (f - A) / m, this.y = (h - p) / m, this.z = (d - c) / m, this.w = Math.acos((l + u + g - 1) / 2), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Tt(this.x, e.x, t.x), this.y = Tt(this.y, e.y, t.y), this.z = Tt(this.z, e.z, t.z), this.w = Tt(this.w, e.w, t.w), this } clampScalar(e, t) { return this.x = Tt(this.x, e, t), this.y = Tt(this.y, e, t), this.z = Tt(this.z, e, t), this.w = Tt(this.w, e, t), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Tt(i, e, t)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class ri extends Ct { constructor(e = 1, t = 1, i = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ni(0, 0, e, t), this.scissorTest = !1, this.viewport = new ni(0, 0, e, t); const n = { width: e, height: t, depth: 1 }; i = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: $, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, i); const r = new ii(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace); r.flipY = !1, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = []; const a = i.count; for (let e = 0; e < a; e++)this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0, this.textures[e].renderTarget = this; this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = i.depthTexture, this.samples = i.samples } get texture() { return this.textures[0] } set texture(e) { this.textures[0] = e } set depthTexture(e) { null !== this._depthTexture && (this._depthTexture.renderTarget = null), null !== e && (e.renderTarget = this), this._depthTexture = e } get depthTexture() { return this._depthTexture } setSize(e, t, i = 1) { if (this.width !== e || this.height !== t || this.depth !== i) { this.width = e, this.height = t, this.depth = i; for (let n = 0, r = this.textures.length; n < r; n++)this.textures[n].image.width = e, this.textures[n].image.height = t, this.textures[n].image.depth = i; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0; for (let t = 0, i = e.textures.length; t < i; t++) { this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this; const i = Object.assign({}, e.textures[t].image); this.textures[t].source = new $t(i) } return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class ai extends ri { constructor(e = 1, t = 1, i = {}) { super(e, t, i), this.isWebGLRenderTarget = !0 } } class si extends ii { constructor(e = null, t = 1, i = 1, n = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = K, this.minFilter = K, this.wrapR = X, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class oi extends ii { constructor(e = null, t = 1, i = 1, n = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = K, this.minFilter = K, this.wrapR = X, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class li { constructor(e = 0, t = 0, i = 0, n = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = n } static slerpFlat(e, t, i, n, r, a, s) { let o = i[n + 0], l = i[n + 1], c = i[n + 2], h = i[n + 3]; const d = r[a + 0], u = r[a + 1], A = r[a + 2], p = r[a + 3]; if (0 === s) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = h); if (1 === s) return e[t + 0] = d, e[t + 1] = u, e[t + 2] = A, void (e[t + 3] = p); if (h !== p || o !== d || l !== u || c !== A) { let e = 1 - s; const t = o * d + l * u + c * A + h * p, i = t >= 0 ? 1 : -1, n = 1 - t * t; if (n > Number.EPSILON) { const r = Math.sqrt(n), a = Math.atan2(r, t * i); e = Math.sin(e * a) / r, s = Math.sin(s * a) / r } const r = s * i; if (o = o * e + d * r, l = l * e + u * r, c = c * e + A * r, h = h * e + p * r, e === 1 - s) { const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h); o *= e, l *= e, c *= e, h *= e } } e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h } static multiplyQuaternionsFlat(e, t, i, n, r, a) { const s = i[n], o = i[n + 1], l = i[n + 2], c = i[n + 3], h = r[a], d = r[a + 1], u = r[a + 2], A = r[a + 3]; return e[t] = s * A + c * h + o * u - l * d, e[t + 1] = o * A + c * d + l * h - s * u, e[t + 2] = l * A + c * u + s * d - o * h, e[t + 3] = c * A - s * h - o * d - l * u, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, i, n) { return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t = !0) { const i = e._x, n = e._y, r = e._z, a = e._order, s = Math.cos, o = Math.sin, l = s(i / 2), c = s(n / 2), h = s(r / 2), d = o(i / 2), u = o(n / 2), A = o(r / 2); switch (a) { case "XYZ": this._x = d * c * h + l * u * A, this._y = l * u * h - d * c * A, this._z = l * c * A + d * u * h, this._w = l * c * h - d * u * A; break; case "YXZ": this._x = d * c * h + l * u * A, this._y = l * u * h - d * c * A, this._z = l * c * A - d * u * h, this._w = l * c * h + d * u * A; break; case "ZXY": this._x = d * c * h - l * u * A, this._y = l * u * h + d * c * A, this._z = l * c * A + d * u * h, this._w = l * c * h - d * u * A; break; case "ZYX": this._x = d * c * h - l * u * A, this._y = l * u * h + d * c * A, this._z = l * c * A - d * u * h, this._w = l * c * h + d * u * A; break; case "YZX": this._x = d * c * h + l * u * A, this._y = l * u * h + d * c * A, this._z = l * c * A - d * u * h, this._w = l * c * h - d * u * A; break; case "XZY": this._x = d * c * h - l * u * A, this._y = l * u * h - d * c * A, this._z = l * c * A + d * u * h, this._w = l * c * h + d * u * A }return !0 === t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const i = t / 2, n = Math.sin(i); return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, i = t[0], n = t[4], r = t[8], a = t[1], s = t[5], o = t[9], l = t[2], c = t[6], h = t[10], d = i + s + h; if (d > 0) { const e = .5 / Math.sqrt(d + 1); this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (a - n) * e } else if (i > s && i > h) { const e = 2 * Math.sqrt(1 + i - s - h); this._w = (c - o) / e, this._x = .25 * e, this._y = (n + a) / e, this._z = (r + l) / e } else if (s > h) { const e = 2 * Math.sqrt(1 + s - i - h); this._w = (r - l) / e, this._x = (n + a) / e, this._y = .25 * e, this._z = (o + c) / e } else { const e = 2 * Math.sqrt(1 + h - i - s); this._w = (a - n) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let i = e.dot(t) + 1; return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(Tt(this.dot(e), -1, 1))) } rotateTowards(e, t) { const i = this.angleTo(e); if (0 === i) return this; const n = Math.min(1, t / i); return this.slerp(e, n), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const i = e._x, n = e._y, r = e._z, a = e._w, s = t._x, o = t._y, l = t._z, c = t._w; return this._x = i * c + a * s + n * l - r * o, this._y = n * c + a * o + r * s - i * l, this._z = r * c + a * l + i * o - n * s, this._w = a * c - i * s - n * o - r * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const i = this._x, n = this._y, r = this._z, a = this._w; let s = a * e._w + i * e._x + n * e._y + r * e._z; if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this; const o = 1 - s * s; if (o <= Number.EPSILON) { const e = 1 - t; return this._w = e * a + t * this._w, this._x = e * i + t * this._x, this._y = e * n + t * this._y, this._z = e * r + t * this._z, this.normalize(), this } const l = Math.sqrt(o), c = Math.atan2(l, s), h = Math.sin((1 - t) * c) / l, d = Math.sin(t * c) / l; return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = r * h + this._z * d, this._onChangeCallback(), this } slerpQuaternions(e, t, i) { return this.copy(e).slerp(t, i) } random() { const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), r = Math.sqrt(i); return this.set(n * Math.sin(e), n * Math.cos(e), r * Math.sin(t), r * Math.cos(t)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class ci { constructor(e = 0, t = 0, i = 0) { ci.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i } set(e, t, i) { return void 0 === i && (i = this.z), this.x = e, this.y = t, this.z = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(di.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(di.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, i = this.y, n = this.z, r = e.elements; return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]); return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this } applyQuaternion(e) { const t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, s = e.z, o = e.w, l = 2 * (a * n - s * i), c = 2 * (s * t - r * n), h = 2 * (r * i - a * t); return this.x = t + o * l + a * h - s * c, this.y = i + o * c + s * l - r * h, this.z = n + o * h + r * c - a * l, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, i = this.y, n = this.z, r = e.elements; return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Tt(this.x, e.x, t.x), this.y = Tt(this.y, e.y, t.y), this.z = Tt(this.z, e.z, t.z), this } clampScalar(e, t) { return this.x = Tt(this.x, e, t), this.y = Tt(this.y, e, t), this.z = Tt(this.z, e, t), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Tt(i, e, t)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const i = e.x, n = e.y, r = e.z, a = t.x, s = t.y, o = t.z; return this.x = n * o - r * s, this.y = r * a - i * o, this.z = i * s - n * a, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const i = e.dot(this) / t; return this.copy(e).multiplyScalar(i) } projectOnPlane(e) { return hi.copy(this).projectOnVector(e), this.sub(hi) } reflect(e) { return this.sub(hi.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const i = this.dot(e) / t; return Math.acos(Tt(i, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z; return t * t + i * i + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, i) { const n = Math.sin(t) * e; return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = n, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, i = Math.sqrt(1 - t * t); return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const hi = new ci, di = new li; class ui { constructor(e = new ci(1 / 0, 1 / 0, 1 / 0), t = new ci(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t += 3)this.expandByPoint(pi.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, i = e.count; t < i; t++)this.expandByPoint(pi.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = pi.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const i = e.geometry; if (void 0 !== i) { const n = i.getAttribute("position"); if (!0 === t && void 0 !== n && !0 !== e.isInstancedMesh) for (let t = 0, i = n.count; t < i; t++)!0 === e.isMesh ? e.getVertexPosition(t, pi) : pi.fromBufferAttribute(n, t), pi.applyMatrix4(e.matrixWorld), this.expandByPoint(pi); else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), fi.copy(e.boundingBox)) : (null === i.boundingBox && i.computeBoundingBox(), fi.copy(i.boundingBox)), fi.applyMatrix4(e.matrixWorld), this.union(fi) } const n = e.children; for (let e = 0, i = n.length; e < i; e++)this.expandByObject(n[e], t); return this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z } intersectsSphere(e) { return this.clampPoint(e.center, pi), pi.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, i; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(yi), xi.subVectors(this.max, yi), gi.subVectors(e.a, yi), mi.subVectors(e.b, yi), _i.subVectors(e.c, yi), bi.subVectors(mi, gi), vi.subVectors(_i, mi), Ei.subVectors(gi, _i); let t = [0, -bi.z, bi.y, 0, -vi.z, vi.y, 0, -Ei.z, Ei.y, bi.z, 0, -bi.x, vi.z, 0, -vi.x, Ei.z, 0, -Ei.x, -bi.y, bi.x, 0, -vi.y, vi.x, 0, -Ei.y, Ei.x, 0]; return !!Si(t, gi, mi, _i, xi) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Si(t, gi, mi, _i, xi) && (Ci.crossVectors(bi, vi), t = [Ci.x, Ci.y, Ci.z], Si(t, gi, mi, _i, xi))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, pi).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(pi).length()), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (Ai[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ai[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ai[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ai[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ai[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ai[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ai[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ai[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ai)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const Ai = [new ci, new ci, new ci, new ci, new ci, new ci, new ci, new ci], pi = new ci, fi = new ui, gi = new ci, mi = new ci, _i = new ci, bi = new ci, vi = new ci, Ei = new ci, yi = new ci, xi = new ci, Ci = new ci, Ii = new ci; function Si(e, t, i, n, r) { for (let a = 0, s = e.length - 3; a <= s; a += 3) { Ii.fromArray(e, a); const s = r.x * Math.abs(Ii.x) + r.y * Math.abs(Ii.y) + r.z * Math.abs(Ii.z), o = t.dot(Ii), l = i.dot(Ii), c = n.dot(Ii); if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) return !1 } return !0 } const wi = new ui, Mi = new ci, Bi = new ci; class Ti { constructor(e = new ci, t = -1) { this.isSphere = !0, this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const i = this.center; void 0 !== t ? i.copy(t) : wi.setFromPoints(e).getCenter(i); let n = 0; for (let t = 0, r = e.length; t < r; t++)n = Math.max(n, i.distanceToSquared(e[t])); return this.radius = Math.sqrt(n), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const i = this.center.distanceToSquared(e); return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; Mi.subVectors(e, this.center); const t = Mi.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), i = .5 * (e - this.radius); this.center.addScaledVector(Mi, i / e), this.radius += i } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Bi.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Mi.copy(e.center).add(Bi)), this.expandByPoint(Mi.copy(e.center).sub(Bi))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const Ri = new ci, Di = new ci, Li = new ci, Ui = new ci, Pi = new ci, Qi = new ci, Fi = new ci; class Ni { constructor(e = new ci, t = new ci(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Ri)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = Ri.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (Ri.copy(this.origin).addScaledVector(this.direction, t), Ri.distanceToSquared(e)) } distanceSqToSegment(e, t, i, n) { Di.copy(e).add(t).multiplyScalar(.5), Li.copy(t).sub(e).normalize(), Ui.copy(this.origin).sub(Di); const r = .5 * e.distanceTo(t), a = -this.direction.dot(Li), s = Ui.dot(this.direction), o = -Ui.dot(Li), l = Ui.lengthSq(), c = Math.abs(1 - a * a); let h, d, u, A; if (c > 0) if (h = a * o - s, d = a * s - o, A = r * c, h >= 0) if (d >= -A) if (d <= A) { const e = 1 / c; h *= e, d *= e, u = h * (h + a * d + 2 * s) + d * (a * h + d + 2 * o) + l } else d = r, h = Math.max(0, -(a * d + s)), u = -h * h + d * (d + 2 * o) + l; else d = -r, h = Math.max(0, -(a * d + s)), u = -h * h + d * (d + 2 * o) + l; else d <= -A ? (h = Math.max(0, -(-a * r + s)), d = h > 0 ? -r : Math.min(Math.max(-r, -o), r), u = -h * h + d * (d + 2 * o) + l) : d <= A ? (h = 0, d = Math.min(Math.max(-r, -o), r), u = d * (d + 2 * o) + l) : (h = Math.max(0, -(a * r + s)), d = h > 0 ? r : Math.min(Math.max(-r, -o), r), u = -h * h + d * (d + 2 * o) + l); else d = a > 0 ? -r : r, h = Math.max(0, -(a * d + s)), u = -h * h + d * (d + 2 * o) + l; return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(Di).addScaledVector(Li, d), u } intersectSphere(e, t) { Ri.subVectors(e.center, this.origin); const i = Ri.dot(this.direction), n = Ri.dot(Ri) - i * i, r = e.radius * e.radius; if (n > r) return null; const a = Math.sqrt(r - n), s = i - a, o = i + a; return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const i = -(this.origin.dot(e.normal) + e.constant) / t; return i >= 0 ? i : null } intersectPlane(e, t) { const i = this.distanceToPlane(e); return null === i ? null : this.at(i, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); if (0 === t) return !0; return e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let i, n, r, a, s, o; const l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin; return l >= 0 ? (i = (e.min.x - d.x) * l, n = (e.max.x - d.x) * l) : (i = (e.max.x - d.x) * l, n = (e.min.x - d.x) * l), c >= 0 ? (r = (e.min.y - d.y) * c, a = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c, a = (e.min.y - d.y) * c), i > a || r > n ? null : ((r > i || isNaN(i)) && (i = r), (a < n || isNaN(n)) && (n = a), h >= 0 ? (s = (e.min.z - d.z) * h, o = (e.max.z - d.z) * h) : (s = (e.max.z - d.z) * h, o = (e.min.z - d.z) * h), i > o || s > n ? null : ((s > i || i != i) && (i = s), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, t))) } intersectsBox(e) { return null !== this.intersectBox(e, Ri) } intersectTriangle(e, t, i, n, r) { Pi.subVectors(t, e), Qi.subVectors(i, e), Fi.crossVectors(Pi, Qi); let a, s = this.direction.dot(Fi); if (s > 0) { if (n) return null; a = 1 } else { if (!(s < 0)) return null; a = -1, s = -s } Ui.subVectors(this.origin, e); const o = a * this.direction.dot(Qi.crossVectors(Ui, Qi)); if (o < 0) return null; const l = a * this.direction.dot(Pi.cross(Ui)); if (l < 0) return null; if (o + l > s) return null; const c = -a * Ui.dot(Fi); return c < 0 ? null : this.at(c / s, r) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class ki { constructor(e, t, i, n, r, a, s, o, l, c, h, d, u, A, p, f) { ki.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, i, n, r, a, s, o, l, c, h, d, u, A, p, f) } set(e, t, i, n, r, a, s, o, l, c, h, d, u, A, p, f) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = d, g[3] = u, g[7] = A, g[11] = p, g[15] = f, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new ki).fromArray(this.elements) } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this } copyPosition(e) { const t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this } makeBasis(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, i = e.elements, n = 1 / Oi.setFromMatrixColumn(e, 0).length(), r = 1 / Oi.setFromMatrixColumn(e, 1).length(), a = 1 / Oi.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), s = Math.sin(i), o = Math.cos(n), l = Math.sin(n), c = Math.cos(r), h = Math.sin(r); if ("XYZ" === e.order) { const e = a * c, i = a * h, n = s * c, r = s * h; t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = i + n * l, t[5] = e - r * l, t[9] = -s * o, t[2] = r - e * l, t[6] = n + i * l, t[10] = a * o } else if ("YXZ" === e.order) { const e = o * c, i = o * h, n = l * c, r = l * h; t[0] = e + r * s, t[4] = n * s - i, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -s, t[2] = i * s - n, t[6] = r + e * s, t[10] = a * o } else if ("ZXY" === e.order) { const e = o * c, i = o * h, n = l * c, r = l * h; t[0] = e - r * s, t[4] = -a * h, t[8] = n + i * s, t[1] = i + n * s, t[5] = a * c, t[9] = r - e * s, t[2] = -a * l, t[6] = s, t[10] = a * o } else if ("ZYX" === e.order) { const e = a * c, i = a * h, n = s * c, r = s * h; t[0] = o * c, t[4] = n * l - i, t[8] = e * l + r, t[1] = o * h, t[5] = r * l + e, t[9] = i * l - n, t[2] = -l, t[6] = s * o, t[10] = a * o } else if ("YZX" === e.order) { const e = a * o, i = a * l, n = s * o, r = s * l; t[0] = o * c, t[4] = r - e * h, t[8] = n * h + i, t[1] = h, t[5] = a * c, t[9] = -s * c, t[2] = -l * c, t[6] = i * h + n, t[10] = e - r * h } else if ("XZY" === e.order) { const e = a * o, i = a * l, n = s * o, r = s * l; t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = e * h + r, t[5] = a * c, t[9] = i * h - n, t[2] = n * h - i, t[6] = s * c, t[10] = r * h + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(Hi, e, zi) } lookAt(e, t, i) { const n = this.elements; return ji.subVectors(e, t), 0 === ji.lengthSq() && (ji.z = 1), ji.normalize(), Vi.crossVectors(i, ji), 0 === Vi.lengthSq() && (1 === Math.abs(i.z) ? ji.x += 1e-4 : ji.z += 1e-4, ji.normalize(), Vi.crossVectors(i, ji)), Vi.normalize(), Wi.crossVectors(ji, Vi), n[0] = Vi.x, n[4] = Wi.x, n[8] = ji.x, n[1] = Vi.y, n[5] = Wi.y, n[9] = ji.y, n[2] = Vi.z, n[6] = Wi.z, n[10] = ji.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, n = t.elements, r = this.elements, a = i[0], s = i[4], o = i[8], l = i[12], c = i[1], h = i[5], d = i[9], u = i[13], A = i[2], p = i[6], f = i[10], g = i[14], m = i[3], _ = i[7], b = i[11], v = i[15], E = n[0], y = n[4], x = n[8], C = n[12], I = n[1], S = n[5], w = n[9], M = n[13], B = n[2], T = n[6], R = n[10], D = n[14], L = n[3], U = n[7], P = n[11], Q = n[15]; return r[0] = a * E + s * I + o * B + l * L, r[4] = a * y + s * S + o * T + l * U, r[8] = a * x + s * w + o * R + l * P, r[12] = a * C + s * M + o * D + l * Q, r[1] = c * E + h * I + d * B + u * L, r[5] = c * y + h * S + d * T + u * U, r[9] = c * x + h * w + d * R + u * P, r[13] = c * C + h * M + d * D + u * Q, r[2] = A * E + p * I + f * B + g * L, r[6] = A * y + p * S + f * T + g * U, r[10] = A * x + p * w + f * R + g * P, r[14] = A * C + p * M + f * D + g * Q, r[3] = m * E + _ * I + b * B + v * L, r[7] = m * y + _ * S + b * T + v * U, r[11] = m * x + _ * w + b * R + v * P, r[15] = m * C + _ * M + b * D + v * Q, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], s = e[5], o = e[9], l = e[13], c = e[2], h = e[6], d = e[10], u = e[14]; return e[3] * (+r * o * h - n * l * h - r * s * d + i * l * d + n * s * u - i * o * u) + e[7] * (+t * o * u - t * l * d + r * a * d - n * a * u + n * l * c - r * o * c) + e[11] * (+t * l * h - t * s * u - r * a * h + i * a * u + r * s * c - i * l * c) + e[15] * (-n * s * c - t * o * h + t * s * d + n * a * h - i * a * d + i * o * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, i) { const n = this.elements; return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this } invert() { const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], s = e[5], o = e[6], l = e[7], c = e[8], h = e[9], d = e[10], u = e[11], A = e[12], p = e[13], f = e[14], g = e[15], m = h * f * l - p * d * l + p * o * u - s * f * u - h * o * g + s * d * g, _ = A * d * l - c * f * l - A * o * u + a * f * u + c * o * g - a * d * g, b = c * p * l - A * h * l + A * s * u - a * p * u - c * s * g + a * h * g, v = A * h * o - c * p * o - A * s * d + a * p * d + c * s * f - a * h * f, E = t * m + i * _ + n * b + r * v; if (0 === E) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const y = 1 / E; return e[0] = m * y, e[1] = (p * d * r - h * f * r - p * n * u + i * f * u + h * n * g - i * d * g) * y, e[2] = (s * f * r - p * o * r + p * n * l - i * f * l - s * n * g + i * o * g) * y, e[3] = (h * o * r - s * d * r - h * n * l + i * d * l + s * n * u - i * o * u) * y, e[4] = _ * y, e[5] = (c * f * r - A * d * r + A * n * u - t * f * u - c * n * g + t * d * g) * y, e[6] = (A * o * r - a * f * r - A * n * l + t * f * l + a * n * g - t * o * g) * y, e[7] = (a * d * r - c * o * r + c * n * l - t * d * l - a * n * u + t * o * u) * y, e[8] = b * y, e[9] = (A * h * r - c * p * r - A * i * u + t * p * u + c * i * g - t * h * g) * y, e[10] = (a * p * r - A * s * r + A * i * l - t * p * l - a * i * g + t * s * g) * y, e[11] = (c * s * r - a * h * r - c * i * l + t * h * l + a * i * u - t * s * u) * y, e[12] = v * y, e[13] = (c * p * n - A * h * n + A * i * d - t * p * d - c * i * f + t * h * f) * y, e[14] = (A * s * n - a * p * n - A * i * o + t * p * o + a * i * f - t * s * f) * y, e[15] = (a * h * n - c * s * n + c * i * o - t * h * o - a * i * d + t * s * d) * y, this } scale(e) { const t = this.elements, i = e.x, n = e.y, r = e.z; return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, i, n)) } makeTranslation(e, t, i) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, s = e.y, o = e.z, l = r * a, c = r * s; return this.set(l * a + i, l * s - n * o, l * o + n * s, 0, l * s + n * o, c * s + i, c * o - n * a, 0, l * o - n * s, c * o + n * a, r * o * o + i, 0, 0, 0, 0, 1), this } makeScale(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this } makeShear(e, t, i, n, r, a) { return this.set(1, i, r, 0, e, 1, a, 0, t, n, 1, 0, 0, 0, 0, 1), this } compose(e, t, i) { const n = this.elements, r = t._x, a = t._y, s = t._z, o = t._w, l = r + r, c = a + a, h = s + s, d = r * l, u = r * c, A = r * h, p = a * c, f = a * h, g = s * h, m = o * l, _ = o * c, b = o * h, v = i.x, E = i.y, y = i.z; return n[0] = (1 - (p + g)) * v, n[1] = (u + b) * v, n[2] = (A - _) * v, n[3] = 0, n[4] = (u - b) * E, n[5] = (1 - (d + g)) * E, n[6] = (f + m) * E, n[7] = 0, n[8] = (A + _) * y, n[9] = (f - m) * y, n[10] = (1 - (d + p)) * y, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this } decompose(e, t, i) { const n = this.elements; let r = Oi.set(n[0], n[1], n[2]).length(); const a = Oi.set(n[4], n[5], n[6]).length(), s = Oi.set(n[8], n[9], n[10]).length(); this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], Gi.copy(this); const o = 1 / r, l = 1 / a, c = 1 / s; return Gi.elements[0] *= o, Gi.elements[1] *= o, Gi.elements[2] *= o, Gi.elements[4] *= l, Gi.elements[5] *= l, Gi.elements[6] *= l, Gi.elements[8] *= c, Gi.elements[9] *= c, Gi.elements[10] *= c, t.setFromRotationMatrix(Gi), i.x = r, i.y = a, i.z = s, this } makePerspective(e, t, i, n, r, a, s = 2e3) { const o = this.elements, l = 2 * r / (t - e), c = 2 * r / (i - n), h = (t + e) / (t - e), d = (i + n) / (i - n); let u, A; if (s === yt) u = -(a + r) / (a - r), A = -2 * a * r / (a - r); else { if (s !== xt) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s); u = -a / (a - r), A = -a * r / (a - r) } return o[0] = l, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = d, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = A, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(e, t, i, n, r, a, s = 2e3) { const o = this.elements, l = 1 / (t - e), c = 1 / (i - n), h = 1 / (a - r), d = (t + e) * l, u = (i + n) * c; let A, p; if (s === yt) A = (a + r) * h, p = -2 * h; else { if (s !== xt) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s); A = r * h, p = -1 * h } return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -d, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = p, o[14] = -A, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(e) { const t = this.elements, i = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 16; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } } const Oi = new ci, Gi = new ki, Hi = new ci(0, 0, 0), zi = new ci(1, 1, 1), Vi = new ci, Wi = new ci, ji = new ci, qi = new ki, Xi = new li; class Yi { constructor(e = 0, t = 0, i = 0, n = Yi.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = n } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, i, n = this._order) { return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, i = !0) { const n = e.elements, r = n[0], a = n[4], s = n[8], o = n[1], l = n[5], c = n[9], h = n[2], d = n[6], u = n[10]; switch (t) { case "XYZ": this._y = Math.asin(Tt(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, u), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-Tt(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, u), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0); break; case "ZXY": this._x = Math.asin(Tt(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, r)); break; case "ZYX": this._y = Math.asin(-Tt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, l)); break; case "YZX": this._z = Math.asin(Tt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(s, u)); break; case "XZY": this._z = Math.asin(-Tt(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, u), this._y = 0) }return this._order = t, !0 === i && this._onChangeCallback(), this } setFromQuaternion(e, t, i) { return qi.makeRotationFromQuaternion(e), this.setFromRotationMatrix(qi, t, i) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return Xi.setFromEuler(this), this.setFromQuaternion(Xi, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } Yi.DEFAULT_ORDER = "XYZ"; class Ki { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e >>> 0 } enable(e) { this.mask |= 1 << e } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e } disable(e) { this.mask &= ~(1 << e) } disableAll() { this.mask = 0 } test(e) { return !!(this.mask & e.mask) } isEnabled(e) { return !!(this.mask & 1 << e) } } let Ji = 0; const Zi = new ci, $i = new li, en = new ki, tn = new ci, nn = new ci, rn = new ci, an = new li, sn = new ci(1, 0, 0), on = new ci(0, 1, 0), ln = new ci(0, 0, 1), cn = { type: "added" }, hn = { type: "removed" }, dn = { type: "childadded", child: null }, un = { type: "childremoved", child: null }; class An extends Ct { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Ji++ }), this.uuid = Bt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = An.DEFAULT_UP.clone(); const e = new ci, t = new Yi, i = new li, n = new ci(1, 1, 1); t._onChange((function () { i.setFromEuler(t, !1) })), i._onChange((function () { t.setFromQuaternion(i, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: n }, modelViewMatrix: { value: new ki }, normalMatrix: { value: new Ft } }), this.matrix = new ki, this.matrixWorld = new ki, this.matrixAutoUpdate = An.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = An.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Ki, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return $i.setFromAxisAngle(e, t), this.quaternion.multiply($i), this } rotateOnWorldAxis(e, t) { return $i.setFromAxisAngle(e, t), this.quaternion.premultiply($i), this } rotateX(e) { return this.rotateOnAxis(sn, e) } rotateY(e) { return this.rotateOnAxis(on, e) } rotateZ(e) { return this.rotateOnAxis(ln, e) } translateOnAxis(e, t) { return Zi.copy(e).applyQuaternion(this.quaternion), this.position.add(Zi.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(sn, e) } translateY(e) { return this.translateOnAxis(on, e) } translateZ(e) { return this.translateOnAxis(ln, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(en.copy(this.matrixWorld).invert()) } lookAt(e, t, i) { e.isVector3 ? tn.copy(e) : tn.set(e, t, i); const n = this.parent; this.updateWorldMatrix(!0, !1), nn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? en.lookAt(nn, tn, this.up) : en.lookAt(tn, nn, this.up), this.quaternion.setFromRotationMatrix(en), n && (en.extractRotation(n.matrixWorld), $i.setFromRotationMatrix(en), this.quaternion.premultiply($i.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this || e && e.isObject3D && (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(cn), dn.child = e, this.dispatchEvent(dn), dn.child = null), this } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(hn), un.child = e, this.dispatchEvent(un), un.child = null), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), en.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), en.multiply(e.parent.matrixWorld)), e.applyMatrix4(en), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(cn), dn.child = e, this.dispatchEvent(dn), dn.child = null, this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let i = 0, n = this.children.length; i < n; i++) { const n = this.children[i].getObjectByProperty(e, t); if (void 0 !== n) return n } } getObjectsByProperty(e, t, i = []) { this[e] === t && i.push(this); const n = this.children; for (let r = 0, a = n.length; r < a; r++)n[r].getObjectsByProperty(e, t, i); return i } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nn, e, rn), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nn, an, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let i = 0, n = t.length; i < n; i++)t[i].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let i = 0, n = t.length; i < n; i++)t[i].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let i = 0, n = t.length; i < n; i++) { t[i].updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const i = this.parent; if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) { const e = this.children; for (let t = 0, i = e.length; t < i; t++) { e[t].updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = void 0 === e || "string" == typeof e, i = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const n = {}; function r(t, i) { return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((e => ({ boxInitialized: e.boxInitialized, boxMin: e.box.min.toArray(), boxMax: e.box.max.toArray(), sphereInitialized: e.sphereInitialized, sphereRadius: e.sphere.radius, sphereCenter: e.sphere.center.toArray() }))), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(e), null !== this._colorsTexture && (n.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (n.boundingSphere = { center: n.boundingSphere.center.toArray(), radius: n.boundingSphere.radius }), null !== this.boundingBox && (n.boundingBox = { min: n.boundingBox.min.toArray(), max: n.boundingBox.max.toArray() })), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { n.geometry = r(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const i = t.shapes; if (Array.isArray(i)) for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; r(e.shapes, n) } else r(e.shapes, i) } } if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let i = 0, n = this.material.length; i < n; i++)t.push(r(e.materials, this.material[i])); n.material = t } else n.material = r(e.materials, this.material); if (this.children.length > 0) { n.children = []; for (let t = 0; t < this.children.length; t++)n.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { n.animations = []; for (let t = 0; t < this.animations.length; t++) { const i = this.animations[t]; n.animations.push(r(e.animations, i)) } } if (t) { const t = a(e.geometries), n = a(e.materials), r = a(e.textures), s = a(e.images), o = a(e.shapes), l = a(e.skeletons), c = a(e.animations), h = a(e.nodes); t.length > 0 && (i.geometries = t), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), s.length > 0 && (i.images = s), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), c.length > 0 && (i.animations = c), h.length > 0 && (i.nodes = h) } return i.object = n, i; function a(e) { const t = []; for (const i in e) { const n = e[i]; delete n.metadata, t.push(n) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const i = e.children[t]; this.add(i.clone()) } return this } } An.DEFAULT_UP = new ci(0, 1, 0), An.DEFAULT_MATRIX_AUTO_UPDATE = !0, An.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const pn = new ci, fn = new ci, gn = new ci, mn = new ci, _n = new ci, bn = new ci, vn = new ci, En = new ci, yn = new ci, xn = new ci, Cn = new ni, In = new ni, Sn = new ni; class wn { constructor(e = new ci, t = new ci, i = new ci) { this.a = e, this.b = t, this.c = i } static getNormal(e, t, i, n) { n.subVectors(i, t), pn.subVectors(e, t), n.cross(pn); const r = n.lengthSq(); return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0) } static getBarycoord(e, t, i, n, r) { pn.subVectors(n, t), fn.subVectors(i, t), gn.subVectors(e, t); const a = pn.dot(pn), s = pn.dot(fn), o = pn.dot(gn), l = fn.dot(fn), c = fn.dot(gn), h = a * l - s * s; if (0 === h) return r.set(0, 0, 0), null; const d = 1 / h, u = (l * o - s * c) * d, A = (a * c - s * o) * d; return r.set(1 - u - A, A, u) } static containsPoint(e, t, i, n) { return null !== this.getBarycoord(e, t, i, n, mn) && (mn.x >= 0 && mn.y >= 0 && mn.x + mn.y <= 1) } static getInterpolation(e, t, i, n, r, a, s, o) { return null === this.getBarycoord(e, t, i, n, mn) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, mn.x), o.addScaledVector(a, mn.y), o.addScaledVector(s, mn.z), o) } static getInterpolatedAttribute(e, t, i, n, r, a) { return Cn.setScalar(0), In.setScalar(0), Sn.setScalar(0), Cn.fromBufferAttribute(e, t), In.fromBufferAttribute(e, i), Sn.fromBufferAttribute(e, n), a.setScalar(0), a.addScaledVector(Cn, r.x), a.addScaledVector(In, r.y), a.addScaledVector(Sn, r.z), a } static isFrontFacing(e, t, i, n) { return pn.subVectors(i, t), fn.subVectors(e, t), pn.cross(fn).dot(n) < 0 } set(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this } setFromPointsAndIndices(e, t, i, n) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this } setFromAttributeAndIndices(e, t, i, n) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return pn.subVectors(this.c, this.b), fn.subVectors(this.a, this.b), .5 * pn.cross(fn).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return wn.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return wn.getBarycoord(e, this.a, this.b, this.c, t) } getInterpolation(e, t, i, n, r) { return wn.getInterpolation(e, this.a, this.b, this.c, t, i, n, r) } containsPoint(e) { return wn.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return wn.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const i = this.a, n = this.b, r = this.c; let a, s; _n.subVectors(n, i), bn.subVectors(r, i), En.subVectors(e, i); const o = _n.dot(En), l = bn.dot(En); if (o <= 0 && l <= 0) return t.copy(i); yn.subVectors(e, n); const c = _n.dot(yn), h = bn.dot(yn); if (c >= 0 && h <= c) return t.copy(n); const d = o * h - c * l; if (d <= 0 && o >= 0 && c <= 0) return a = o / (o - c), t.copy(i).addScaledVector(_n, a); xn.subVectors(e, r); const u = _n.dot(xn), A = bn.dot(xn); if (A >= 0 && u <= A) return t.copy(r); const p = u * l - o * A; if (p <= 0 && l >= 0 && A <= 0) return s = l / (l - A), t.copy(i).addScaledVector(bn, s); const f = c * A - u * h; if (f <= 0 && h - c >= 0 && u - A >= 0) return vn.subVectors(r, n), s = (h - c) / (h - c + (u - A)), t.copy(n).addScaledVector(vn, s); const g = 1 / (f + p + d); return a = p * g, s = d * g, t.copy(i).addScaledVector(_n, a).addScaledVector(bn, s) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } const Mn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Bn = { h: 0, s: 0, l: 0 }, Tn = { h: 0, s: 0, l: 0 }; function Rn(e, t, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e } class Dn { constructor(e, t, i) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i) } set(e, t, i) { if (void 0 === t && void 0 === i) { const t = e; t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t) } else this.setRGB(e, t, i); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = ot) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, qt.toWorkingColorSpace(this, t), this } setRGB(e, t, i, n = qt.workingColorSpace) { return this.r = e, this.g = t, this.b = i, qt.toWorkingColorSpace(this, n), this } setHSL(e, t, i, n = qt.workingColorSpace) { if (e = Rt(e, 1), t = Tt(t, 0, 1), i = Tt(i, 0, 1), 0 === t) this.r = this.g = this.b = i; else { const n = i <= .5 ? i * (1 + t) : i + t - i * t, r = 2 * i - n; this.r = Rn(r, n, e + 1 / 3), this.g = Rn(r, n, e), this.b = Rn(r, n, e - 1 / 3) } return qt.toWorkingColorSpace(this, n), this } setStyle(e, t = ot) { function i(e) { void 0 !== e && parseFloat(e) } let n; if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) { let e; const r = n[1], a = n[2]; switch (r) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(e[4]), this.setRGB(Math.min(255, parseInt(e[1], 10)) / 255, Math.min(255, parseInt(e[2], 10)) / 255, Math.min(255, parseInt(e[3], 10)) / 255, t); if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(e[4]), this.setRGB(Math.min(100, parseInt(e[1], 10)) / 100, Math.min(100, parseInt(e[2], 10)) / 100, Math.min(100, parseInt(e[3], 10)) / 100, t); break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(e[4]), this.setHSL(parseFloat(e[1]) / 360, parseFloat(e[2]) / 100, parseFloat(e[3]) / 100, t) } } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) { const e = n[1], i = e.length; if (3 === i) return this.setRGB(parseInt(e.charAt(0), 16) / 15, parseInt(e.charAt(1), 16) / 15, parseInt(e.charAt(2), 16) / 15, t); if (6 === i) return this.setHex(parseInt(e, 16), t) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = ot) { const i = Mn[e.toLowerCase()]; return void 0 !== i && this.setHex(i, t), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = Xt(e.r), this.g = Xt(e.g), this.b = Xt(e.b), this } copyLinearToSRGB(e) { return this.r = Yt(e.r), this.g = Yt(e.g), this.b = Yt(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = ot) { return qt.fromWorkingColorSpace(Ln.copy(this), e), 65536 * Math.round(Tt(255 * Ln.r, 0, 255)) + 256 * Math.round(Tt(255 * Ln.g, 0, 255)) + Math.round(Tt(255 * Ln.b, 0, 255)) } getHexString(e = ot) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = qt.workingColorSpace) { qt.fromWorkingColorSpace(Ln.copy(this), t); const i = Ln.r, n = Ln.g, r = Ln.b, a = Math.max(i, n, r), s = Math.min(i, n, r); let o, l; const c = (s + a) / 2; if (s === a) o = 0, l = 0; else { const e = a - s; switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s), a) { case i: o = (n - r) / e + (n < r ? 6 : 0); break; case n: o = (r - i) / e + 2; break; case r: o = (i - n) / e + 4 }o /= 6 } return e.h = o, e.s = l, e.l = c, e } getRGB(e, t = qt.workingColorSpace) { return qt.fromWorkingColorSpace(Ln.copy(this), t), e.r = Ln.r, e.g = Ln.g, e.b = Ln.b, e } getStyle(e = ot) { qt.fromWorkingColorSpace(Ln.copy(this), e); const t = Ln.r, i = Ln.g, n = Ln.b; return e !== ot ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(255 * n)})` } offsetHSL(e, t, i) { return this.getHSL(Bn), this.setHSL(Bn.h + e, Bn.s + t, Bn.l + i) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, i) { return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this } lerpHSL(e, t) { this.getHSL(Bn), e.getHSL(Tn); const i = Dt(Bn.h, Tn.h, t), n = Dt(Bn.s, Tn.s, t), r = Dt(Bn.l, Tn.l, t); return this.setHSL(i, n, r), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const t = this.r, i = this.g, n = this.b, r = e.elements; return this.r = r[0] * t + r[3] * i + r[6] * n, this.g = r[1] * t + r[4] * i + r[7] * n, this.b = r[2] * t + r[5] * i + r[8] * n, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const Ln = new Dn; Dn.NAMES = Mn; let Un = 0; class Pn extends Ct { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Un++ }), this.uuid = Bt(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = f, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Dn(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = dt, this.stencilZFail = dt, this.stencilZPass = dt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const t in e) { const i = e[t]; if (void 0 === i) continue; const n = this[t]; void 0 !== n && (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i) } } toJSON(e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; function n(e) { const t = []; for (const i in e) { const n = e[i]; delete n.metadata, t.push(n) } return t } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (i.dispersion = this.dispersion), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), !0 === this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = !0), 204 !== this.blendSrc && (i.blendSrc = this.blendSrc), 205 !== this.blendDst && (i.blendDst = this.blendDst), this.blendEquation !== f && (i.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (i.depthFunc = this.depthFunc), !1 === this.depthTest && (i.depthTest = this.depthTest), !1 === this.depthWrite && (i.depthWrite = this.depthWrite), !1 === this.colorWrite && (i.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (i.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== dt && (i.stencilFail = this.stencilFail), this.stencilZFail !== dt && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== dt && (i.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaHash && (i.alphaHash = !0), !0 === this.alphaToCoverage && (i.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0), !0 === this.forceSinglePass && (i.forceSinglePass = !0), !0 === this.wireframe && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), t) { const t = n(e.textures), r = n(e.images); t.length > 0 && (i.textures = t), r.length > 0 && (i.images = r) } return i } clone() { return (new this.constructor).copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let i = null; if (null !== t) { const e = t.length; i = new Array(e); for (let n = 0; n !== e; ++n)i[n] = t[n].clone() } return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } onBuild() { } } class Qn extends Pn { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Dn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Yi, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const Fn = Nn(); function Nn() { const e = new ArrayBuffer(4), t = new Float32Array(e), i = new Uint32Array(e), n = new Uint32Array(512), r = new Uint32Array(512); for (let e = 0; e < 256; ++e) { const t = e - 127; t < -27 ? (n[e] = 0, n[256 | e] = 32768, r[e] = 24, r[256 | e] = 24) : t < -14 ? (n[e] = 1024 >> -t - 14, n[256 | e] = 1024 >> -t - 14 | 32768, r[e] = -t - 1, r[256 | e] = -t - 1) : t <= 15 ? (n[e] = t + 15 << 10, n[256 | e] = t + 15 << 10 | 32768, r[e] = 13, r[256 | e] = 13) : t < 128 ? (n[e] = 31744, n[256 | e] = 64512, r[e] = 24, r[256 | e] = 24) : (n[e] = 31744, n[256 | e] = 64512, r[e] = 13, r[256 | e] = 13) } const a = new Uint32Array(2048), s = new Uint32Array(64), o = new Uint32Array(64); for (let e = 1; e < 1024; ++e) { let t = e << 13, i = 0; for (; !(8388608 & t);)t <<= 1, i -= 8388608; t &= -8388609, i += 947912704, a[e] = t | i } for (let e = 1024; e < 2048; ++e)a[e] = 939524096 + (e - 1024 << 13); for (let e = 1; e < 31; ++e)s[e] = e << 23; s[31] = 1199570944, s[32] = 2147483648; for (let e = 33; e < 63; ++e)s[e] = 2147483648 + (e - 32 << 23); s[63] = 3347054592; for (let e = 1; e < 64; ++e)32 !== e && (o[e] = 1024); return { floatView: t, uint32View: i, baseTable: n, shiftTable: r, mantissaTable: a, exponentTable: s, offsetTable: o } } function kn(e) { Math.abs(e), e = Tt(e, -65504, 65504), Fn.floatView[0] = e; const t = Fn.uint32View[0], i = t >> 23 & 511; return Fn.baseTable[i] + ((8388607 & t) >> Fn.shiftTable[i]) } function On(e) { const t = e >> 10; return Fn.uint32View[0] = Fn.mantissaTable[Fn.offsetTable[t] + (1023 & e)] + Fn.exponentTable[t], Fn.floatView[0] } class Gn { static toHalfFloat(e) { return kn(e) } static fromHalfFloat(e) { return On(e) } } const Hn = new ci, zn = new Qt; let Vn = 0; class Wn { constructor(e, t, i = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: Vn++ }), this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = i, this.usage = vt, this.updateRanges = [], this.gpuType = le, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, i) { e *= this.itemSize, i *= t.itemSize; for (let n = 0, r = this.itemSize; n < r; n++)this.array[e + n] = t.array[i + n]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, i = this.count; t < i; t++)zn.fromBufferAttribute(this, t), zn.applyMatrix3(e), this.setXY(t, zn.x, zn.y); else if (3 === this.itemSize) for (let t = 0, i = this.count; t < i; t++)Hn.fromBufferAttribute(this, t), Hn.applyMatrix3(e), this.setXYZ(t, Hn.x, Hn.y, Hn.z); return this } applyMatrix4(e) { for (let t = 0, i = this.count; t < i; t++)Hn.fromBufferAttribute(this, t), Hn.applyMatrix4(e), this.setXYZ(t, Hn.x, Hn.y, Hn.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)Hn.fromBufferAttribute(this, t), Hn.applyNormalMatrix(e), this.setXYZ(t, Hn.x, Hn.y, Hn.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)Hn.fromBufferAttribute(this, t), Hn.transformDirection(e), this.setXYZ(t, Hn.x, Hn.y, Hn.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let i = this.array[e * this.itemSize + t]; return this.normalized && (i = Lt(i, this.array)), i } setComponent(e, t, i) { return this.normalized && (i = Ut(i, this.array)), this.array[e * this.itemSize + t] = i, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Lt(t, this.array)), t } setX(e, t) { return this.normalized && (t = Ut(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Lt(t, this.array)), t } setY(e, t) { return this.normalized && (t = Ut(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Lt(t, this.array)), t } setZ(e, t) { return this.normalized && (t = Ut(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Lt(t, this.array)), t } setW(e, t) { return this.normalized && (t = Ut(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, i) { return e *= this.itemSize, this.normalized && (t = Ut(t, this.array), i = Ut(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this } setXYZ(e, t, i, n) { return e *= this.itemSize, this.normalized && (t = Ut(t, this.array), i = Ut(i, this.array), n = Ut(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this } setXYZW(e, t, i, n, r) { return e *= this.itemSize, this.normalized && (t = Ut(t, this.array), i = Ut(i, this.array), n = Ut(n, this.array), r = Ut(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== vt && (e.usage = this.usage), e } } class jn extends Wn { constructor(e, t, i) { super(new Uint16Array(e), t, i) } } class qn extends Wn { constructor(e, t, i) { super(new Uint32Array(e), t, i) } } class Xn extends Wn { constructor(e, t, i) { super(new Float32Array(e), t, i) } } let Yn = 0; const Kn = new ki, Jn = new An, Zn = new ci, $n = new ui, er = new ui, tr = new ci; class ir extends Ct { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Yn++ }), this.uuid = Bt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (kt(e) ? qn : jn)(e, 1) : this.index = e, this } setIndirect(e) { return this.indirect = e, this } getIndirect() { return this.indirect } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, i = 0) { this.groups.push({ start: e, count: t, materialIndex: i }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const i = this.attributes.normal; if (void 0 !== i) { const t = (new Ft).getNormalMatrix(e); i.applyNormalMatrix(t), i.needsUpdate = !0 } const n = this.attributes.tangent; return void 0 !== n && (n.transformDirection(e), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return Kn.makeRotationFromQuaternion(e), this.applyMatrix4(Kn), this } rotateX(e) { return Kn.makeRotationX(e), this.applyMatrix4(Kn), this } rotateY(e) { return Kn.makeRotationY(e), this.applyMatrix4(Kn), this } rotateZ(e) { return Kn.makeRotationZ(e), this.applyMatrix4(Kn), this } translate(e, t, i) { return Kn.makeTranslation(e, t, i), this.applyMatrix4(Kn), this } scale(e, t, i) { return Kn.makeScale(e, t, i), this.applyMatrix4(Kn), this } lookAt(e) { return Jn.lookAt(e), Jn.updateMatrix(), this.applyMatrix4(Jn.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Zn).negate(), this.translate(Zn.x, Zn.y, Zn.z), this } setFromPoints(e) { const t = this.getAttribute("position"); if (void 0 === t) { const t = []; for (let i = 0, n = e.length; i < n; i++) { const n = e[i]; t.push(n.x, n.y, n.z || 0) } this.setAttribute("position", new Xn(t, 3)) } else { const i = Math.min(e.length, t.count); for (let n = 0; n < i; n++) { const i = e[n]; t.setXYZ(n, i.x, i.y, i.z || 0) } e.length, t.count, t.needsUpdate = !0 } return this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new ui); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) this.boundingBox.set(new ci(-1 / 0, -1 / 0, -1 / 0), new ci(1 / 0, 1 / 0, 1 / 0)); else { if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; $n.setFromBufferAttribute(i), this.morphTargetsRelative ? (tr.addVectors(this.boundingBox.min, $n.min), this.boundingBox.expandByPoint(tr), tr.addVectors(this.boundingBox.max, $n.max), this.boundingBox.expandByPoint(tr)) : (this.boundingBox.expandByPoint($n.min), this.boundingBox.expandByPoint($n.max)) } } else this.boundingBox.makeEmpty(); isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z) } } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Ti); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) this.boundingSphere.set(new ci, 1 / 0); else if (e) { const i = this.boundingSphere.center; if ($n.setFromBufferAttribute(e), t) for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; er.setFromBufferAttribute(i), this.morphTargetsRelative ? (tr.addVectors($n.min, er.min), $n.expandByPoint(tr), tr.addVectors($n.max, er.max), $n.expandByPoint(tr)) : ($n.expandByPoint(er.min), $n.expandByPoint(er.max)) } $n.getCenter(i); let n = 0; for (let t = 0, r = e.count; t < r; t++)tr.fromBufferAttribute(e, t), n = Math.max(n, i.distanceToSquared(tr)); if (t) for (let r = 0, a = t.length; r < a; r++) { const a = t[r], s = this.morphTargetsRelative; for (let t = 0, r = a.count; t < r; t++)tr.fromBufferAttribute(a, t), s && (Zn.fromBufferAttribute(e, t), tr.add(Zn)), n = Math.max(n, i.distanceToSquared(tr)) } this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) } } computeTangents() { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return; const i = t.position, n = t.normal, r = t.uv; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Wn(new Float32Array(4 * i.count), 4)); const a = this.getAttribute("tangent"), s = [], o = []; for (let e = 0; e < i.count; e++)s[e] = new ci, o[e] = new ci; const l = new ci, c = new ci, h = new ci, d = new Qt, u = new Qt, A = new Qt, p = new ci, f = new ci; function g(e, t, n) { l.fromBufferAttribute(i, e), c.fromBufferAttribute(i, t), h.fromBufferAttribute(i, n), d.fromBufferAttribute(r, e), u.fromBufferAttribute(r, t), A.fromBufferAttribute(r, n), c.sub(l), h.sub(l), u.sub(d), A.sub(d); const a = 1 / (u.x * A.y - A.x * u.y); isFinite(a) && (p.copy(c).multiplyScalar(A.y).addScaledVector(h, -u.y).multiplyScalar(a), f.copy(h).multiplyScalar(u.x).addScaledVector(c, -A.x).multiplyScalar(a), s[e].add(p), s[t].add(p), s[n].add(p), o[e].add(f), o[t].add(f), o[n].add(f)) } let m = this.groups; 0 === m.length && (m = [{ start: 0, count: e.count }]); for (let t = 0, i = m.length; t < i; ++t) { const i = m[t], n = i.start; for (let t = n, r = n + i.count; t < r; t += 3)g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2)) } const _ = new ci, b = new ci, v = new ci, E = new ci; function y(e) { v.fromBufferAttribute(n, e), E.copy(v); const t = s[e]; _.copy(t), _.sub(v.multiplyScalar(v.dot(t))).normalize(), b.crossVectors(E, t); const i = b.dot(o[e]) < 0 ? -1 : 1; a.setXYZW(e, _.x, _.y, _.z, i) } for (let t = 0, i = m.length; t < i; ++t) { const i = m[t], n = i.start; for (let t = n, r = n + i.count; t < r; t += 3)y(e.getX(t + 0)), y(e.getX(t + 1)), y(e.getX(t + 2)) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let i = this.getAttribute("normal"); if (void 0 === i) i = new Wn(new Float32Array(3 * t.count), 3), this.setAttribute("normal", i); else for (let e = 0, t = i.count; e < t; e++)i.setXYZ(e, 0, 0, 0); const n = new ci, r = new ci, a = new ci, s = new ci, o = new ci, l = new ci, c = new ci, h = new ci; if (e) for (let d = 0, u = e.count; d < u; d += 3) { const u = e.getX(d + 0), A = e.getX(d + 1), p = e.getX(d + 2); n.fromBufferAttribute(t, u), r.fromBufferAttribute(t, A), a.fromBufferAttribute(t, p), c.subVectors(a, r), h.subVectors(n, r), c.cross(h), s.fromBufferAttribute(i, u), o.fromBufferAttribute(i, A), l.fromBufferAttribute(i, p), s.add(c), o.add(c), l.add(c), i.setXYZ(u, s.x, s.y, s.z), i.setXYZ(A, o.x, o.y, o.z), i.setXYZ(p, l.x, l.y, l.z) } else for (let e = 0, s = t.count; e < s; e += 3)n.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, r), h.subVectors(n, r), c.cross(h), i.setXYZ(e + 0, c.x, c.y, c.z), i.setXYZ(e + 1, c.x, c.y, c.z), i.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), i.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, i = e.count; t < i; t++)tr.fromBufferAttribute(e, t), tr.normalize(), e.setXYZ(t, tr.x, tr.y, tr.z) } toNonIndexed() { function e(e, t) { const i = e.array, n = e.itemSize, r = e.normalized, a = new i.constructor(t.length * n); let s = 0, o = 0; for (let r = 0, l = t.length; r < l; r++) { s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * n; for (let e = 0; e < n; e++)a[o++] = i[s++] } return new Wn(a, n, r) } if (null === this.index) return this; const t = new ir, i = this.index.array, n = this.attributes; for (const r in n) { const a = e(n[r], i); t.setAttribute(r, a) } const r = this.morphAttributes; for (const n in r) { const a = [], s = r[n]; for (let t = 0, n = s.length; t < n; t++) { const n = e(s[t], i); a.push(n) } t.morphAttributes[n] = a } t.morphTargetsRelative = this.morphTargetsRelative; const a = this.groups; for (let e = 0, i = a.length; e < i; e++) { const i = a[e]; t.addGroup(i.start, i.count, i.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const i in t) void 0 !== t[i] && (e[i] = t[i]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const i = this.attributes; for (const t in i) { const n = i[t]; e.data.attributes[t] = n.toJSON(e.data) } const n = {}; let r = !1; for (const t in this.morphAttributes) { const i = this.morphAttributes[t], a = []; for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; a.push(n.toJSON(e.data)) } a.length > 0 && (n[t] = a, r = !0) } r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups; a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a))); const s = this.boundingSphere; return null !== s && (e.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), e } clone() { return (new this.constructor).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const i = e.index; null !== i && this.setIndex(i.clone()); const n = e.attributes; for (const e in n) { const i = n[e]; this.setAttribute(e, i.clone(t)) } const r = e.morphAttributes; for (const e in r) { const i = [], n = r[e]; for (let e = 0, r = n.length; e < r; e++)i.push(n[e].clone(t)); this.morphAttributes[e] = i } this.morphTargetsRelative = e.morphTargetsRelative; const a = e.groups; for (let e = 0, t = a.length; e < t; e++) { const t = a[e]; this.addGroup(t.start, t.count, t.materialIndex) } const s = e.boundingBox; null !== s && (this.boundingBox = s.clone()); const o = e.boundingSphere; return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const nr = new ki, rr = new Ni, ar = new Ti, sr = new ci, or = new ci, lr = new ci, cr = new ci, hr = new ci, dr = new ci, ur = new ci, Ar = new ci; class pr extends An { constructor(e = new ir, t = new Qn) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { const t = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } getVertexPosition(e, t) { const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, a = i.morphTargetsRelative; t.fromBufferAttribute(n, e); const s = this.morphTargetInfluences; if (r && s) { dr.set(0, 0, 0); for (let i = 0, n = r.length; i < n; i++) { const n = s[i], o = r[i]; 0 !== n && (hr.fromBufferAttribute(o, e), a ? dr.addScaledVector(hr, n) : dr.addScaledVector(hr.sub(t), n)) } t.add(dr) } return t } raycast(e, t) { const i = this.geometry, n = this.material, r = this.matrixWorld; if (void 0 !== n) { if (null === i.boundingSphere && i.computeBoundingSphere(), ar.copy(i.boundingSphere), ar.applyMatrix4(r), rr.copy(e.ray).recast(e.near), !1 === ar.containsPoint(rr.origin)) { if (null === rr.intersectSphere(ar, sr)) return; if (rr.origin.distanceToSquared(sr) > (e.far - e.near) ** 2) return } nr.copy(r).invert(), rr.copy(e.ray).applyMatrix4(nr), null !== i.boundingBox && !1 === rr.intersectsBox(i.boundingBox) || this._computeIntersections(e, t, rr) } } _computeIntersections(e, t, i) { let n; const r = this.geometry, a = this.material, s = r.index, o = r.attributes.position, l = r.attributes.uv, c = r.attributes.uv1, h = r.attributes.normal, d = r.groups, u = r.drawRange; if (null !== s) if (Array.isArray(a)) for (let r = 0, o = d.length; r < o; r++) { const o = d[r], A = a[o.materialIndex]; for (let r = Math.max(o.start, u.start), a = Math.min(s.count, Math.min(o.start + o.count, u.start + u.count)); r < a; r += 3) { n = fr(this, A, e, i, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = o.materialIndex, t.push(n)) } } else { for (let r = Math.max(0, u.start), o = Math.min(s.count, u.start + u.count); r < o; r += 3) { n = fr(this, a, e, i, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), t.push(n)) } } else if (void 0 !== o) if (Array.isArray(a)) for (let r = 0, s = d.length; r < s; r++) { const s = d[r], A = a[s.materialIndex]; for (let r = Math.max(s.start, u.start), a = Math.min(o.count, Math.min(s.start + s.count, u.start + u.count)); r < a; r += 3) { n = fr(this, A, e, i, l, c, h, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = s.materialIndex, t.push(n)) } } else { for (let r = Math.max(0, u.start), s = Math.min(o.count, u.start + u.count); r < s; r += 3) { n = fr(this, a, e, i, l, c, h, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), t.push(n)) } } } } function fr(e, t, i, n, r, a, s, o, l, c) { e.getVertexPosition(o, or), e.getVertexPosition(l, lr), e.getVertexPosition(c, cr); const h = function (e, t, i, n, r, a, s, o) { let l; if (l = 1 === t.side ? n.intersectTriangle(s, a, r, !0, o) : n.intersectTriangle(r, a, s, 0 === t.side, o), null === l) return null; Ar.copy(o), Ar.applyMatrix4(e.matrixWorld); const c = i.ray.origin.distanceTo(Ar); return c < i.near || c > i.far ? null : { distance: c, point: Ar.clone(), object: e } }(e, t, i, n, or, lr, cr, ur); if (h) { const e = new ci; wn.getBarycoord(ur, or, lr, cr, e), r && (h.uv = wn.getInterpolatedAttribute(r, o, l, c, e, new Qt)), a && (h.uv1 = wn.getInterpolatedAttribute(a, o, l, c, e, new Qt)), s && (h.normal = wn.getInterpolatedAttribute(s, o, l, c, e, new ci), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1)); const t = { a: o, b: l, c, normal: new ci, materialIndex: 0 }; wn.getNormal(or, lr, cr, t.normal), h.face = t, h.barycoord = e } return h } class gr extends ir { constructor(e = 1, t = 1, i = 1, n = 1, r = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }; const s = this; n = Math.floor(n), r = Math.floor(r), a = Math.floor(a); const o = [], l = [], c = [], h = []; let d = 0, u = 0; function A(e, t, i, n, r, a, A, p, f, g, m) { const _ = a / f, b = A / g, v = a / 2, E = A / 2, y = p / 2, x = f + 1, C = g + 1; let I = 0, S = 0; const w = new ci; for (let a = 0; a < C; a++) { const s = a * b - E; for (let o = 0; o < x; o++) { const d = o * _ - v; w[e] = d * n, w[t] = s * r, w[i] = y, l.push(w.x, w.y, w.z), w[e] = 0, w[t] = 0, w[i] = p > 0 ? 1 : -1, c.push(w.x, w.y, w.z), h.push(o / f), h.push(1 - a / g), I += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < f; t++) { const i = d + t + x * e, n = d + t + x * (e + 1), r = d + (t + 1) + x * (e + 1), a = d + (t + 1) + x * e; o.push(i, n, a), o.push(n, r, a), S += 6 } s.addGroup(u, S, m), u += S, d += I } A("z", "y", "x", -1, -1, i, t, e, a, r, 0), A("z", "y", "x", 1, -1, i, t, -e, a, r, 1), A("x", "z", "y", 1, 1, e, i, t, n, a, 2), A("x", "z", "y", 1, -1, e, i, -t, n, a, 3), A("x", "y", "z", 1, -1, e, t, i, n, r, 4), A("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new Xn(l, 3)), this.setAttribute("normal", new Xn(c, 3)), this.setAttribute("uv", new Xn(h, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new gr(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function mr(e) { const t = {}; for (const i in e) { t[i] = {}; for (const n in e[i]) { const r = e[i][n]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? t[i][n] = null : t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r } } return t } function _r(e) { const t = {}; for (let i = 0; i < e.length; i++) { const n = mr(e[i]); for (const e in n) t[e] = n[e] } return t } function br(e) { const t = e.getRenderTarget(); return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : qt.workingColorSpace } const vr = { clone: mr, merge: _r }; class Er extends Pn { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = mr(e.uniforms), this.uniformsGroups = function (e) { const t = []; for (let i = 0; i < e.length; i++)t.push(e[i].clone()); return t }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const i in this.uniforms) { const n = this.uniforms[i].value; n && n.isTexture ? t.uniforms[i] = { type: "t", value: n.toJSON(e).uuid } : n && n.isColor ? t.uniforms[i] = { type: "c", value: n.getHex() } : n && n.isVector2 ? t.uniforms[i] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? t.uniforms[i] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? t.uniforms[i] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? t.uniforms[i] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? t.uniforms[i] = { type: "m4", value: n.toArray() } : t.uniforms[i] = { value: n } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; const i = {}; for (const e in this.extensions) !0 === this.extensions[e] && (i[e] = !0); return Object.keys(i).length > 0 && (t.extensions = i), t } } class yr extends An { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ki, this.projectionMatrix = new ki, this.projectionMatrixInverse = new ki, this.coordinateSystem = yt } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } const xr = new ci, Cr = new Qt, Ir = new Qt; class Sr extends yr { constructor(e = 50, t = 1, i = .1, n = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * Mt * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(.5 * wt * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * Mt * Math.atan(Math.tan(.5 * wt * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(e, t, i) { xr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(xr.x, xr.y).multiplyScalar(-e / xr.z), xr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(xr.x, xr.y).multiplyScalar(-e / xr.z) } getViewSize(e, t) { return this.getViewBounds(e, Cr, Ir), t.subVectors(Ir, Cr) } setViewOffset(e, t, i, n, r, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * wt * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -.5 * n; const a = this.view; if (null !== this.view && this.view.enabled) { const e = a.fullWidth, s = a.fullHeight; r += a.offsetX * n / e, t -= a.offsetY * i / s, n *= a.width / e, i *= a.height / s } const s = this.filmOffset; 0 !== s && (r += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const wr = -90; class Mr extends An { constructor(e, t, i) { super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0; const n = new Sr(wr, 1, e, t); n.layers = this.layers, this.add(n); const r = new Sr(wr, 1, e, t); r.layers = this.layers, this.add(r); const a = new Sr(wr, 1, e, t); a.layers = this.layers, this.add(a); const s = new Sr(wr, 1, e, t); s.layers = this.layers, this.add(s); const o = new Sr(wr, 1, e, t); o.layers = this.layers, this.add(o); const l = new Sr(wr, 1, e, t); l.layers = this.layers, this.add(l) } updateCoordinateSystem() { const e = this.coordinateSystem, t = this.children.concat(), [i, n, r, a, s, o] = t; for (const e of t) this.remove(e); if (e === yt) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1); else { if (e !== xt) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1) } for (const e of t) this.add(e), e.updateMatrixWorld() } update(e, t) { null === this.parent && this.updateMatrixWorld(); const { renderTarget: i, activeMipmapLevel: n } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [r, a, s, o, l, c] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), A = e.xr.enabled; e.xr.enabled = !1; const p = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, n), e.render(t, r), e.setRenderTarget(i, 1, n), e.render(t, a), e.setRenderTarget(i, 2, n), e.render(t, s), e.setRenderTarget(i, 3, n), e.render(t, o), e.setRenderTarget(i, 4, n), e.render(t, l), i.texture.generateMipmaps = p, e.setRenderTarget(i, 5, n), e.render(t, c), e.setRenderTarget(h, d, u), e.xr.enabled = A, i.texture.needsPMREMUpdate = !0 } } class Br extends ii { constructor(e = [], t = 301, i, n, r, a, s, o, l, c) { super(e, t, i, n, r, a, s, o, l, c), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class Tr extends ai { constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const i = { width: e, height: e, depth: 1 }, n = [i, i, i, i, i, i]; this.texture = new Br(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : $ } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const i = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, n = new gr(5, 5, 5), r = new Er({ name: "CubemapFromEquirect", uniforms: mr(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: 1, blending: 0 }); r.uniforms.tEquirect.value = t; const a = new pr(n, r), s = t.minFilter; t.minFilter === te && (t.minFilter = $); return new Mr(1, 10, this).update(e, a), t.minFilter = s, a.geometry.dispose(), a.material.dispose(), this } clear(e, t = !0, i = !0, n = !0) { const r = e.getRenderTarget(); for (let r = 0; r < 6; r++)e.setRenderTarget(this, r), e.clear(t, i, n); e.setRenderTarget(r) } } class Rr extends An { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const Dr = { type: "move" }; class Lr { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new Rr, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new Rr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ci, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ci), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new Rr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ci, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ci), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const i of e.hand.values()) this._getHandJoint(t, i) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, i) { let n = null, r = null, a = null; const s = this._targetRay, o = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) { if (l && e.hand) { a = !0; for (const n of e.hand.values()) { const e = t.getJointPose(n, i), r = this._getHandJoint(l, n); null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius), r.visible = null !== e } const n = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], s = n.position.distanceTo(r.position), o = .02, c = .005; l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1)); null !== s && (n = t.getPose(e.targetRaySpace, i), null === n && null !== r && (n = r), null !== n && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, n.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = !1, n.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(Dr))) } return null !== s && (s.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this } _getHandJoint(e, t) { if (void 0 === e.joints[t.jointName]) { const i = new Rr; i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i) } return e.joints[t.jointName] } } class Ur extends An { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Yi, this.environmentIntensity = 1, this.environmentRotation = new Yi, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t } } class Pr { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = vt, this.updateRanges = [], this.version = 0, this.uuid = Bt() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, i) { e *= this.stride, i *= t.stride; for (let n = 0, r = this.stride; n < r; n++)this.array[e + n] = t.array[i + n]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Bt()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride); return i.setUsage(this.usage), i } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Bt()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const Qr = new ci; class Fr { constructor(e, t, i, n = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, i = this.data.count; t < i; t++)Qr.fromBufferAttribute(this, t), Qr.applyMatrix4(e), this.setXYZ(t, Qr.x, Qr.y, Qr.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)Qr.fromBufferAttribute(this, t), Qr.applyNormalMatrix(e), this.setXYZ(t, Qr.x, Qr.y, Qr.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)Qr.fromBufferAttribute(this, t), Qr.transformDirection(e), this.setXYZ(t, Qr.x, Qr.y, Qr.z); return this } getComponent(e, t) { let i = this.array[e * this.data.stride + this.offset + t]; return this.normalized && (i = Lt(i, this.array)), i } setComponent(e, t, i) { return this.normalized && (i = Ut(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this } setX(e, t) { return this.normalized && (t = Ut(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = Ut(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = Ut(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = Ut(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Lt(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Lt(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Lt(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Lt(t, this.array)), t } setXY(e, t, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = Ut(t, this.array), i = Ut(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this } setXYZ(e, t, i, n) { return e = e * this.data.stride + this.offset, this.normalized && (t = Ut(t, this.array), i = Ut(i, this.array), n = Ut(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this } setXYZW(e, t, i, n, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = Ut(t, this.array), i = Ut(i, this.array), n = Ut(n, this.array), r = Ut(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this } clone(e) { if (void 0 === e) { const e = []; for (let t = 0; t < this.count; t++) { const i = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[i + t]) } return new Wn(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Fr(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (void 0 === e) { const e = []; for (let t = 0; t < this.count; t++) { const i = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[i + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } const Nr = new ci, kr = new ni, Or = new ni, Gr = new ci, Hr = new ki, zr = new ci, Vr = new Ti, Wr = new ki, jr = new Ni; class qr extends pr { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = G, this.bindMatrix = new ki, this.bindMatrixInverse = new ki, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; null === this.boundingBox && (this.boundingBox = new ui), this.boundingBox.makeEmpty(); const t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, zr), this.boundingBox.expandByPoint(zr) } computeBoundingSphere() { const e = this.geometry; null === this.boundingSphere && (this.boundingSphere = new Ti), this.boundingSphere.makeEmpty(); const t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, zr), this.boundingSphere.expandByPoint(zr) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { const i = this.material, n = this.matrixWorld; void 0 !== i && (null === this.boundingSphere && this.computeBoundingSphere(), Vr.copy(this.boundingSphere), Vr.applyMatrix4(n), !1 !== e.ray.intersectsSphere(Vr) && (Wr.copy(n).invert(), jr.copy(e.ray).applyMatrix4(Wr), null !== this.boundingBox && !1 === jr.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, jr))) } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new ni, t = this.geometry.attributes.skinWeight; for (let i = 0, n = t.count; i < n; i++) { e.fromBufferAttribute(t, i); const n = 1 / e.manhattanLength(); n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === G ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert() } applyBoneTransform(e, t) { const i = this.skeleton, n = this.geometry; kr.fromBufferAttribute(n.attributes.skinIndex, e), Or.fromBufferAttribute(n.attributes.skinWeight, e), Nr.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const n = Or.getComponent(e); if (0 !== n) { const r = kr.getComponent(e); Hr.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), t.addScaledVector(Gr.copy(Nr).applyMatrix4(Hr), n) } } return t.applyMatrix4(this.bindMatrixInverse) } } class Xr extends An { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class Yr extends ii { constructor(e = null, t = 1, i = 1, n, r, a, s, o, l = 1003, c = 1003, h, d) { super(null, a, s, o, l, c, n, r, h, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const Kr = new ki, Jr = new ki; class Zr { constructor(e = [], t = []) { this.uuid = Bt(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new ki) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new ki; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture; for (let n = 0, r = e.length; n < r; n++) { const r = e[n] ? e[n].matrixWorld : Jr; Kr.multiplyMatrices(r, t[n]), Kr.toArray(i, 16 * n) } null !== n && (n.needsUpdate = !0) } clone() { return new Zr(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length); e = 4 * Math.ceil(e / 4), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const i = new Yr(t, e, e, pe, le); return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this } getBoneByName(e) { for (let t = 0, i = this.bones.length; t < i; t++) { const i = this.bones[t]; if (i.name === e) return i } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let i = 0, n = e.bones.length; i < n; i++) { let n = t[e.bones[i]]; void 0 === n && (n = new Xr), this.bones.push(n), this.boneInverses.push((new ki).fromArray(e.boneInverses[i])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, i = this.boneInverses; for (let n = 0, r = t.length; n < r; n++) { const r = t[n]; e.bones.push(r.uuid); const a = i[n]; e.boneInverses.push(a.toArray()) } return e } } class $r extends Wn { constructor(e, t, i, n = 1) { super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const ea = new ki, ta = new ki, ia = [], na = new ui, ra = new ki, aa = new pr, sa = new Ti; class oa extends pr { constructor(e, t, i) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new $r(new Float32Array(16 * i), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null; for (let e = 0; e < i; e++)this.setMatrixAt(e, ra) } computeBoundingBox() { const e = this.geometry, t = this.count; null === this.boundingBox && (this.boundingBox = new ui), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let i = 0; i < t; i++)this.getMatrixAt(i, ea), na.copy(e.boundingBox).applyMatrix4(ea), this.boundingBox.union(na) } computeBoundingSphere() { const e = this.geometry, t = this.count; null === this.boundingSphere && (this.boundingSphere = new Ti), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let i = 0; i < t; i++)this.getMatrixAt(i, ea), sa.copy(e.boundingSphere).applyMatrix4(ea), this.boundingSphere.union(sa) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } getMorphAt(e, t) { const i = t.morphTargetInfluences, n = this.morphTexture.source.data.data, r = e * (i.length + 1) + 1; for (let e = 0; e < i.length; e++)i[e] = n[r + e] } raycast(e, t) { const i = this.matrixWorld, n = this.count; if (aa.geometry = this.geometry, aa.material = this.material, void 0 !== aa.material && (null === this.boundingSphere && this.computeBoundingSphere(), sa.copy(this.boundingSphere), sa.applyMatrix4(i), !1 !== e.ray.intersectsSphere(sa))) for (let r = 0; r < n; r++) { this.getMatrixAt(r, ea), ta.multiplyMatrices(i, ea), aa.matrixWorld = ta, aa.raycast(e, ia); for (let e = 0, i = ia.length; e < i; e++) { const i = ia[e]; i.instanceId = r, i.object = this, t.push(i) } ia.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new $r(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } setMorphAt(e, t) { const i = t.morphTargetInfluences, n = i.length + 1; null === this.morphTexture && (this.morphTexture = new Yr(new Float32Array(n * this.count), n, this.count, me, le)); const r = this.morphTexture.source.data.data; let a = 0; for (let e = 0; e < i.length; e++)a += i[e]; const s = this.geometry.morphTargetsRelative ? 1 : 1 - a, o = n * e; r[o] = s, r.set(i, o + 1) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null) } } const la = new ci, ca = new ci, ha = new Ft; class da { constructor(e = new ci(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, i, n) { return this.normal.set(e, t, i), this.constant = n, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, i) { const n = la.subVectors(i, t).cross(ca.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(n, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const i = e.delta(la), n = this.normal.dot(i); if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; const r = -(e.start.dot(this.normal) + this.constant) / n; return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r) } intersectsLine(e) { const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end); return t < 0 && i > 0 || i < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const i = t || ha.getNormalMatrix(e), n = this.coplanarPoint(la).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize(); return this.constant = -n.dot(r), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } const ua = new Ti, Aa = new ci; class pa { constructor(e = new da, t = new da, i = new da, n = new da, r = new da, a = new da) { this.planes = [e, t, i, n, r, a] } set(e, t, i, n, r, a) { const s = this.planes; return s[0].copy(e), s[1].copy(t), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(a), this } copy(e) { const t = this.planes; for (let i = 0; i < 6; i++)t[i].copy(e.planes[i]); return this } setFromProjectionMatrix(e, t = 2e3) { const i = this.planes, n = e.elements, r = n[0], a = n[1], s = n[2], o = n[3], l = n[4], c = n[5], h = n[6], d = n[7], u = n[8], A = n[9], p = n[10], f = n[11], g = n[12], m = n[13], _ = n[14], b = n[15]; if (i[0].setComponents(o - r, d - l, f - u, b - g).normalize(), i[1].setComponents(o + r, d + l, f + u, b + g).normalize(), i[2].setComponents(o + a, d + c, f + A, b + m).normalize(), i[3].setComponents(o - a, d - c, f - A, b - m).normalize(), i[4].setComponents(o - s, d - h, f - p, b - _).normalize(), t === yt) i[5].setComponents(o + s, d + h, f + p, b + _).normalize(); else { if (t !== xt) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); i[5].setComponents(s, h, p, _).normalize() } return this } intersectsObject(e) { if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), ua.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const t = e.geometry; null === t.boundingSphere && t.computeBoundingSphere(), ua.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(ua) } intersectsSprite(e) { return ua.center.set(0, 0, 0), ua.radius = .7071067811865476, ua.applyMatrix4(e.matrixWorld), this.intersectsSphere(ua) } intersectsSphere(e) { const t = this.planes, i = e.center, n = -e.radius; for (let e = 0; e < 6; e++) { if (t[e].distanceToPoint(i) < n) return !1 } return !0 } intersectsBox(e) { const t = this.planes; for (let i = 0; i < 6; i++) { const n = t[i]; if (Aa.x = n.normal.x > 0 ? e.max.x : e.min.x, Aa.y = n.normal.y > 0 ? e.max.y : e.min.y, Aa.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Aa) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let i = 0; i < 6; i++)if (t[i].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } class fa extends Pn { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Dn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const ga = new ci, ma = new ci, _a = new ki, ba = new Ni, va = new Ti, Ea = new ci, ya = new ci; class xa extends An { constructor(e = new ir, t = new fa) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (null === e.index) { const t = e.attributes.position, i = [0]; for (let e = 1, n = t.count; e < n; e++)ga.fromBufferAttribute(t, e - 1), ma.fromBufferAttribute(t, e), i[e] = i[e - 1], i[e] += ga.distanceTo(ma); e.setAttribute("lineDistance", new Xn(i, 1)) } return this } raycast(e, t) { const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, a = i.drawRange; if (null === i.boundingSphere && i.computeBoundingSphere(), va.copy(i.boundingSphere), va.applyMatrix4(n), va.radius += r, !1 === e.ray.intersectsSphere(va)) return; _a.copy(n).invert(), ba.copy(e.ray).applyMatrix4(_a); const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = s * s, l = this.isLineSegments ? 2 : 1, c = i.index, h = i.attributes.position; if (null !== c) { const i = Math.max(0, a.start), n = Math.min(c.count, a.start + a.count); for (let r = i, a = n - 1; r < a; r += l) { const i = c.getX(r), n = c.getX(r + 1), a = Ca(this, e, ba, o, i, n, r); a && t.push(a) } if (this.isLineLoop) { const r = c.getX(n - 1), a = c.getX(i), s = Ca(this, e, ba, o, r, a, n - 1); s && t.push(s) } } else { const i = Math.max(0, a.start), n = Math.min(h.count, a.start + a.count); for (let r = i, a = n - 1; r < a; r += l) { const i = Ca(this, e, ba, o, r, r + 1, r); i && t.push(i) } if (this.isLineLoop) { const r = Ca(this, e, ba, o, n - 1, i, n - 1); r && t.push(r) } } } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { const t = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function Ca(e, t, i, n, r, a, s) { const o = e.geometry.attributes.position; ga.fromBufferAttribute(o, r), ma.fromBufferAttribute(o, a); if (i.distanceSqToSegment(ga, ma, Ea, ya) > n) return; Ea.applyMatrix4(e.matrixWorld); const l = t.ray.origin.distanceTo(Ea); return l < t.near || l > t.far ? void 0 : { distance: l, point: ya.clone().applyMatrix4(e.matrixWorld), index: s, face: null, faceIndex: null, barycoord: null, object: e } } const Ia = new ci, Sa = new ci; class wa extends xa { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (null === e.index) { const t = e.attributes.position, i = []; for (let e = 0, n = t.count; e < n; e += 2)Ia.fromBufferAttribute(t, e), Sa.fromBufferAttribute(t, e + 1), i[e] = 0 === e ? 0 : i[e - 1], i[e + 1] = i[e] + Ia.distanceTo(Sa); e.setAttribute("lineDistance", new Xn(i, 1)) } return this } } class Ma extends xa { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class Ba extends Pn { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Dn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const Ta = new ki, Ra = new Ni, Da = new Ti, La = new ci; class Ua extends An { constructor(e = new ir, t = new Ba) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, t) { const i = this.geometry, n = this.matrixWorld, r = e.params.Points.threshold, a = i.drawRange; if (null === i.boundingSphere && i.computeBoundingSphere(), Da.copy(i.boundingSphere), Da.applyMatrix4(n), Da.radius += r, !1 === e.ray.intersectsSphere(Da)) return; Ta.copy(n).invert(), Ra.copy(e.ray).applyMatrix4(Ta); const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = s * s, l = i.index, c = i.attributes.position; if (null !== l) { for (let i = Math.max(0, a.start), r = Math.min(l.count, a.start + a.count); i < r; i++) { const r = l.getX(i); La.fromBufferAttribute(c, r), Pa(La, r, o, n, e, t, this) } } else { for (let i = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); i < r; i++)La.fromBufferAttribute(c, i), Pa(La, i, o, n, e, t, this) } } updateMorphTargets() { const e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { const i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { const t = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function Pa(e, t, i, n, r, a, s) { const o = Ra.distanceSqToPoint(e); if (o < i) { const i = new ci; Ra.closestPointToPoint(e, i), i.applyMatrix4(n); const l = r.ray.origin.distanceTo(i); if (l < r.near || l > r.far) return; a.push({ distance: l, distanceToRay: Math.sqrt(o), point: i, index: t, face: null, faceIndex: null, barycoord: null, object: s }) } } class Qa extends ii { constructor(e, t, i, n, r, a, s, o, l, c, h, d) { super(null, a, s, o, l, c, n, r, h, d), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class Fa extends Qa { constructor(e, t, i, n, r, a) { super(e, t, i, r, a), this.isCompressedArrayTexture = !0, this.image.depth = n, this.wrapR = X, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class Na extends Qa { constructor(e, t, i) { super(void 0, e[0].width, e[0].height, t, i, H), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class ka extends ii { constructor(e, t, i = 1014, n, r, a, s = 1003, o = 1003, l, c = 1026) { if (c !== fe && c !== ge) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); super(null, n, r, a, s, o, c, i, l), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.source = new $t(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this } toJSON(e) { const t = super.toJSON(e); return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t } } class Oa extends ir { constructor(e = 1, t = 32, i = 0, n = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: n }, t = Math.max(3, t); const r = [], a = [], s = [], o = [], l = new ci, c = new Qt; a.push(0, 0, 0), s.push(0, 0, 1), o.push(.5, .5); for (let r = 0, h = 3; r <= t; r++, h += 3) { const d = i + r / t * n; l.x = e * Math.cos(d), l.y = e * Math.sin(d), a.push(l.x, l.y, l.z), s.push(0, 0, 1), c.x = (a[h] / e + 1) / 2, c.y = (a[h + 1] / e + 1) / 2, o.push(c.x, c.y) } for (let e = 1; e <= t; e++)r.push(e, e + 1, 0); this.setIndex(r), this.setAttribute("position", new Xn(a, 3)), this.setAttribute("normal", new Xn(s, 3)), this.setAttribute("uv", new Xn(o, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Oa(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class Ga extends ir { constructor(e = 1, t = 1, i = 1, n = 32, r = 1, a = !1, s = 0, o = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: n, heightSegments: r, openEnded: a, thetaStart: s, thetaLength: o }; const l = this; n = Math.floor(n), r = Math.floor(r); const c = [], h = [], d = [], u = []; let A = 0; const p = [], f = i / 2; let g = 0; function m(i) { const r = A, a = new Qt, p = new ci; let m = 0; const _ = !0 === i ? e : t, b = !0 === i ? 1 : -1; for (let e = 1; e <= n; e++)h.push(0, f * b, 0), d.push(0, b, 0), u.push(.5, .5), A++; const v = A; for (let e = 0; e <= n; e++) { const t = e / n * o + s, i = Math.cos(t), r = Math.sin(t); p.x = _ * r, p.y = f * b, p.z = _ * i, h.push(p.x, p.y, p.z), d.push(0, b, 0), a.x = .5 * i + .5, a.y = .5 * r * b + .5, u.push(a.x, a.y), A++ } for (let e = 0; e < n; e++) { const t = r + e, n = v + e; !0 === i ? c.push(n, n + 1, t) : c.push(n + 1, n, t), m += 3 } l.addGroup(g, m, !0 === i ? 1 : 2), g += m } !function () { const a = new ci, m = new ci; let _ = 0; const b = (t - e) / i; for (let l = 0; l <= r; l++) { const c = [], g = l / r, _ = g * (t - e) + e; for (let e = 0; e <= n; e++) { const t = e / n, r = t * o + s, l = Math.sin(r), p = Math.cos(r); m.x = _ * l, m.y = -g * i + f, m.z = _ * p, h.push(m.x, m.y, m.z), a.set(l, b, p).normalize(), d.push(a.x, a.y, a.z), u.push(t, 1 - g), c.push(A++) } p.push(c) } for (let i = 0; i < n; i++)for (let n = 0; n < r; n++) { const a = p[n][i], s = p[n + 1][i], o = p[n + 1][i + 1], l = p[n][i + 1]; (e > 0 || 0 !== n) && (c.push(a, s, l), _ += 3), (t > 0 || n !== r - 1) && (c.push(s, o, l), _ += 3) } l.addGroup(g, _, 0), g += _ }(), !1 === a && (e > 0 && m(!0), t > 0 && m(!1)), this.setIndex(c), this.setAttribute("position", new Xn(h, 3)), this.setAttribute("normal", new Xn(d, 3)), this.setAttribute("uv", new Xn(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ga(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Ha extends ir { constructor(e = 1, t = 1, i = 1, n = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n }; const r = e / 2, a = t / 2, s = Math.floor(i), o = Math.floor(n), l = s + 1, c = o + 1, h = e / s, d = t / o, u = [], A = [], p = [], f = []; for (let e = 0; e < c; e++) { const t = e * d - a; for (let i = 0; i < l; i++) { const n = i * h - r; A.push(n, -t, 0), p.push(0, 0, 1), f.push(i / s), f.push(1 - e / o) } } for (let e = 0; e < o; e++)for (let t = 0; t < s; t++) { const i = t + l * e, n = t + l * (e + 1), r = t + 1 + l * (e + 1), a = t + 1 + l * e; u.push(i, n, a), u.push(n, r, a) } this.setIndex(u), this.setAttribute("position", new Xn(A, 3)), this.setAttribute("normal", new Xn(p, 3)), this.setAttribute("uv", new Xn(f, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ha(e.width, e.height, e.widthSegments, e.heightSegments) } } class za extends ir { constructor(e = 1, t = 32, i = 16, n = 0, r = 2 * Math.PI, a = 0, s = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: s }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i)); const o = Math.min(a + s, Math.PI); let l = 0; const c = [], h = new ci, d = new ci, u = [], A = [], p = [], f = []; for (let u = 0; u <= i; u++) { const g = [], m = u / i; let _ = 0; 0 === u && 0 === a ? _ = .5 / t : u === i && o === Math.PI && (_ = -.5 / t); for (let i = 0; i <= t; i++) { const o = i / t; h.x = -e * Math.cos(n + o * r) * Math.sin(a + m * s), h.y = e * Math.cos(a + m * s), h.z = e * Math.sin(n + o * r) * Math.sin(a + m * s), A.push(h.x, h.y, h.z), d.copy(h).normalize(), p.push(d.x, d.y, d.z), f.push(o + _, 1 - m), g.push(l++) } c.push(g) } for (let e = 0; e < i; e++)for (let n = 0; n < t; n++) { const t = c[e][n + 1], r = c[e][n], s = c[e + 1][n], l = c[e + 1][n + 1]; (0 !== e || a > 0) && u.push(t, r, l), (e !== i - 1 || o < Math.PI) && u.push(r, s, l) } this.setIndex(u), this.setAttribute("position", new Xn(A, 3)), this.setAttribute("normal", new Xn(p, 3)), this.setAttribute("uv", new Xn(f, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new za(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class Va extends Pn { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new Dn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Qt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Yi, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class Wa extends Va { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Qt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return Tt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (e) { this.ior = (1 + .4 * e) / (1 - .4 * e) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Dn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Dn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Dn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get dispersion() { return this._dispersion } set dispersion(e) { this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class ja extends Pn { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class qa extends Pn { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function Xa(e, t) { return e && e.constructor !== t ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e } function Ya(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) } function Ka(e) { const t = e.length, i = new Array(t); for (let e = 0; e !== t; ++e)i[e] = e; return i.sort((function (t, i) { return e[t] - e[i] })), i } function Ja(e, t, i) { const n = e.length, r = new e.constructor(n); for (let a = 0, s = 0; s !== n; ++a) { const n = i[a] * t; for (let i = 0; i !== t; ++i)r[s++] = e[n + i] } return r } function Za(e, t, i, n) { let r = 1, a = e[0]; for (; void 0 !== a && void 0 === a[n];)a = e[r++]; if (void 0 === a) return; let s = a[n]; if (void 0 !== s) if (Array.isArray(s)) do { s = a[n], void 0 !== s && (t.push(a.time), i.push(...s)), a = e[r++] } while (void 0 !== a); else if (void 0 !== s.toArray) do { s = a[n], void 0 !== s && (t.push(a.time), s.toArray(i, i.length)), a = e[r++] } while (void 0 !== a); else do { s = a[n], void 0 !== s && (t.push(a.time), i.push(s)), a = e[r++] } while (void 0 !== a) } class $a { constructor(e, t, i, n) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let i = this._cachedIndex, n = t[i], r = t[i - 1]; e: { t: { let a; i: { n: if (!(e < n)) { for (let a = i + 2; ;) { if (void 0 === n) { if (e < r) break n; return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } if (i === a) break; if (r = n, n = t[++i], e < n) break t } a = t.length; break i } if (e >= r) break e; { const s = t[1]; e < s && (i = 2, r = s); for (let a = i - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === a) break; if (n = r, r = t[--i - 1], e >= r) break t } a = i, i = 0 } } for (; i < a;) { const n = i + a >>> 1; e < t[n] ? a = n : i = n + 1 } if (n = t[i], r = t[i - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0); if (void 0 === n) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } this._cachedIndex = i, this.intervalChanged_(i, r, n) } return this.interpolate_(i, r, e, n) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n; for (let e = 0; e !== n; ++e)t[e] = i[r + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class es extends $a { constructor(e, t, i, n) { super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: it, endingEnd: it } } intervalChanged_(e, t, i) { const n = this.parameterPositions; let r = e - 2, a = e + 1, s = n[r], o = n[a]; if (void 0 === s) switch (this.getSettings_().endingStart) { case nt: r = e, s = 2 * t - i; break; case rt: r = n.length - 2, s = t + n[r] - n[r + 1]; break; default: r = e, s = i }if (void 0 === o) switch (this.getSettings_().endingEnd) { case nt: a = e, o = 2 * i - t; break; case rt: a = 1, o = i + n[1] - n[0]; break; default: a = e - 1, o = t }const l = .5 * (i - t), c = this.valueSize; this._weightPrev = l / (t - s), this._weightNext = l / (o - i), this._offsetPrev = r * c, this._offsetNext = a * c } interpolate_(e, t, i, n) { const r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = o - s, c = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, u = this._weightNext, A = (i - t) / (n - t), p = A * A, f = p * A, g = -d * f + 2 * d * p - d * A, m = (1 + d) * f + (-1.5 - 2 * d) * p + (-.5 + d) * A + 1, _ = (-1 - u) * f + (1.5 + u) * p + .5 * A, b = u * f - u * p; for (let e = 0; e !== s; ++e)r[e] = g * a[c + e] + m * a[l + e] + _ * a[o + e] + b * a[h + e]; return r } } class ts extends $a { constructor(e, t, i, n) { super(e, t, i, n) } interpolate_(e, t, i, n) { const r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = o - s, c = (i - t) / (n - t), h = 1 - c; for (let e = 0; e !== s; ++e)r[e] = a[l + e] * h + a[o + e] * c; return r } } class is extends $a { constructor(e, t, i, n) { super(e, t, i, n) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class ns { constructor(e, t, i, n) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Xa(t, this.TimeBufferType), this.values = Xa(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let i; if (t.toJSON !== this.toJSON) i = t.toJSON(e); else { i = { name: e.name, times: Xa(e.times, Array), values: Xa(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (i.interpolation = t) } return i.type = e.ValueTypeName, i } InterpolantFactoryMethodDiscrete(e) { return new is(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new ts(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new es(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case $e: t = this.InterpolantFactoryMethodDiscrete; break; case et: t = this.InterpolantFactoryMethodLinear; break; case tt: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return $e; case this.InterpolantFactoryMethodLinear: return et; case this.InterpolantFactoryMethodSmooth: return tt } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let i = 0, n = t.length; i !== n; ++i)t[i] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let i = 0, n = t.length; i !== n; ++i)t[i] *= e } return this } trim(e, t) { const i = this.times, n = i.length; let r = 0, a = n - 1; for (; r !== n && i[r] < e;)++r; for (; -1 !== a && i[a] > t;)--a; if (++a, 0 !== r || a !== n) { r >= a && (a = Math.max(a, 1), r = a - 1); const e = this.getValueSize(); this.times = i.slice(r, a), this.values = this.values.slice(r * e, a * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (e = !1); const i = this.times, n = this.values, r = i.length; 0 === r && (e = !1); let a = null; for (let t = 0; t !== r; t++) { const n = i[t]; if ("number" == typeof n && isNaN(n)) { e = !1; break } if (null !== a && a > n) { e = !1; break } a = n } if (void 0 !== n && Ya(n)) for (let t = 0, i = n.length; t !== i; ++t) { const i = n[t]; if (isNaN(i)) { e = !1; break } } return e } optimize() { const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), n = this.getInterpolation() === tt, r = e.length - 1; let a = 1; for (let s = 1; s < r; ++s) { let r = !1; const o = e[s]; if (o !== e[s + 1] && (1 !== s || o !== e[0])) if (n) r = !0; else { const e = s * i, n = e - i, a = e + i; for (let s = 0; s !== i; ++s) { const i = t[e + s]; if (i !== t[n + s] || i !== t[a + s]) { r = !0; break } } } if (r) { if (s !== a) { e[a] = e[s]; const n = s * i, r = a * i; for (let e = 0; e !== i; ++e)t[r + e] = t[n + e] } ++a } } if (r > 0) { e[a] = e[r]; for (let e = r * i, n = a * i, s = 0; s !== i; ++s)t[n + s] = t[e + s]; ++a } return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this } clone() { const e = this.times.slice(), t = this.values.slice(), i = new (0, this.constructor)(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } } ns.prototype.ValueTypeName = "", ns.prototype.TimeBufferType = Float32Array, ns.prototype.ValueBufferType = Float32Array, ns.prototype.DefaultInterpolation = et; class rs extends ns { constructor(e, t, i) { super(e, t, i) } } rs.prototype.ValueTypeName = "bool", rs.prototype.ValueBufferType = Array, rs.prototype.DefaultInterpolation = $e, rs.prototype.InterpolantFactoryMethodLinear = void 0, rs.prototype.InterpolantFactoryMethodSmooth = void 0; class as extends ns { constructor(e, t, i, n) { super(e, t, i, n) } } as.prototype.ValueTypeName = "color"; class ss extends ns { constructor(e, t, i, n) { super(e, t, i, n) } } ss.prototype.ValueTypeName = "number"; class os extends $a { constructor(e, t, i, n) { super(e, t, i, n) } interpolate_(e, t, i, n) { const r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = (i - t) / (n - t); let l = e * s; for (let e = l + s; l !== e; l += 4)li.slerpFlat(r, 0, a, l - s, a, l, o); return r } } class ls extends ns { constructor(e, t, i, n) { super(e, t, i, n) } InterpolantFactoryMethodLinear(e) { return new os(this.times, this.values, this.getValueSize(), e) } } ls.prototype.ValueTypeName = "quaternion", ls.prototype.InterpolantFactoryMethodSmooth = void 0; class cs extends ns { constructor(e, t, i) { super(e, t, i) } } cs.prototype.ValueTypeName = "string", cs.prototype.ValueBufferType = Array, cs.prototype.DefaultInterpolation = $e, cs.prototype.InterpolantFactoryMethodLinear = void 0, cs.prototype.InterpolantFactoryMethodSmooth = void 0; class hs extends ns { constructor(e, t, i, n) { super(e, t, i, n) } } hs.prototype.ValueTypeName = "vector"; class ds { constructor(e = "", t = -1, i = [], n = 2500) { this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = Bt(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], i = e.tracks, n = 1 / (e.fps || 1); for (let e = 0, r = i.length; e !== r; ++e)t.push(us(i[e]).scale(n)); const r = new this(e.name, e.duration, t, e.blendMode); return r.uuid = e.uuid, r } static toJSON(e) { const t = [], i = e.tracks, n = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, n = i.length; e !== n; ++e)t.push(ns.toJSON(i[e])); return n } static CreateFromMorphTargetSequence(e, t, i, n) { const r = t.length, a = []; for (let e = 0; e < r; e++) { let s = [], o = []; s.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0); const l = Ka(s); s = Ja(s, 1, l), o = Ja(o, 1, l), n || 0 !== s[0] || (s.push(r), o.push(o[0])), a.push(new ss(".morphTargetInfluences[" + t[e].name + "]", s, o).scale(1 / i)) } return new this(e, -1, a) } static findByName(e, t) { let i = e; if (!Array.isArray(e)) { const t = e; i = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < i.length; e++)if (i[e].name === t) return i[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, i) { const n = {}, r = /^([\w-]*?)([\d]+)$/; for (let t = 0, i = e.length; t < i; t++) { const i = e[t], a = i.name.match(r); if (a && a.length > 1) { const e = a[1]; let t = n[e]; t || (n[e] = t = []), t.push(i) } } const a = []; for (const e in n) a.push(this.CreateFromMorphTargetSequence(e, n[e], t, i)); return a } static parseAnimation(e, t) { if (!e) return null; const i = function (e, t, i, n, r) { if (0 !== i.length) { const a = [], s = []; Za(i, a, s, n), 0 !== a.length && r.push(new e(t, a, s)) } }, n = [], r = e.name || "default", a = e.fps || 30, s = e.blendMode; let o = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const r = l[e].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const e = {}; let t; for (t = 0; t < r.length; t++)if (r[t].morphTargets) for (let i = 0; i < r[t].morphTargets.length; i++)e[r[t].morphTargets[i]] = -1; for (const i in e) { const e = [], a = []; for (let n = 0; n !== r[t].morphTargets.length; ++n) { const n = r[t]; e.push(n.time), a.push(n.morphTarget === i ? 1 : 0) } n.push(new ss(".morphTargetInfluence[" + i + "]", e, a)) } o = e.length * a } else { const a = ".bones[" + t[e].name + "]"; i(hs, a + ".position", r, "pos", n), i(ls, a + ".quaternion", r, "rot", n), i(hs, a + ".scale", r, "scl", n) } } if (0 === n.length) return null; return new this(r, o, n, s) } resetDuration() { let e = 0; for (let t = 0, i = this.tracks.length; t !== i; ++t) { const i = this.tracks[t]; e = Math.max(e, i.times[i.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function us(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return ss; case "vector": case "vector2": case "vector3": case "vector4": return hs; case "color": return as; case "quaternion": return ls; case "bool": case "boolean": return rs; case "string": return cs }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], i = []; Za(e.keys, t, i, "value"), e.times = t, e.values = i } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const As = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class ps { constructor(e, t, i) { const n = this; let r, a = !1, s = 0, o = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) { o++, !1 === a && void 0 !== n.onStart && n.onStart(e, s, o), a = !0 }, this.itemEnd = function (e) { s++, void 0 !== n.onProgress && n.onProgress(e, s, o), s === o && (a = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function (e) { void 0 !== n.onError && n.onError(e) }, this.resolveURL = function (e) { return r ? r(e) : e }, this.setURLModifier = function (e) { return r = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, i = l.length; t < i; t += 2) { const i = l[t], n = l[t + 1]; if (i.global && (i.lastIndex = 0), i.test(e)) return n } return null } } } const fs = new ps; class gs { constructor(e) { this.manager = void 0 !== e ? e : fs, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const i = this; return new Promise((function (n, r) { i.load(e, n, t, r) })) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } gs.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const ms = {}; class _s extends Error { constructor(e, t) { super(e), this.response = t } } class bs extends gs { constructor(e) { super(e), this.mimeType = "", this.responseType = "" } load(e, t, i, n) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = As.get(e); if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => { t && t(r), this.manager.itemEnd(e) }), 0), r; if (void 0 !== ms[e]) return void ms[e].push({ onLoad: t, onProgress: i, onError: n }); ms[e] = [], ms[e].push({ onLoad: t, onProgress: i, onError: n }); const a = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), s = this.mimeType, o = this.responseType; fetch(a).then((t => { if (200 === t.status || 0 === t.status) { if (t.status, "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t; const i = ms[e], n = t.body.getReader(), r = t.headers.get("X-File-Size") || t.headers.get("Content-Length"), a = r ? parseInt(r) : 0, s = 0 !== a; let o = 0; const l = new ReadableStream({ start(e) { !function t() { n.read().then((({ done: n, value: r }) => { if (n) e.close(); else { o += r.byteLength; const n = new ProgressEvent("progress", { lengthComputable: s, loaded: o, total: a }); for (let e = 0, t = i.length; e < t; e++) { const t = i[e]; t.onProgress && t.onProgress(n) } e.enqueue(r), t() } }), (t => { e.error(t) })) }() } }); return new Response(l) } throw new _s(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t) })).then((e => { switch (o) { case "arraybuffer": return e.arrayBuffer(); case "blob": return e.blob(); case "document": return e.text().then((e => (new DOMParser).parseFromString(e, s))); case "json": return e.json(); default: if ("" === s) return e.text(); { const t = /charset="?([^;"\s]*)"?/i.exec(s), i = t && t[1] ? t[1].toLowerCase() : void 0, n = new TextDecoder(i); return e.arrayBuffer().then((e => n.decode(e))) } } })).then((t => { As.add(e, t); const i = ms[e]; delete ms[e]; for (let e = 0, n = i.length; e < n; e++) { const n = i[e]; n.onLoad && n.onLoad(t) } })).catch((t => { const i = ms[e]; if (void 0 === i) throw this.manager.itemError(e), t; delete ms[e]; for (let e = 0, n = i.length; e < n; e++) { const n = i[e]; n.onError && n.onError(t) } this.manager.itemError(e) })).finally((() => { this.manager.itemEnd(e) })), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class vs extends gs { constructor(e) { super(e) } load(e, t, i, n) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, a = As.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function () { t && t(a), r.manager.itemEnd(e) }), 0), a; const s = Ot("img"); function o() { c(), As.add(e, this), t && t(this), r.manager.itemEnd(e) } function l(t) { c(), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e) } function c() { s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1) } return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s } } class Es extends gs { constructor(e) { super(e) } load(e, t, i, n) { const r = this, a = new Yr, s = new bs(this.manager); return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(r.withCredentials), s.load(e, (function (e) { let i; try { i = r.parse(e) } catch (e) { if (void 0 === n) return; n(e) } void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a.image.width = i.width, a.image.height = i.height, a.image.data = i.data), a.wrapS = void 0 !== i.wrapS ? i.wrapS : X, a.wrapT = void 0 !== i.wrapT ? i.wrapT : X, a.magFilter = void 0 !== i.magFilter ? i.magFilter : $, a.minFilter = void 0 !== i.minFilter ? i.minFilter : $, a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.colorSpace && (a.colorSpace = i.colorSpace), void 0 !== i.flipY && (a.flipY = i.flipY), void 0 !== i.format && (a.format = i.format), void 0 !== i.type && (a.type = i.type), void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps, a.minFilter = te), 1 === i.mipmapCount && (a.minFilter = $), void 0 !== i.generateMipmaps && (a.generateMipmaps = i.generateMipmaps), a.needsUpdate = !0, t && t(a, i) }), i, n), a } } class ys extends gs { constructor(e) { super(e) } load(e, t, i, n) { const r = new ii, a = new vs(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function (e) { r.image = e, r.needsUpdate = !0, void 0 !== t && t(r) }), i, n), r } } class xs extends An { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Dn(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t } } class Cs extends xs { constructor(e, t, i) { super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(An.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Dn(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const Is = new ki, Ss = new ci, ws = new ci; class Ms { constructor(e) { this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Qt(512, 512), this.map = null, this.mapPass = null, this.matrix = new ki, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new pa, this._frameExtents = new Qt(1, 1), this._viewportCount = 1, this._viewports = [new ni(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, i = this.matrix; Ss.setFromMatrixPosition(e.matrixWorld), t.position.copy(Ss), ws.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(ws), t.updateMatrixWorld(), Is.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Is), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(Is) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class Bs extends Ms { constructor() { super(new Sr(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, i = 2 * Mt * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far; i === t.fov && n === t.aspect && r === t.far || (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class Ts extends xs { constructor(e, t, i = 0, n = Math.PI / 3, r = 0, a = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(An.DEFAULT_UP), this.updateMatrix(), this.target = new An, this.distance = i, this.angle = n, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new Bs } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const Rs = new ki, Ds = new ci, Ls = new ci; class Us extends Ms { constructor() { super(new Sr(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Qt(4, 2), this._viewportCount = 6, this._viewports = [new ni(2, 1, 1, 1), new ni(0, 1, 1, 1), new ni(3, 1, 1, 1), new ni(1, 1, 1, 1), new ni(3, 0, 1, 1), new ni(1, 0, 1, 1)], this._cubeDirections = [new ci(1, 0, 0), new ci(-1, 0, 0), new ci(0, 0, 1), new ci(0, 0, -1), new ci(0, 1, 0), new ci(0, -1, 0)], this._cubeUps = [new ci(0, 1, 0), new ci(0, 1, 0), new ci(0, 1, 0), new ci(0, 1, 0), new ci(0, 0, 1), new ci(0, 0, -1)] } updateMatrices(e, t = 0) { const i = this.camera, n = this.matrix, r = e.distance || i.far; r !== i.far && (i.far = r, i.updateProjectionMatrix()), Ds.setFromMatrixPosition(e.matrixWorld), i.position.copy(Ds), Ls.copy(i.position), Ls.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(Ls), i.updateMatrixWorld(), n.makeTranslation(-Ds.x, -Ds.y, -Ds.z), Rs.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Rs) } } class Ps extends xs { constructor(e, t, i = 0, n = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new Us } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class Qs extends yr { constructor(e = -1, t = 1, i = 1, n = -1, r = .1, a = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = a, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, i, n, r, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2; let r = i - e, a = i + e, s = n + t, o = n - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; r += e * this.view.offsetX, a = r + e * this.view.width, s -= t * this.view.offsetY, o = s - t * this.view.height } this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } class Fs extends Ms { constructor() { super(new Qs(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class Ns extends xs { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(An.DEFAULT_UP), this.updateMatrix(), this.target = new An, this.shadow = new Fs } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class ks extends xs { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class Os { static extractUrlBase(e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class Gs extends gs { constructor(e) { super(e), this.isImageBitmapLoader = !0, this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, i, n) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, a = As.get(e); if (void 0 !== a) return r.manager.itemStart(e), a.then ? void a.then((i => { t && t(i), r.manager.itemEnd(e) })).catch((e => { n && n(e) })) : (setTimeout((function () { t && t(a), r.manager.itemEnd(e) }), 0), a); const s = {}; s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader; const o = fetch(e, s).then((function (e) { return e.blob() })).then((function (e) { return createImageBitmap(e, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function (i) { return As.add(e, i), t && t(i), r.manager.itemEnd(e), i })).catch((function (t) { n && n(t), As.remove(e), r.manager.itemError(e), r.manager.itemEnd(e) })); As.add(e, o), r.manager.itemStart(e) } } class Hs extends Sr { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0 } } class zs { constructor(e, t, i) { let n, r, a; switch (this.binding = e, this.valueSize = i, t) { case "quaternion": n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5; break; case "string": case "bool": n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i); break; default: n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i) }this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const i = this.buffer, n = this.valueSize, r = e * n + n; let a = this.cumulativeWeight; if (0 === a) { for (let e = 0; e !== n; ++e)i[r + e] = i[e]; a = t } else { a += t; const e = t / a; this._mixBufferRegion(i, r, 0, e, n) } this.cumulativeWeight = a } accumulateAdditive(e) { const t = this.buffer, i = this.valueSize, n = i * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, s = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) { const e = t * this._origIndex; this._mixBufferRegion(i, n, e, 1 - r, t) } a > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t); for (let e = t, r = t + t; e !== r; ++e)if (i[e] !== i[e + t]) { s.setValue(i, n); break } } saveOriginalState() { const e = this.binding, t = this.buffer, i = this.valueSize, n = i * this._origIndex; e.getValue(t, n); for (let e = i, r = n; e !== r; ++e)t[e] = t[n + e % i]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let i = e; i < t; i++)this.buffer[i] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let i = 0; i < this.valueSize; i++)this.buffer[t + i] = this.buffer[e + i] } _select(e, t, i, n, r) { if (n >= .5) for (let n = 0; n !== r; ++n)e[t + n] = e[i + n] } _slerp(e, t, i, n) { li.slerpFlat(e, t, e, t, e, i, n) } _slerpAdditive(e, t, i, n, r) { const a = this._workIndex * r; li.multiplyQuaternionsFlat(e, a, e, t, e, i), li.slerpFlat(e, t, e, t, e, a, n) } _lerp(e, t, i, n, r) { const a = 1 - n; for (let s = 0; s !== r; ++s) { const r = t + s; e[r] = e[r] * a + e[i + s] * n } } _lerpAdditive(e, t, i, n, r) { for (let a = 0; a !== r; ++a) { const r = t + a; e[r] = e[r] + e[i + a] * n } } } const Vs = "\\[\\]\\.:\\/", Ws = new RegExp("[" + Vs + "]", "g"), js = "[^" + Vs + "]", qs = "[^" + Vs.replace("\\.", "") + "]", Xs = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", js) + /(WCOD+)?/.source.replace("WCOD", qs) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", js) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", js) + "$"), Ys = ["material", "materials", "bones", "map"]; class Ks { constructor(e, t, i) { this.path = t, this.parsedPath = i || Ks.parseTrackName(t), this.node = Ks.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, i) { return e && e.isAnimationObjectGroup ? new Ks.Composite(e, t, i) : new Ks(e, t, i) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(Ws, "") } static parseTrackName(e) { const t = Xs.exec(e); if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, n = i.nodeName && i.nodeName.lastIndexOf("."); if (void 0 !== n && -1 !== n) { const e = i.nodeName.substring(n + 1); -1 !== Ys.indexOf(e) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = e) } if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i } static findNode(e, t) { if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const i = e.skeleton.getBoneByName(t); if (void 0 !== i) return i } if (e.children) { const i = function (e) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.name === t || r.uuid === t) return r; const a = i(r.children); if (a) return a } return null }, n = i(e.children); if (n) return n } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const i = this.resolvedProperty; for (let n = 0, r = i.length; n !== r; ++n)e[t++] = i[n] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const i = this.resolvedProperty; for (let n = 0, r = i.length; n !== r; ++n)i[n] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const i = this.resolvedProperty; for (let n = 0, r = i.length; n !== r; ++n)i[n] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const i = this.resolvedProperty; for (let n = 0, r = i.length; n !== r; ++n)i[n] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, i = t.objectName, n = t.propertyName; let r = t.propertyIndex; if (e || (e = Ks.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return; if (i) { let n = t.objectIndex; switch (i) { case "materials": if (!e.material) return; if (!e.material.materials) return; e = e.material.materials; break; case "bones": if (!e.skeleton) return; e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === n) { n = t; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) return; if (!e.material.map) return; e = e.material.map; break; default: if (void 0 === e[i]) return; e = e[i] }if (void 0 !== n) { if (void 0 === e[n]) return; e = e[n] } } const a = e[n]; if (void 0 === a) { t.nodeName; return } let s = this.Versioning.None; this.targetObject = e, !0 === e.isMaterial ? s = this.Versioning.NeedsUpdate : !0 === e.isObject3D && (s = this.Versioning.MatrixWorldNeedsUpdate); let o = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === n) { if (!e.geometry) return; if (!e.geometry.morphAttributes) return; void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r]) } o = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r } else void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n; this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][s] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Ks.Composite = class { constructor(e, t, i) { const n = i || Ks.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, n) } getValue(e, t) { this.bind(); const i = this._targetGroup.nCachedObjects_, n = this._bindings[i]; void 0 !== n && n.getValue(e, t) } setValue(e, t) { const i = this._bindings; for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)i[n].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].unbind() } }, Ks.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ks.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ks.prototype.GetterByBindingType = [Ks.prototype._getValue_direct, Ks.prototype._getValue_array, Ks.prototype._getValue_arrayElement, Ks.prototype._getValue_toArray], Ks.prototype.SetterByBindingTypeAndVersioning = [[Ks.prototype._setValue_direct, Ks.prototype._setValue_direct_setNeedsUpdate, Ks.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ks.prototype._setValue_array, Ks.prototype._setValue_array_setNeedsUpdate, Ks.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ks.prototype._setValue_arrayElement, Ks.prototype._setValue_arrayElement_setNeedsUpdate, Ks.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ks.prototype._setValue_fromArray, Ks.prototype._setValue_fromArray_setNeedsUpdate, Ks.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class Js { constructor(e, t, i = null, n = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n; const r = t.tracks, a = r.length, s = new Array(a), o = { endingStart: it, endingEnd: it }; for (let e = 0; e !== a; ++e) { const t = r[e].createInterpolant(null); s[e] = t, t.settings = o } this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, i = !1) { if (e.fadeOut(t), this.fadeIn(t), !0 === i) { const i = this._clip.duration, n = e._clip.duration, r = n / i, a = i / n; e.warp(1, r, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, i = !1) { return e.crossFadeFrom(this, t, i) } stopFading() { const e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, i) { const n = this._mixer, r = n.time, a = this.timeScale; let s = this._timeScaleInterpolant; null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s); const o = s.parameterPositions, l = s.sampleValues; return o[0] = r, o[1] = r + i, l[0] = e / a, l[1] = t / a, this } stopWarping() { const e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, i, n) { if (!this.enabled) return void this._updateWeight(e); const r = this._startTime; if (null !== r) { const n = (e - r) * i; n < 0 || 0 === i ? t = 0 : (this._startTime = null, t = i * n) } t *= this._updateTimeScale(e); const a = this._updateTime(t), s = this._updateWeight(e); if (s > 0) { const e = this._interpolants, t = this._propertyBindings; if (2501 === this.blendMode) for (let i = 0, n = e.length; i !== n; ++i)e[i].evaluate(a), t[i].accumulateAdditive(s); else for (let i = 0, r = e.length; i !== r; ++i)e[i].evaluate(a), t[i].accumulate(n, s) } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const i = this._weightInterpolant; if (null !== i) { const n = i.evaluate(e)[0]; t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const i = this._timeScaleInterpolant; if (null !== i) { t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, i = this.loop; let n = this.time + e, r = this._loopCount; const a = 2202 === i; if (0 === e) return -1 === r || !a || 1 & ~r ? n : t - n; if (2200 === i) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (n >= t) n = t; else { if (!(n < 0)) { this.time = n; break e } n = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = n, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), n >= t || n < 0) { const i = Math.floor(n / t); n -= t * i, r += Math.abs(i); const s = this.repetitions - r; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === s) { const t = e < 0; this._setEndings(t, !t, a) } else this._setEndings(!1, !1, a); this._loopCount = r, this.time = n, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i }) } } else this.time = n; if (a && !(1 & ~r)) return t - n } return n } _setEndings(e, t, i) { const n = this._interpolantSettings; i ? (n.endingStart = nt, n.endingEnd = nt) : (n.endingStart = e ? this.zeroSlopeAtStart ? nt : it : rt, n.endingEnd = t ? this.zeroSlopeAtEnd ? nt : it : rt) } _scheduleFading(e, t, i) { const n = this._mixer, r = n.time; let a = this._weightInterpolant; null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a); const s = a.parameterPositions, o = a.sampleValues; return s[0] = r, o[0] = t, s[1] = r + e, o[1] = i, this } } const Zs = new Float32Array(1); class $s extends Ct { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, a = e._propertyBindings, s = e._interpolants, o = i.uuid, l = this._bindingsByRootAndName; let c = l[o]; void 0 === c && (c = {}, l[o] = c); for (let e = 0; e !== r; ++e) { const r = n[e], l = r.name; let h = c[l]; if (void 0 !== h) ++h.referenceCount, a[e] = h; else { if (h = a[e], void 0 !== h) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l)); continue } const n = t && t._propertyBindings[e].binding.parsedPath; h = new zs(Ks.create(i, l, n), r.ValueTypeName, r.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), a[e] = h } s[e].resultBuffer = h.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { const t = (e._localRoot || this._root).uuid, i = e._clip.uuid, n = this._actionsByClip[i]; this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t) } const t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { const i = t[e]; 0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { const i = t[e]; 0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, i) { const n = this._actions, r = this._actionsByClip; let a = r[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = a; else { const t = a.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e } _removeInactiveAction(e) { const t = this._actions, i = t[t.length - 1], n = e._cacheIndex; i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null; const r = e._clip.uuid, a = this._actionsByClip, s = a[r], o = s.knownActions, l = o[o.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null; delete s.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { const i = t[e]; 0 == --i.referenceCount && this._removeInactiveBinding(i) } } _lendAction(e) { const t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r } _takeBackAction(e) { const t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r } _addInactiveBinding(e, t, i) { const n = this._bindingsByRootAndName, r = this._bindings; let a = n[t]; void 0 === a && (a = {}, n[t] = a), a[i] = e, e._cacheIndex = r.length, r.push(e) } _removeInactiveBinding(e) { const t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, s = a[n], o = t[t.length - 1], l = e._cacheIndex; o._cacheIndex = l, t[l] = o, t.pop(), delete s[r], 0 === Object.keys(s).length && delete a[n] } _lendBinding(e) { const t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r } _takeBackBinding(e) { const t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let i = e[t]; return void 0 === i && (i = new ts(new Float32Array(2), new Float32Array(2), 1, Zs), i.__cacheIndex = t, e[t] = i), i } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n]; e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r } clipAction(e, t, i) { const n = t || this._root, r = n.uuid; let a = "string" == typeof e ? ds.findByName(n, e) : e; const s = null !== a ? a.uuid : e, o = this._actionsByClip[s]; let l = null; if (void 0 === i && (i = null !== a ? a.blendMode : at), void 0 !== o) { const e = o.actionByRoot[r]; if (void 0 !== e && e.blendMode === i) return e; l = o.knownActions[0], null === a && (a = l._clip) } if (null === a) return null; const c = new Js(this, a, t, i); return this._bindAction(c, l), this._addInactiveAction(c, s, r), c } existingAction(e, t) { const i = t || this._root, n = i.uuid, r = "string" == typeof e ? ds.findByName(i, e) : e, a = r ? r.uuid : e, s = this._actionsByClip[a]; return void 0 !== s && s.actionByRoot[n] || null } stopAllAction() { const e = this._actions; for (let t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1; for (let s = 0; s !== i; ++s) { t[s]._update(n, e, r, a) } const s = this._bindings, o = this._nActiveBindings; for (let e = 0; e !== o; ++e)s[e].apply(a); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i]; if (void 0 !== r) { const e = r.knownActions; for (let i = 0, n = e.length; i !== n; ++i) { const n = e[i]; this._deactivateAction(n); const r = n._cacheIndex, a = t[t.length - 1]; n._cacheIndex = null, n._byClipCacheIndex = null, a._cacheIndex = r, t[r] = a, t.pop(), this._removeInactiveBindingsForAction(n) } delete n[i] } } uncacheRoot(e) { const t = e.uuid, i = this._actionsByClip; for (const e in i) { const n = i[e].actionByRoot[t]; void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } const n = this._bindingsByRootAndName[t]; if (void 0 !== n) for (const e in n) { const t = n[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { const i = this.existingAction(e, t); null !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } } const eo = new ki; class to { constructor(e, t, i = 0, n = 1 / 0) { this.ray = new Ni(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new Ki, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera && (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) } setFromXRController(e) { return eo.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(eo), this } intersectObject(e, t = !0, i = []) { return no(e, this, i, t), i.sort(io), i } intersectObjects(e, t = !0, i = []) { for (let n = 0, r = e.length; n < r; n++)no(e[n], this, i, t); return i.sort(io), i } } function io(e, t) { return e.distance - t.distance } function no(e, t, i, n) { let r = !0; if (e.layers.test(t.layers)) { !1 === e.raycast(t, i) && (r = !1) } if (!0 === r && !0 === n) { const n = e.children; for (let e = 0, r = n.length; e < r; e++)no(n[e], t, i, !0) } } class ro { constructor(e = 1, t = 0, i = 0) { this.radius = e, this.phi = t, this.theta = i } set(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { const e = 1e-6; return this.phi = Tt(this.phi, e, Math.PI - e), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Tt(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } const ao = new ci, so = new ki, oo = new ki; class lo extends wa { constructor(e) { const t = co(e), i = new ir, n = [], r = [], a = new Dn(0, 0, 1), s = new Dn(0, 1, 0); for (let e = 0; e < t.length; e++) { const i = t[e]; i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b)) } i.setAttribute("position", new Xn(n, 3)), i.setAttribute("color", new Xn(r, 3)); super(i, new fa({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, i = this.geometry, n = i.getAttribute("position"); oo.copy(this.root.matrixWorld).invert(); for (let e = 0, i = 0; e < t.length; e++) { const r = t[e]; r.parent && r.parent.isBone && (so.multiplyMatrices(oo, r.matrixWorld), ao.setFromMatrixPosition(so), n.setXYZ(i, ao.x, ao.y, ao.z), so.multiplyMatrices(oo, r.parent.matrixWorld), ao.setFromMatrixPosition(so), n.setXYZ(i + 1, ao.x, ao.y, ao.z), i += 2) } i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function co(e) { const t = []; !0 === e.isBone && t.push(e); for (let i = 0; i < e.children.length; i++)t.push(...co(e.children[i])); return t } class ho extends wa { constructor(e = 10, t = 10, i = 4473924, n = 8947848) { i = new Dn(i), n = new Dn(n); const r = t / 2, a = e / t, s = e / 2, o = [], l = []; for (let e = 0, c = 0, h = -s; e <= t; e++, h += a) { o.push(-s, 0, h, s, 0, h), o.push(h, 0, -s, h, 0, s); const t = e === r ? i : n; t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3 } const c = new ir; c.setAttribute("position", new Xn(o, 3)), c.setAttribute("color", new Xn(l, 3)); super(c, new fa({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class uo extends wa { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = new ir; i.setAttribute("position", new Xn(t, 3)), i.setAttribute("color", new Xn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); super(i, new fa({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } setColors(e, t, i) { const n = new Dn, r = this.geometry.attributes.color.array; return n.set(e), n.toArray(r, 0), n.toArray(r, 3), n.set(t), n.toArray(r, 6), n.toArray(r, 9), n.set(i), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class Ao extends Ct { constructor(e, t = null) { super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null } } connect(e) { void 0 !== e && (null !== this.domElement && this.disconnect(), this.domElement = e) } disconnect() { } dispose() { } update() { } } function po(e, t, i, n) { const r = function (e) { switch (e) { case ie: case ne: return { byteLength: 1, components: 1 }; case ae: case re: case ce: return { byteLength: 2, components: 1 }; case he: case de: return { byteLength: 2, components: 4 }; case oe: case se: case le: return { byteLength: 4, components: 1 }; case Ae: return { byteLength: 4, components: 3 } }throw new Error(`Unknown texture type ${e}.`) }(n); switch (i) { case 1021: case 1024: return e * t; case 1025: return e * t * 2; case me: case _e: return e * t / r.components * r.byteLength; case be: case ve: return e * t * 2 / r.components * r.byteLength; case 1022: return e * t * 3 / r.components * r.byteLength; case pe: case Ee: return e * t * 4 / r.components * r.byteLength; case ye: case xe: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8; case Ce: case Ie: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16; case we: case Be: return Math.max(e, 16) * Math.max(t, 8) / 4; case Se: case Me: return Math.max(e, 8) * Math.max(t, 8) / 2; case Te: case Re: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8; case De: case Le: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16; case Ue: return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16; case Pe: return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16; case Qe: return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16; case Fe: return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16; case Ne: return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16; case ke: return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16; case Oe: return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16; case Ge: return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16; case He: return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16; case ze: return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16; case Ve: return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16; case We: return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16; case je: return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16; case qe: case Xe: case Ye: return Math.ceil(e / 4) * Math.ceil(t / 4) * 16; case 36283: case Ke: return Math.ceil(e / 4) * Math.ceil(t / 4) * 8; case Je: case Ze: return Math.ceil(e / 4) * Math.ceil(t / 4) * 16 }throw new Error(`Unable to determine texture byte length for ${i} format.`) } function fo() { let e = null, t = !1, i = null, n = null; function r(t, a) { i(t, a), n = e.requestAnimationFrame(r) } return { start: function () { !0 !== t && null !== i && (n = e.requestAnimationFrame(r), t = !0) }, stop: function () { e.cancelAnimationFrame(n), t = !1 }, setAnimationLoop: function (e) { i = e }, setContext: function (t) { e = t } } } function go(e) { const t = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), t.get(e) }, remove: function (i) { i.isInterleavedBufferAttribute && (i = i.data); const n = t.get(i); n && (e.deleteBuffer(n.buffer), t.delete(i)) }, update: function (i, n) { if (i.isInterleavedBufferAttribute && (i = i.data), i.isGLBufferAttribute) { const e = t.get(i); return void ((!e || e.version < i.version) && t.set(i, { buffer: i.buffer, type: i.type, bytesPerElement: i.elementSize, version: i.version })) } const r = t.get(i); if (void 0 === r) t.set(i, function (t, i) { const n = t.array, r = t.usage, a = n.byteLength, s = e.createBuffer(); let o; if (e.bindBuffer(i, s), e.bufferData(i, n, r), t.onUploadCallback(), n instanceof Float32Array) o = e.FLOAT; else if (n instanceof Uint16Array) o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT; else if (n instanceof Int16Array) o = e.SHORT; else if (n instanceof Uint32Array) o = e.UNSIGNED_INT; else if (n instanceof Int32Array) o = e.INT; else if (n instanceof Int8Array) o = e.BYTE; else if (n instanceof Uint8Array) o = e.UNSIGNED_BYTE; else { if (!(n instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + n); o = e.UNSIGNED_BYTE } return { buffer: s, type: o, bytesPerElement: n.BYTES_PER_ELEMENT, version: t.version, size: a } }(i, n)); else if (r.version < i.version) { if (r.size !== i.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); !function (t, i, n) { const r = i.array, a = i.updateRanges; if (e.bindBuffer(n, t), 0 === a.length) e.bufferSubData(n, 0, r); else { a.sort(((e, t) => e.start - t.start)); let t = 0; for (let e = 1; e < a.length; e++) { const i = a[t], n = a[e]; n.start <= i.start + i.count + 1 ? i.count = Math.max(i.count, n.start + n.count - i.start) : (++t, a[t] = n) } a.length = t + 1; for (let t = 0, i = a.length; t < i; t++) { const i = a[t]; e.bufferSubData(n, i.start * r.BYTES_PER_ELEMENT, r, i.start, i.count) } i.clearUpdateRanges() } i.onUploadCallback() }(r.buffer, i, n), r.version = i.version } } } } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: r } })), "undefined" != typeof window && (window.__THREE__ || (window.__THREE__ = r)); const mo = { alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif", alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif", alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif", batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif", begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;", normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif", opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif", uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif", uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif", uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}" }, _o = { common: { diffuse: { value: new Dn(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Ft }, alphaMap: { value: null }, alphaMapTransform: { value: new Ft }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Ft } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Ft }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Ft } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Ft } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Ft }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Ft }, normalScale: { value: new Qt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Ft }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Ft } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Ft } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Ft } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Dn(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Dn(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Ft }, alphaTest: { value: 0 }, uvTransform: { value: new Ft } }, sprite: { diffuse: { value: new Dn(16777215) }, opacity: { value: 1 }, center: { value: new Qt(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Ft }, alphaMap: { value: null }, alphaMapTransform: { value: new Ft }, alphaTest: { value: 0 } } }, bo = { basic: { uniforms: _r([_o.common, _o.specularmap, _o.envmap, _o.aomap, _o.lightmap, _o.fog]), vertexShader: mo.meshbasic_vert, fragmentShader: mo.meshbasic_frag }, lambert: { uniforms: _r([_o.common, _o.specularmap, _o.envmap, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.fog, _o.lights, { emissive: { value: new Dn(0) } }]), vertexShader: mo.meshlambert_vert, fragmentShader: mo.meshlambert_frag }, phong: { uniforms: _r([_o.common, _o.specularmap, _o.envmap, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.fog, _o.lights, { emissive: { value: new Dn(0) }, specular: { value: new Dn(1118481) }, shininess: { value: 30 } }]), vertexShader: mo.meshphong_vert, fragmentShader: mo.meshphong_frag }, standard: { uniforms: _r([_o.common, _o.envmap, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.roughnessmap, _o.metalnessmap, _o.fog, _o.lights, { emissive: { value: new Dn(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: mo.meshphysical_vert, fragmentShader: mo.meshphysical_frag }, toon: { uniforms: _r([_o.common, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.gradientmap, _o.fog, _o.lights, { emissive: { value: new Dn(0) } }]), vertexShader: mo.meshtoon_vert, fragmentShader: mo.meshtoon_frag }, matcap: { uniforms: _r([_o.common, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.fog, { matcap: { value: null } }]), vertexShader: mo.meshmatcap_vert, fragmentShader: mo.meshmatcap_frag }, points: { uniforms: _r([_o.points, _o.fog]), vertexShader: mo.points_vert, fragmentShader: mo.points_frag }, dashed: { uniforms: _r([_o.common, _o.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: mo.linedashed_vert, fragmentShader: mo.linedashed_frag }, depth: { uniforms: _r([_o.common, _o.displacementmap]), vertexShader: mo.depth_vert, fragmentShader: mo.depth_frag }, normal: { uniforms: _r([_o.common, _o.bumpmap, _o.normalmap, _o.displacementmap, { opacity: { value: 1 } }]), vertexShader: mo.meshnormal_vert, fragmentShader: mo.meshnormal_frag }, sprite: { uniforms: _r([_o.sprite, _o.fog]), vertexShader: mo.sprite_vert, fragmentShader: mo.sprite_frag }, background: { uniforms: { uvTransform: { value: new Ft }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: mo.background_vert, fragmentShader: mo.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Ft } }, vertexShader: mo.backgroundCube_vert, fragmentShader: mo.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: mo.cube_vert, fragmentShader: mo.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: mo.equirect_vert, fragmentShader: mo.equirect_frag }, distanceRGBA: { uniforms: _r([_o.common, _o.displacementmap, { referencePosition: { value: new ci }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: mo.distanceRGBA_vert, fragmentShader: mo.distanceRGBA_frag }, shadow: { uniforms: _r([_o.lights, _o.fog, { color: { value: new Dn(0) }, opacity: { value: 1 } }]), vertexShader: mo.shadow_vert, fragmentShader: mo.shadow_frag } }; bo.physical = { uniforms: _r([bo.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Ft }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Ft }, clearcoatNormalScale: { value: new Qt(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Ft }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Ft }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Ft }, sheen: { value: 0 }, sheenColor: { value: new Dn(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Ft }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Ft }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Ft }, transmissionSamplerSize: { value: new Qt }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Ft }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Dn(0) }, specularColor: { value: new Dn(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Ft }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Ft }, anisotropyVector: { value: new Qt }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Ft } }]), vertexShader: mo.meshphysical_vert, fragmentShader: mo.meshphysical_frag }; const vo = { r: 0, b: 0, g: 0 }, Eo = new Yi, yo = new ki; function xo(e, t, i, n, r, a, s) { const o = new Dn(0); let l, c, h = !0 === a ? 0 : 1, d = null, u = 0, A = null; function p(e) { let n = !0 === e.isScene ? e.background : null; if (n && n.isTexture) { n = (e.backgroundBlurriness > 0 ? i : t).get(n) } return n } function f(t, i) { t.getRGB(vo, br(e)), n.buffers.color.setClear(vo.r, vo.g, vo.b, i, s) } return { getClearColor: function () { return o }, setClearColor: function (e, t = 1) { o.set(e), h = t, f(o, h) }, getClearAlpha: function () { return h }, setClearAlpha: function (e) { h = e, f(o, h) }, render: function (t) { let i = !1; const r = p(t); null === r ? f(o, h) : r && r.isColor && (f(r, 1), i = !0); const a = e.xr.getEnvironmentBlendMode(); "additive" === a ? n.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === a && n.buffers.color.setClear(0, 0, 0, 0, s), (e.autoClear || i) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)) }, addToRenderList: function (t, i) { const n = p(i); n && (n.isCubeTexture || n.mapping === j) ? (void 0 === c && (c = new pr(new gr(1, 1, 1), new Er({ name: "BackgroundCubeMaterial", uniforms: mr(bo.backgroundCube.uniforms), vertexShader: bo.backgroundCube.vertexShader, fragmentShader: bo.backgroundCube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1, allowOverride: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (e, t, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(c.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(c)), Eo.copy(i.backgroundRotation), Eo.x *= -1, Eo.y *= -1, Eo.z *= -1, n.isCubeTexture && !1 === n.isRenderTargetTexture && (Eo.y *= -1, Eo.z *= -1), c.material.uniforms.envMap.value = n, c.material.uniforms.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = i.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = i.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(yo.makeRotationFromEuler(Eo)), c.material.toneMapped = qt.getTransfer(n.colorSpace) !== ht, d === n && u === n.version && A === e.toneMapping || (c.material.needsUpdate = !0, d = n, u = n.version, A = e.toneMapping), c.layers.enableAll(), t.unshift(c, c.geometry, c.material, 0, 0, null)) : n && n.isTexture && (void 0 === l && (l = new pr(new Ha(2, 2), new Er({ name: "BackgroundMaterial", uniforms: mr(bo.background.uniforms), vertexShader: bo.background.vertexShader, fragmentShader: bo.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1, allowOverride: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(l)), l.material.uniforms.t2D.value = n, l.material.uniforms.backgroundIntensity.value = i.backgroundIntensity, l.material.toneMapped = qt.getTransfer(n.colorSpace) !== ht, !0 === n.matrixAutoUpdate && n.updateMatrix(), l.material.uniforms.uvTransform.value.copy(n.matrix), d === n && u === n.version && A === e.toneMapping || (l.material.needsUpdate = !0, d = n, u = n.version, A = e.toneMapping), l.layers.enableAll(), t.unshift(l, l.geometry, l.material, 0, 0, null)) }, dispose: function () { void 0 !== c && (c.geometry.dispose(), c.material.dispose(), c = void 0), void 0 !== l && (l.geometry.dispose(), l.material.dispose(), l = void 0) } } } function Co(e, t) { const i = e.getParameter(e.MAX_VERTEX_ATTRIBS), n = {}, r = c(null); let a = r, s = !1; function o(t) { return e.bindVertexArray(t) } function l(t) { return e.deleteVertexArray(t) } function c(e) { const t = [], n = [], r = []; for (let e = 0; e < i; e++)t[e] = 0, n[e] = 0, r[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: r, object: e, attributes: {}, index: null } } function h() { const e = a.newAttributes; for (let t = 0, i = e.length; t < i; t++)e[t] = 0 } function d(e) { u(e, 0) } function u(t, i) { const n = a.newAttributes, r = a.enabledAttributes, s = a.attributeDivisors; n[t] = 1, 0 === r[t] && (e.enableVertexAttribArray(t), r[t] = 1), s[t] !== i && (e.vertexAttribDivisor(t, i), s[t] = i) } function A() { const t = a.newAttributes, i = a.enabledAttributes; for (let n = 0, r = i.length; n < r; n++)i[n] !== t[n] && (e.disableVertexAttribArray(n), i[n] = 0) } function p(t, i, n, r, a, s, o) { !0 === o ? e.vertexAttribIPointer(t, i, n, a, s) : e.vertexAttribPointer(t, i, n, r, a, s) } function f() { g(), s = !0, a !== r && (a = r, o(a.object)) } function g() { r.geometry = null, r.program = null, r.wireframe = !1 } return { setup: function (i, r, l, f, g) { let m = !1; const _ = function (t, i, r) { const a = !0 === r.wireframe; let s = n[t.id]; void 0 === s && (s = {}, n[t.id] = s); let o = s[i.id]; void 0 === o && (o = {}, s[i.id] = o); let l = o[a]; void 0 === l && (l = c(e.createVertexArray()), o[a] = l); return l }(f, l, r); a !== _ && (a = _, o(a.object)), m = function (e, t, i, n) { const r = a.attributes, s = t.attributes; let o = 0; const l = i.getAttributes(); for (const t in l) { if (l[t].location >= 0) { const i = r[t]; let n = s[t]; if (void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor)), void 0 === i) return !0; if (i.attribute !== n) return !0; if (n && i.data !== n.data) return !0; o++ } } return a.attributesNum !== o || a.index !== n }(i, f, l, g), m && function (e, t, i, n) { const r = {}, s = t.attributes; let o = 0; const l = i.getAttributes(); for (const t in l) { if (l[t].location >= 0) { let i = s[t]; void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)); const n = {}; n.attribute = i, i && i.data && (n.data = i.data), r[t] = n, o++ } } a.attributes = r, a.attributesNum = o, a.index = n }(i, f, l, g), null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER), (m || s) && (s = !1, function (i, n, r, a) { h(); const s = a.attributes, o = r.getAttributes(), l = n.defaultAttributeValues; for (const n in o) { const r = o[n]; if (r.location >= 0) { let o = s[n]; if (void 0 === o && ("instanceMatrix" === n && i.instanceMatrix && (o = i.instanceMatrix), "instanceColor" === n && i.instanceColor && (o = i.instanceColor)), void 0 !== o) { const n = o.normalized, s = o.itemSize, l = t.get(o); if (void 0 === l) continue; const c = l.buffer, h = l.type, A = l.bytesPerElement, f = h === e.INT || h === e.UNSIGNED_INT || o.gpuType === se; if (o.isInterleavedBufferAttribute) { const t = o.data, l = t.stride, g = o.offset; if (t.isInstancedInterleavedBuffer) { for (let e = 0; e < r.locationSize; e++)u(r.location + e, t.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = t.meshPerAttribute * t.count) } else for (let e = 0; e < r.locationSize; e++)d(r.location + e); e.bindBuffer(e.ARRAY_BUFFER, c); for (let e = 0; e < r.locationSize; e++)p(r.location + e, s / r.locationSize, h, n, l * A, (g + s / r.locationSize * e) * A, f) } else { if (o.isInstancedBufferAttribute) { for (let e = 0; e < r.locationSize; e++)u(r.location + e, o.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count) } else for (let e = 0; e < r.locationSize; e++)d(r.location + e); e.bindBuffer(e.ARRAY_BUFFER, c); for (let e = 0; e < r.locationSize; e++)p(r.location + e, s / r.locationSize, h, n, s * A, s / r.locationSize * e * A, f) } } else if (void 0 !== l) { const t = l[n]; if (void 0 !== t) switch (t.length) { case 2: e.vertexAttrib2fv(r.location, t); break; case 3: e.vertexAttrib3fv(r.location, t); break; case 4: e.vertexAttrib4fv(r.location, t); break; default: e.vertexAttrib1fv(r.location, t) } } } } A() }(i, r, l, f), null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer)) }, reset: f, resetDefaultState: g, dispose: function () { f(); for (const e in n) { const t = n[e]; for (const e in t) { const i = t[e]; for (const e in i) l(i[e].object), delete i[e]; delete t[e] } delete n[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === n[e.id]) return; const t = n[e.id]; for (const e in t) { const i = t[e]; for (const e in i) l(i[e].object), delete i[e]; delete t[e] } delete n[e.id] }, releaseStatesOfProgram: function (e) { for (const t in n) { const i = n[t]; if (void 0 === i[e.id]) continue; const r = i[e.id]; for (const e in r) l(r[e].object), delete r[e]; delete i[e.id] } }, initAttributes: h, enableAttribute: d, disableUnusedAttributes: A } } function Io(e, t, i) { let n; function r(t, r, a) { 0 !== a && (e.drawArraysInstanced(n, t, r, a), i.update(r, n, a)) } this.setMode = function (e) { n = e }, this.render = function (t, r) { e.drawArrays(n, t, r), i.update(r, n, 1) }, this.renderInstances = r, this.renderMultiDraw = function (e, r, a) { if (0 === a) return; t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, e, 0, r, 0, a); let s = 0; for (let e = 0; e < a; e++)s += r[e]; i.update(s, n, 1) }, this.renderMultiDrawInstances = function (e, a, s, o) { if (0 === s) return; const l = t.get("WEBGL_multi_draw"); if (null === l) for (let t = 0; t < e.length; t++)r(e[t], a[t], o[t]); else { l.multiDrawArraysInstancedWEBGL(n, e, 0, a, 0, o, 0, s); let t = 0; for (let e = 0; e < s; e++)t += a[e] * o[e]; i.update(t, n, 1) } } } function So(e, t, i, n) { let r; function a(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let s = void 0 !== i.precision ? i.precision : "highp"; const o = a(s); o !== s && (s = o); const l = !0 === i.logarithmicDepthBuffer, c = !0 === i.reverseDepthBuffer && t.has("EXT_clip_control"), h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS); return { isWebGL2: !0, getMaxAnisotropy: function () { if (void 0 !== r) return r; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const i = t.get("EXT_texture_filter_anisotropic"); r = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r }, getMaxPrecision: a, textureFormatReadable: function (t) { return t === pe || n.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT) }, textureTypeReadable: function (i) { const r = i === ce && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float")); return !(i !== ie && n.convert(i) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && i !== le && !r) }, precision: s, logarithmicDepthBuffer: l, reverseDepthBuffer: c, maxTextures: h, maxVertexTextures: d, maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE), maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS), maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS), maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures: d > 0, maxSamples: e.getParameter(e.MAX_SAMPLES) } } function wo(e) { const t = this; let i = null, n = 0, r = !1, a = !1; const s = new da, o = new Ft, l = { value: null, needsUpdate: !1 }; function c(e, i, n, r) { const a = null !== e ? e.length : 0; let c = null; if (0 !== a) { if (c = l.value, !0 !== r || null === c) { const t = n + 4 * a, r = i.matrixWorldInverse; o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, i = n; t !== a; ++t, i += 4)s.copy(e[t]).applyMatrix4(r, o), s.normal.toArray(c, i), c[i + 3] = s.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = a, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t) { const i = 0 !== e.length || t || 0 !== n || r; return r = t, n = e.length, i }, this.beginShadows = function () { a = !0, c(null) }, this.endShadows = function () { a = !1 }, this.setGlobalState = function (e, t) { i = c(e, t, 0) }, this.setState = function (s, o, h) { const d = s.clippingPlanes, u = s.clipIntersection, A = s.clipShadows, p = e.get(s); if (!r || null === d || 0 === d.length || a && !A) a ? c(null) : function () { l.value !== i && (l.value = i, l.needsUpdate = n > 0); t.numPlanes = n, t.numIntersection = 0 }(); else { const e = a ? 0 : n, t = 4 * e; let r = p.clippingState || null; l.value = r, r = c(d, o, t, h); for (let e = 0; e !== t; ++e)r[e] = i[e]; p.clippingState = r, this.numIntersection = u ? this.numPlanes : 0, this.numPlanes += e } } } function Mo(e) { let t = new WeakMap; function i(e, t) { return t === V ? e.mapping = H : t === W && (e.mapping = z), e } function n(e) { const i = e.target; i.removeEventListener("dispose", n); const r = t.get(i); void 0 !== r && (t.delete(i), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const a = r.mapping; if (a === V || a === W) { if (t.has(r)) { return i(t.get(r).texture, r.mapping) } { const a = r.image; if (a && a.height > 0) { const s = new Tr(a.height); return s.fromEquirectangularTexture(e, r), t.set(r, s), r.addEventListener("dispose", n), i(s.texture, r.mapping) } return null } } } return r }, dispose: function () { t = new WeakMap } } } const Bo = [.125, .215, .35, .446, .526, .582], To = 20, Ro = new Qs, Do = new Dn; let Lo = null, Uo = 0, Po = 0, Qo = !1; const Fo = (1 + Math.sqrt(5)) / 2, No = 1 / Fo, ko = [new ci(-Fo, No, 0), new ci(Fo, No, 0), new ci(-No, 0, Fo), new ci(No, 0, Fo), new ci(0, Fo, -No), new ci(0, Fo, No), new ci(-1, 1, -1), new ci(1, 1, -1), new ci(-1, 1, 1), new ci(1, 1, 1)], Oo = new ci; class Go { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, i = .1, n = 100, r = {}) { const { size: a = 256, position: s = Oo } = r; Lo = this._renderer.getRenderTarget(), Uo = this._renderer.getActiveCubeFace(), Po = this._renderer.getActiveMipmapLevel(), Qo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a); const o = this._allocateTargets(); return o.depthBuffer = !0, this._sceneToCubeUV(e, i, n, o, s), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = Wo(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = Vo(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(Lo, Uo, Po), this._renderer.xr.enabled = Qo, e.scissorTest = !1, zo(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === H || e.mapping === z ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Lo = this._renderer.getRenderTarget(), Uo = this._renderer.getActiveCubeFace(), Po = this._renderer.getActiveMipmapLevel(), Qo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1; const i = t || this._allocateTargets(); return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: $, minFilter: $, generateMipmaps: !1, type: ce, format: pe, colorSpace: lt, depthBuffer: !1 }, n = Ho(e, t, i); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Ho(e, t, i); const { _lodMax: n } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (e) { const t = [], i = [], n = []; let r = e; const a = e - 4 + 1 + Bo.length; for (let s = 0; s < a; s++) { const a = Math.pow(2, r); i.push(a); let o = 1 / a; s > e - 4 ? o = Bo[s - e + 4 - 1] : 0 === s && (o = 0), n.push(o); const l = 1 / (a - 2), c = -l, h = 1 + l, d = [c, c, h, c, h, h, c, c, h, h, c, h], u = 6, A = 6, p = 3, f = 2, g = 1, m = new Float32Array(p * A * u), _ = new Float32Array(f * A * u), b = new Float32Array(g * A * u); for (let e = 0; e < u; e++) { const t = e % 3 * 2 / 3 - 1, i = e > 2 ? 0 : -1, n = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0]; m.set(n, p * A * e), _.set(d, f * A * e); const r = [e, e, e, e, e, e]; b.set(r, g * A * e) } const v = new ir; v.setAttribute("position", new Wn(m, p)), v.setAttribute("uv", new Wn(_, f)), v.setAttribute("faceIndex", new Wn(b, g)), t.push(v), r > 4 && r-- } return { lodPlanes: t, sizeLods: i, sigmas: n } }(n)), this._blurMaterial = function (e, t, i) { const n = new Float32Array(To), r = new ci(0, 1, 0), a = new Er({ name: "SphericalGaussianBlur", defines: { n: To, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / i, CUBEUV_MAX_MIP: `${e}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: jo(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }); return a }(n, e, t) } return n } _compileMaterial(e) { const t = new pr(this._lodPlanes[0], e); this._renderer.compile(t, Ro) } _sceneToCubeUV(e, t, i, n, r) { const a = new Sr(90, 1, t, i), s = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], l = this._renderer, c = l.autoClear, h = l.toneMapping; l.getClearColor(Do), l.toneMapping = 0, l.autoClear = !1; const d = new Qn({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }), u = new pr(new gr, d); let A = !1; const p = e.background; p ? p.isColor && (d.color.copy(p), e.background = null, A = !0) : (d.color.copy(Do), A = !0); for (let t = 0; t < 6; t++) { const i = t % 3; 0 === i ? (a.up.set(0, s[t], 0), a.position.set(r.x, r.y, r.z), a.lookAt(r.x + o[t], r.y, r.z)) : 1 === i ? (a.up.set(0, 0, s[t]), a.position.set(r.x, r.y, r.z), a.lookAt(r.x, r.y + o[t], r.z)) : (a.up.set(0, s[t], 0), a.position.set(r.x, r.y, r.z), a.lookAt(r.x, r.y, r.z + o[t])); const c = this._cubeSize; zo(n, i * c, t > 2 ? c : 0, c, c), l.setRenderTarget(n), A && l.render(u, a), l.render(e, a) } u.geometry.dispose(), u.material.dispose(), l.toneMapping = h, l.autoClear = c, e.background = p } _textureToCubeUV(e, t) { const i = this._renderer, n = e.mapping === H || e.mapping === z; n ? (null === this._cubemapMaterial && (this._cubemapMaterial = Wo()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Vo()); const r = n ? this._cubemapMaterial : this._equirectMaterial, a = new pr(this._lodPlanes[0], r); r.uniforms.envMap.value = e; const s = this._cubeSize; zo(t, 0, 0, 3 * s, 2 * s), i.setRenderTarget(t), i.render(a, Ro) } _applyPMREM(e) { const t = this._renderer, i = t.autoClear; t.autoClear = !1; const n = this._lodPlanes.length; for (let t = 1; t < n; t++) { const i = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]), r = ko[(n - t - 1) % ko.length]; this._blur(e, t - 1, t, i, r) } t.autoClear = i } _blur(e, t, i, n, r) { const a = this._pingPongRenderTarget; this._halfBlur(e, a, t, i, n, "latitudinal", r), this._halfBlur(a, e, i, i, n, "longitudinal", r) } _halfBlur(e, t, i, n, r, a, s) { const o = this._renderer, l = this._blurMaterial, c = new pr(this._lodPlanes[n], l), h = l.uniforms, d = this._sizeLods[i] - 1, u = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / 39, A = r / u, p = isFinite(r) ? 1 + Math.floor(3 * A) : To, f = []; let g = 0; for (let e = 0; e < To; ++e) { const t = e / A, i = Math.exp(-t * t / 2); f.push(i), 0 === e ? g += i : e < p && (g += 2 * i) } for (let e = 0; e < f.length; e++)f[e] = f[e] / g; h.envMap.value = e.texture, h.samples.value = p, h.weights.value = f, h.latitudinal.value = "latitudinal" === a, s && (h.poleAxis.value = s); const { _lodMax: m } = this; h.dTheta.value = u, h.mipInt.value = m - i; const _ = this._sizeLods[n]; zo(t, 3 * _ * (n > m - 4 ? n - m + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), o.setRenderTarget(t), o.render(c, Ro) } } function Ho(e, t, i) { const n = new ai(e, t, i); return n.texture.mapping = j, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n } function zo(e, t, i, n, r) { e.viewport.set(t, i, n, r), e.scissor.set(t, i, n, r) } function Vo() { return new Er({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: jo(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function Wo() { return new Er({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: jo(), fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function jo() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function qo(e) { let t = new WeakMap, i = null; function n(e) { const i = e.target; i.removeEventListener("dispose", n); const r = t.get(i); void 0 !== r && (t.delete(i), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const a = r.mapping, s = a === V || a === W, o = a === H || a === z; if (s || o) { let a = t.get(r); const l = void 0 !== a ? a.texture.pmremVersion : 0; if (r.isRenderTargetTexture && r.pmremVersion !== l) return null === i && (i = new Go(e)), a = s ? i.fromEquirectangular(r, a) : i.fromCubemap(r, a), a.texture.pmremVersion = r.pmremVersion, t.set(r, a), a.texture; if (void 0 !== a) return a.texture; { const l = r.image; return s && l && l.height > 0 || o && l && function (e) { let t = 0; const i = 6; for (let n = 0; n < i; n++)void 0 !== e[n] && t++; return t === i }(l) ? (null === i && (i = new Go(e)), a = s ? i.fromEquirectangular(r) : i.fromCubemap(r), a.texture.pmremVersion = r.pmremVersion, t.set(r, a), r.addEventListener("dispose", n), a.texture) : null } } } return r }, dispose: function () { t = new WeakMap, null !== i && (i.dispose(), i = null) } } } function Xo(e) { const t = {}; function i(i) { if (void 0 !== t[i]) return t[i]; let n; switch (i) { case "WEBGL_depth_texture": n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: n = e.getExtension(i) }return t[i] = n, n } return { has: function (e) { return null !== i(e) }, init: function () { i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent") }, get: function (e) { const t = i(e); return null === t && zt("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function Yo(e, t, i, n) { const r = {}, a = new WeakMap; function s(e) { const o = e.target; null !== o.index && t.remove(o.index); for (const e in o.attributes) t.remove(o.attributes[e]); o.removeEventListener("dispose", s), delete r[o.id]; const l = a.get(o); l && (t.remove(l), a.delete(o)), n.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, i.memory.geometries-- } function o(e) { const i = [], n = e.index, r = e.attributes.position; let s = 0; if (null !== n) { const e = n.array; s = n.version; for (let t = 0, n = e.length; t < n; t += 3) { const n = e[t + 0], r = e[t + 1], a = e[t + 2]; i.push(n, r, r, a, a, n) } } else { if (void 0 === r) return; { const e = r.array; s = r.version; for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) { const e = t + 0, n = t + 1, r = t + 2; i.push(e, n, n, r, r, e) } } } const o = new (kt(i) ? qn : jn)(i, 1); o.version = s; const l = a.get(e); l && t.remove(l), a.set(e, o) } return { get: function (e, t) { return !0 === r[t.id] || (t.addEventListener("dispose", s), r[t.id] = !0, i.memory.geometries++), t }, update: function (i) { const n = i.attributes; for (const i in n) t.update(n[i], e.ARRAY_BUFFER) }, getWireframeAttribute: function (e) { const t = a.get(e); if (t) { const i = e.index; null !== i && t.version < i.version && o(e) } else o(e); return a.get(e) } } } function Ko(e, t, i) { let n, r, a; function s(t, s, o) { 0 !== o && (e.drawElementsInstanced(n, s, r, t * a, o), i.update(s, n, o)) } this.setMode = function (e) { n = e }, this.setIndex = function (e) { r = e.type, a = e.bytesPerElement }, this.render = function (t, s) { e.drawElements(n, s, r, t * a), i.update(s, n, 1) }, this.renderInstances = s, this.renderMultiDraw = function (e, a, s) { if (0 === s) return; t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, a, 0, r, e, 0, s); let o = 0; for (let e = 0; e < s; e++)o += a[e]; i.update(o, n, 1) }, this.renderMultiDrawInstances = function (e, o, l, c) { if (0 === l) return; const h = t.get("WEBGL_multi_draw"); if (null === h) for (let t = 0; t < e.length; t++)s(e[t] / a, o[t], c[t]); else { h.multiDrawElementsInstancedWEBGL(n, o, 0, r, e, 0, c, 0, l); let t = 0; for (let e = 0; e < l; e++)t += o[e] * c[e]; i.update(t, n, 1) } } } function Jo(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (i, n, r) { switch (t.calls++, n) { case e.TRIANGLES: t.triangles += r * (i / 3); break; case e.LINES: t.lines += r * (i / 2); break; case e.LINE_STRIP: t.lines += r * (i - 1); break; case e.LINE_LOOP: t.lines += r * i; break; case e.POINTS: t.points += r * i } } } } function Zo(e, t, i) { const n = new WeakMap, r = new ni; return { update: function (a, s, o) { const l = a.morphTargetInfluences, c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color, h = void 0 !== c ? c.length : 0; let d = n.get(s); if (void 0 === d || d.count !== h) { void 0 !== d && d.texture.dispose(); const u = void 0 !== s.morphAttributes.position, A = void 0 !== s.morphAttributes.normal, p = void 0 !== s.morphAttributes.color, f = s.morphAttributes.position || [], g = s.morphAttributes.normal || [], m = s.morphAttributes.color || []; let _ = 0; !0 === u && (_ = 1), !0 === A && (_ = 2), !0 === p && (_ = 3); let b = s.attributes.position.count * _, v = 1; b > t.maxTextureSize && (v = Math.ceil(b / t.maxTextureSize), b = t.maxTextureSize); const E = new Float32Array(b * v * 4 * h), y = new si(E, b, v, h); y.type = le, y.needsUpdate = !0; const x = 4 * _; for (let I = 0; I < h; I++) { const S = f[I], w = g[I], M = m[I], B = b * v * 4 * I; for (let T = 0; T < S.count; T++) { const R = T * x; !0 === u && (r.fromBufferAttribute(S, T), E[B + R + 0] = r.x, E[B + R + 1] = r.y, E[B + R + 2] = r.z, E[B + R + 3] = 0), !0 === A && (r.fromBufferAttribute(w, T), E[B + R + 4] = r.x, E[B + R + 5] = r.y, E[B + R + 6] = r.z, E[B + R + 7] = 0), !0 === p && (r.fromBufferAttribute(M, T), E[B + R + 8] = r.x, E[B + R + 9] = r.y, E[B + R + 10] = r.z, E[B + R + 11] = 4 === M.itemSize ? r.w : 1) } } function C() { y.dispose(), n.delete(s), s.removeEventListener("dispose", C) } d = { count: h, texture: y, size: new Qt(b, v) }, n.set(s, d), s.addEventListener("dispose", C) } if (!0 === a.isInstancedMesh && null !== a.morphTexture) o.getUniforms().setValue(e, "morphTexture", a.morphTexture, i); else { let D = 0; for (let U = 0; U < l.length; U++)D += l[U]; const L = s.morphTargetsRelative ? 1 : 1 - D; o.getUniforms().setValue(e, "morphTargetBaseInfluence", L), o.getUniforms().setValue(e, "morphTargetInfluences", l) } o.getUniforms().setValue(e, "morphTargetsTexture", d.texture, i), o.getUniforms().setValue(e, "morphTargetsTextureSize", d.size) } } } function $o(e, t, i, n) { let r = new WeakMap; function a(e) { const t = e.target; t.removeEventListener("dispose", a), i.remove(t.instanceMatrix), null !== t.instanceColor && i.remove(t.instanceColor) } return { update: function (s) { const o = n.render.frame, l = s.geometry, c = t.get(s, l); if (r.get(c) !== o && (t.update(c), r.set(c, o)), s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a), r.get(s) !== o && (i.update(s.instanceMatrix, e.ARRAY_BUFFER), null !== s.instanceColor && i.update(s.instanceColor, e.ARRAY_BUFFER), r.set(s, o))), s.isSkinnedMesh) { const e = s.skeleton; r.get(e) !== o && (e.update(), r.set(e, o)) } return c }, dispose: function () { r = new WeakMap } } } const el = new ii, tl = new ka(1, 1), il = new si, nl = new oi, rl = new Br, al = [], sl = [], ol = new Float32Array(16), ll = new Float32Array(9), cl = new Float32Array(4); function hl(e, t, i) { const n = e[0]; if (n <= 0 || n > 0) return e; const r = t * i; let a = al[r]; if (void 0 === a && (a = new Float32Array(r), al[r] = a), 0 !== t) { n.toArray(a, 0); for (let n = 1, r = 0; n !== t; ++n)r += i, e[n].toArray(a, r) } return a } function dl(e, t) { if (e.length !== t.length) return !1; for (let i = 0, n = e.length; i < n; i++)if (e[i] !== t[i]) return !1; return !0 } function ul(e, t) { for (let i = 0, n = t.length; i < n; i++)e[i] = t[i] } function Al(e, t) { let i = sl[t]; void 0 === i && (i = new Int32Array(t), sl[t] = i); for (let n = 0; n !== t; ++n)i[n] = e.allocateTextureUnit(); return i } function pl(e, t) { const i = this.cache; i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t) } function fl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (dl(i, t)) return; e.uniform2fv(this.addr, t), ul(i, t) } } function gl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else if (void 0 !== t.r) i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b); else { if (dl(i, t)) return; e.uniform3fv(this.addr, t), ul(i, t) } } function ml(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (dl(i, t)) return; e.uniform4fv(this.addr, t), ul(i, t) } } function _l(e, t) { const i = this.cache, n = t.elements; if (void 0 === n) { if (dl(i, t)) return; e.uniformMatrix2fv(this.addr, !1, t), ul(i, t) } else { if (dl(i, n)) return; cl.set(n), e.uniformMatrix2fv(this.addr, !1, cl), ul(i, n) } } function bl(e, t) { const i = this.cache, n = t.elements; if (void 0 === n) { if (dl(i, t)) return; e.uniformMatrix3fv(this.addr, !1, t), ul(i, t) } else { if (dl(i, n)) return; ll.set(n), e.uniformMatrix3fv(this.addr, !1, ll), ul(i, n) } } function vl(e, t) { const i = this.cache, n = t.elements; if (void 0 === n) { if (dl(i, t)) return; e.uniformMatrix4fv(this.addr, !1, t), ul(i, t) } else { if (dl(i, n)) return; ol.set(n), e.uniformMatrix4fv(this.addr, !1, ol), ul(i, n) } } function El(e, t) { const i = this.cache; i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t) } function yl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (dl(i, t)) return; e.uniform2iv(this.addr, t), ul(i, t) } } function xl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else { if (dl(i, t)) return; e.uniform3iv(this.addr, t), ul(i, t) } } function Cl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (dl(i, t)) return; e.uniform4iv(this.addr, t), ul(i, t) } } function Il(e, t) { const i = this.cache; i[0] !== t && (e.uniform1ui(this.addr, t), i[0] = t) } function Sl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (dl(i, t)) return; e.uniform2uiv(this.addr, t), ul(i, t) } } function wl(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else { if (dl(i, t)) return; e.uniform3uiv(this.addr, t), ul(i, t) } } function Ml(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (dl(i, t)) return; e.uniform4uiv(this.addr, t), ul(i, t) } } function Bl(e, t, i) { const n = this.cache, r = i.allocateTextureUnit(); let a; n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), this.type === e.SAMPLER_2D_SHADOW ? (tl.compareFunction = 515, a = tl) : a = el, i.setTexture2D(t || a, r) } function Tl(e, t, i) { const n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || nl, r) } function Rl(e, t, i) { const n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(t || rl, r) } function Dl(e, t, i) { const n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || il, r) } function Ll(e, t) { e.uniform1fv(this.addr, t) } function Ul(e, t) { const i = hl(t, this.size, 2); e.uniform2fv(this.addr, i) } function Pl(e, t) { const i = hl(t, this.size, 3); e.uniform3fv(this.addr, i) } function Ql(e, t) { const i = hl(t, this.size, 4); e.uniform4fv(this.addr, i) } function Fl(e, t) { const i = hl(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, i) } function Nl(e, t) { const i = hl(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, i) } function kl(e, t) { const i = hl(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, i) } function Ol(e, t) { e.uniform1iv(this.addr, t) } function Gl(e, t) { e.uniform2iv(this.addr, t) } function Hl(e, t) { e.uniform3iv(this.addr, t) } function zl(e, t) { e.uniform4iv(this.addr, t) } function Vl(e, t) { e.uniform1uiv(this.addr, t) } function Wl(e, t) { e.uniform2uiv(this.addr, t) } function jl(e, t) { e.uniform3uiv(this.addr, t) } function ql(e, t) { e.uniform4uiv(this.addr, t) } function Xl(e, t, i) { const n = this.cache, r = t.length, a = Al(i, r); dl(n, a) || (e.uniform1iv(this.addr, a), ul(n, a)); for (let e = 0; e !== r; ++e)i.setTexture2D(t[e] || el, a[e]) } function Yl(e, t, i) { const n = this.cache, r = t.length, a = Al(i, r); dl(n, a) || (e.uniform1iv(this.addr, a), ul(n, a)); for (let e = 0; e !== r; ++e)i.setTexture3D(t[e] || nl, a[e]) } function Kl(e, t, i) { const n = this.cache, r = t.length, a = Al(i, r); dl(n, a) || (e.uniform1iv(this.addr, a), ul(n, a)); for (let e = 0; e !== r; ++e)i.setTextureCube(t[e] || rl, a[e]) } function Jl(e, t, i) { const n = this.cache, r = t.length, a = Al(i, r); dl(n, a) || (e.uniform1iv(this.addr, a), ul(n, a)); for (let e = 0; e !== r; ++e)i.setTexture2DArray(t[e] || il, a[e]) } class Zl { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = function (e) { switch (e) { case 5126: return pl; case 35664: return fl; case 35665: return gl; case 35666: return ml; case 35674: return _l; case 35675: return bl; case 35676: return vl; case 5124: case 35670: return El; case 35667: case 35671: return yl; case 35668: case 35672: return xl; case 35669: case 35673: return Cl; case 5125: return Il; case 36294: return Sl; case 36295: return wl; case 36296: return Ml; case 35678: case 36198: case 36298: case 36306: case 35682: return Bl; case 35679: case 36299: case 36307: return Tl; case 35680: case 36300: case 36308: case 36293: return Rl; case 36289: case 36303: case 36311: case 36292: return Dl } }(t.type) } } class $l { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return Ll; case 35664: return Ul; case 35665: return Pl; case 35666: return Ql; case 35674: return Fl; case 35675: return Nl; case 35676: return kl; case 5124: case 35670: return Ol; case 35667: case 35671: return Gl; case 35668: case 35672: return Hl; case 35669: case 35673: return zl; case 5125: return Vl; case 36294: return Wl; case 36295: return jl; case 36296: return ql; case 35678: case 36198: case 36298: case 36306: case 35682: return Xl; case 35679: case 36299: case 36307: return Yl; case 35680: case 36300: case 36308: case 36293: return Kl; case 36289: case 36303: case 36311: case 36292: return Jl } }(t.type) } } class ec { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, i) { const n = this.seq; for (let r = 0, a = n.length; r !== a; ++r) { const a = n[r]; a.setValue(e, t[a.id], i) } } } const tc = /(\w+)(\])?(\[|\.)?/g; function ic(e, t) { e.seq.push(t), e.map[t.id] = t } function nc(e, t, i) { const n = e.name, r = n.length; for (tc.lastIndex = 0; ;) { const a = tc.exec(n), s = tc.lastIndex; let o = a[1]; const l = "]" === a[2], c = a[3]; if (l && (o |= 0), void 0 === c || "[" === c && s + 2 === r) { ic(i, void 0 === c ? new Zl(o, e, t) : new $l(o, e, t)); break } { let e = i.map[o]; void 0 === e && (e = new ec(o), ic(i, e)), i = e } } } class rc { constructor(e, t) { this.seq = [], this.map = {}; const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let n = 0; n < i; ++n) { const i = e.getActiveUniform(t, n); nc(i, e.getUniformLocation(t, i.name), this) } } setValue(e, t, i, n) { const r = this.map[t]; void 0 !== r && r.setValue(e, i, n) } setOptional(e, t, i) { const n = t[i]; void 0 !== n && this.setValue(e, i, n) } static upload(e, t, i, n) { for (let r = 0, a = t.length; r !== a; ++r) { const a = t[r], s = i[a.id]; !1 !== s.needsUpdate && a.setValue(e, s.value, n) } } static seqWithValue(e, t) { const i = []; for (let n = 0, r = e.length; n !== r; ++n) { const r = e[n]; r.id in t && i.push(r) } return i } } function ac(e, t, i) { const n = e.createShader(t); return e.shaderSource(n, i), e.compileShader(n), n } let sc = 0; const oc = new Ft; function lc(e, t, i) { const n = e.getShaderParameter(t, e.COMPILE_STATUS), r = e.getShaderInfoLog(t).trim(); if (n && "" === r) return ""; const a = /ERROR: 0:(\d+)/.exec(r); if (a) { const n = parseInt(a[1]); return i.toUpperCase() + "\n\n" + r + "\n\n" + function (e, t) { const i = e.split("\n"), n = [], r = Math.max(t - 6, 0), a = Math.min(t + 6, i.length); for (let e = r; e < a; e++) { const r = e + 1; n.push(`${r === t ? ">" : " "} ${r}: ${i[e]}`) } return n.join("\n") }(e.getShaderSource(t), n) } return r } function cc(e, t) { const i = function (e) { qt._getMatrix(oc, qt.workingColorSpace, e); const t = `mat3( ${oc.elements.map((e => e.toFixed(4)))} )`; switch (qt.getTransfer(e)) { case ct: return [t, "LinearTransferOETF"]; case ht: return [t, "sRGBTransferOETF"]; default: return [t, "LinearTransferOETF"] } }(t); return [`vec4 ${e}( vec4 value ) {`, `\treturn ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`, "}"].join("\n") } function hc(e, t) { let i; switch (t) { case 1: default: i = "Linear"; break; case 2: i = "Reinhard"; break; case 3: i = "Cineon"; break; case 4: i = "ACESFilmic"; break; case 6: i = "AgX"; break; case 7: i = "Neutral"; break; case 5: i = "Custom" }return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }" } const dc = new ci; function uc() { qt.getLuminanceCoefficients(dc); return ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${dc.x.toFixed(4)}, ${dc.y.toFixed(4)}, ${dc.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n") } function Ac(e) { return "" !== e } function pc(e, t) { const i = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps; return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function fc(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const gc = /^[ \t]*#include +<([\w\d./]+)>/gm; function mc(e) { return e.replace(gc, bc) } const _c = new Map; function bc(e, t) { let i = mo[t]; if (void 0 === i) { const e = _c.get(t); if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">"); i = mo[e] } return mc(i) } const vc = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Ec(e) { return e.replace(vc, yc) } function yc(e, t, i, n) { let r = ""; for (let e = parseInt(t); e < parseInt(i); e++)r += n.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return r } function xc(e) { let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Cc(e, t, i, n) { const r = e.getContext(), a = i.defines; let s = i.vertexShader, o = i.fragmentShader; const l = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t }(i), c = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case H: case z: t = "ENVMAP_TYPE_CUBE"; break; case j: t = "ENVMAP_TYPE_CUBE_UV" }return t }(i), h = function (e) { let t = "ENVMAP_MODE_REFLECTION"; e.envMap && e.envMapMode === z && (t = "ENVMAP_MODE_REFRACTION"); return t }(i), d = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case 0: t = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: t = "ENVMAP_BLENDING_MIX"; break; case 2: t = "ENVMAP_BLENDING_ADD" }return t }(i), u = function (e) { const t = e.envMapCubeUVHeight; if (null === t) return null; const i = Math.log2(t) - 2, n = 1 / t; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)), texelHeight: n, maxMip: i } }(i), A = function (e) { return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Ac).join("\n") }(i), p = function (e) { const t = []; for (const i in e) { const n = e[i]; !1 !== n && t.push("#define " + i + " " + n) } return t.join("\n") }(a), f = r.createProgram(); let g, m, _ = i.glslVersion ? "#version " + i.glslVersion + "\n" : ""; i.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, p].filter(Ac).join("\n"), g.length > 0 && (g += "\n"), m = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, p].filter(Ac).join("\n"), m.length > 0 && (m += "\n")) : (g = [xc(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, p, i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", i.batching ? "#define USE_BATCHING" : "", i.batchingColor ? "#define USE_BATCHING_COLOR" : "", i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.mapUv ? "#define MAP_UV " + i.mapUv : "", i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "", i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "", i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "", i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "", i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "", i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "", i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "", i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "", i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "", i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "", i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "", i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "", i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "", i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "", i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "", i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "", i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "", i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "", i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "", i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "", i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "", i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ac).join("\n"), m = [xc(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, p, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + d : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.dispersion ? "#define USE_DISPERSION" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? mo.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? hc("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", mo.colorspace_pars_fragment, cc("linearToOutputTexel", i.outputColorSpace), uc(), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Ac).join("\n")), s = mc(s), s = pc(s, i), s = fc(s, i), o = mc(o), o = pc(o, i), o = fc(o, i), s = Ec(s), o = Ec(o), !0 !== i.isRawShaderMaterial && (_ = "#version 300 es\n", g = [A, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, m = ["#define varying in", i.glslVersion === Et ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === Et ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + m); const b = _ + g + s, v = _ + m + o, E = ac(r, r.VERTEX_SHADER, b), y = ac(r, r.FRAGMENT_SHADER, v); function x(t) { if (e.debug.checkShaderErrors) { const i = r.getProgramInfoLog(f).trim(), n = r.getShaderInfoLog(E).trim(), a = r.getShaderInfoLog(y).trim(); let s = !0, o = !0; if (!1 === r.getProgramParameter(f, r.LINK_STATUS)) if (s = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(r, f, E, y); else { lc(r, E, "vertex"), lc(r, y, "fragment") } else "" !== i || "" !== n && "" !== a || (o = !1); o && (t.diagnostics = { runnable: s, programLog: i, vertexShader: { log: n, prefix: g }, fragmentShader: { log: a, prefix: m } }) } r.deleteShader(E), r.deleteShader(y), C = new rc(r, f), I = function (e, t) { const i = {}, n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES); for (let r = 0; r < n; r++) { const n = e.getActiveAttrib(t, r), a = n.name; let s = 1; n.type === e.FLOAT_MAT2 && (s = 2), n.type === e.FLOAT_MAT3 && (s = 3), n.type === e.FLOAT_MAT4 && (s = 4), i[a] = { type: n.type, location: e.getAttribLocation(t, a), locationSize: s } } return i }(r, f) } let C, I; r.attachShader(f, E), r.attachShader(f, y), void 0 !== i.index0AttributeName ? r.bindAttribLocation(f, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(f, 0, "position"), r.linkProgram(f), this.getUniforms = function () { return void 0 === C && x(this), C }, this.getAttributes = function () { return void 0 === I && x(this), I }; let S = !1 === i.rendererExtensionParallelShaderCompile; return this.isReady = function () { return !1 === S && (S = r.getProgramParameter(f, 37297)), S }, this.destroy = function () { n.releaseStatesOfProgram(this), r.deleteProgram(f), this.program = void 0 }, this.type = i.shaderType, this.name = i.shaderName, this.id = sc++, this.cacheKey = t, this.usedTimes = 1, this.program = f, this.vertexShader = E, this.fragmentShader = y, this } let Ic = 0; class Sc { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), r = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e); return !1 === a.has(n) && (a.add(n), n.usedTimes++), !1 === a.has(r) && (a.add(r), r.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let i = t.get(e); return void 0 === i && (i = new Set, t.set(e, i)), i } _getShaderStage(e) { const t = this.shaderCache; let i = t.get(e); return void 0 === i && (i = new wc(e), t.set(e, i)), i } } class wc { constructor(e) { this.id = Ic++, this.code = e, this.usedTimes = 0 } } function Mc(e, t, i, n, r, a, s) { const o = new Ki, l = new Sc, c = new Set, h = [], d = r.logarithmicDepthBuffer, u = r.vertexTextures; let A = r.precision; const p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function f(e) { return c.add(e), 0 === e ? "uv" : `uv${e}` } return { getParameters: function (a, o, h, g, m) { const _ = g.fog, b = m.geometry, v = a.isMeshStandardMaterial ? g.environment : null, E = (a.isMeshStandardMaterial ? i : t).get(a.envMap || v), y = E && E.mapping === j ? E.image.height : null, x = p[a.type]; null !== a.precision && (A = r.getMaxPrecision(a.precision), a.precision); const C = b.morphAttributes.position || b.morphAttributes.normal || b.morphAttributes.color, I = void 0 !== C ? C.length : 0; let S, w, M, B, T = 0; if (void 0 !== b.morphAttributes.position && (T = 1), void 0 !== b.morphAttributes.normal && (T = 2), void 0 !== b.morphAttributes.color && (T = 3), x) { const e = bo[x]; S = e.vertexShader, w = e.fragmentShader } else S = a.vertexShader, w = a.fragmentShader, l.update(a), M = l.getVertexShaderID(a), B = l.getFragmentShaderID(a); const R = e.getRenderTarget(), D = e.state.buffers.depth.getReversed(), L = !0 === m.isInstancedMesh, U = !0 === m.isBatchedMesh, P = !!a.map, Q = !!a.matcap, F = !!E, N = !!a.aoMap, k = !!a.lightMap, O = !!a.bumpMap, G = !!a.normalMap, H = !!a.displacementMap, z = !!a.emissiveMap, V = !!a.metalnessMap, W = !!a.roughnessMap, q = a.anisotropy > 0, X = a.clearcoat > 0, Y = a.dispersion > 0, K = a.iridescence > 0, J = a.sheen > 0, Z = a.transmission > 0, $ = q && !!a.anisotropyMap, ee = X && !!a.clearcoatMap, te = X && !!a.clearcoatNormalMap, ie = X && !!a.clearcoatRoughnessMap, ne = K && !!a.iridescenceMap, re = K && !!a.iridescenceThicknessMap, ae = J && !!a.sheenColorMap, se = J && !!a.sheenRoughnessMap, oe = !!a.specularMap, le = !!a.specularColorMap, ce = !!a.specularIntensityMap, he = Z && !!a.transmissionMap, de = Z && !!a.thicknessMap, ue = !!a.gradientMap, Ae = !!a.alphaMap, pe = a.alphaTest > 0, fe = !!a.alphaHash, ge = !!a.extensions; let me = 0; a.toneMapped && (null !== R && !0 !== R.isXRRenderTarget || (me = e.toneMapping)); const _e = { shaderID: x, shaderType: a.type, shaderName: a.name, vertexShader: S, fragmentShader: w, defines: a.defines, customVertexShaderID: M, customFragmentShaderID: B, isRawShaderMaterial: !0 === a.isRawShaderMaterial, glslVersion: a.glslVersion, precision: A, batching: U, batchingColor: U && null !== m._colorsTexture, instancing: L, instancingColor: L && null !== m.instanceColor, instancingMorph: L && null !== m.morphTexture, supportsVertexTextures: u, outputColorSpace: null === R ? e.outputColorSpace : !0 === R.isXRRenderTarget ? R.texture.colorSpace : lt, alphaToCoverage: !!a.alphaToCoverage, map: P, matcap: Q, envMap: F, envMapMode: F && E.mapping, envMapCubeUVHeight: y, aoMap: N, lightMap: k, bumpMap: O, normalMap: G, displacementMap: u && H, emissiveMap: z, normalMapObjectSpace: G && 1 === a.normalMapType, normalMapTangentSpace: G && 0 === a.normalMapType, metalnessMap: V, roughnessMap: W, anisotropy: q, anisotropyMap: $, clearcoat: X, clearcoatMap: ee, clearcoatNormalMap: te, clearcoatRoughnessMap: ie, dispersion: Y, iridescence: K, iridescenceMap: ne, iridescenceThicknessMap: re, sheen: J, sheenColorMap: ae, sheenRoughnessMap: se, specularMap: oe, specularColorMap: le, specularIntensityMap: ce, transmission: Z, transmissionMap: he, thicknessMap: de, gradientMap: ue, opaque: !1 === a.transparent && 1 === a.blending && !1 === a.alphaToCoverage, alphaMap: Ae, alphaTest: pe, alphaHash: fe, combine: a.combine, mapUv: P && f(a.map.channel), aoMapUv: N && f(a.aoMap.channel), lightMapUv: k && f(a.lightMap.channel), bumpMapUv: O && f(a.bumpMap.channel), normalMapUv: G && f(a.normalMap.channel), displacementMapUv: H && f(a.displacementMap.channel), emissiveMapUv: z && f(a.emissiveMap.channel), metalnessMapUv: V && f(a.metalnessMap.channel), roughnessMapUv: W && f(a.roughnessMap.channel), anisotropyMapUv: $ && f(a.anisotropyMap.channel), clearcoatMapUv: ee && f(a.clearcoatMap.channel), clearcoatNormalMapUv: te && f(a.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ie && f(a.clearcoatRoughnessMap.channel), iridescenceMapUv: ne && f(a.iridescenceMap.channel), iridescenceThicknessMapUv: re && f(a.iridescenceThicknessMap.channel), sheenColorMapUv: ae && f(a.sheenColorMap.channel), sheenRoughnessMapUv: se && f(a.sheenRoughnessMap.channel), specularMapUv: oe && f(a.specularMap.channel), specularColorMapUv: le && f(a.specularColorMap.channel), specularIntensityMapUv: ce && f(a.specularIntensityMap.channel), transmissionMapUv: he && f(a.transmissionMap.channel), thicknessMapUv: de && f(a.thicknessMap.channel), alphaMapUv: Ae && f(a.alphaMap.channel), vertexTangents: !!b.attributes.tangent && (G || q), vertexColors: a.vertexColors, vertexAlphas: !0 === a.vertexColors && !!b.attributes.color && 4 === b.attributes.color.itemSize, pointsUvs: !0 === m.isPoints && !!b.attributes.uv && (P || Ae), fog: !!_, useFog: !0 === a.fog, fogExp2: !!_ && _.isFogExp2, flatShading: !0 === a.flatShading, sizeAttenuation: !0 === a.sizeAttenuation, logarithmicDepthBuffer: d, reverseDepthBuffer: D, skinning: !0 === m.isSkinnedMesh, morphTargets: void 0 !== b.morphAttributes.position, morphNormals: void 0 !== b.morphAttributes.normal, morphColors: void 0 !== b.morphAttributes.color, morphTargetsCount: I, morphTextureStride: T, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numSpotLightMaps: o.spotLightMap.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps, numLightProbes: o.numLightProbes, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: a.dithering, shadowMapEnabled: e.shadowMap.enabled && h.length > 0, shadowMapType: e.shadowMap.type, toneMapping: me, decodeVideoTexture: P && !0 === a.map.isVideoTexture && qt.getTransfer(a.map.colorSpace) === ht, decodeVideoTextureEmissive: z && !0 === a.emissiveMap.isVideoTexture && qt.getTransfer(a.emissiveMap.colorSpace) === ht, premultipliedAlpha: a.premultipliedAlpha, doubleSided: 2 === a.side, flipSided: 1 === a.side, useDepthPacking: a.depthPacking >= 0, depthPacking: a.depthPacking || 0, index0AttributeName: a.index0AttributeName, extensionClipCullDistance: ge && !0 === a.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (ge && !0 === a.extensions.multiDraw || U) && n.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"), customProgramCacheKey: a.customProgramCacheKey() }; return _e.vertexUv1s = c.has(1), _e.vertexUv2s = c.has(2), _e.vertexUv3s = c.has(3), c.clear(), _e }, getProgramCacheKey: function (t) { const i = []; if (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)), void 0 !== t.defines) for (const e in t.defines) i.push(e), i.push(t.defines[e]); return !1 === t.isRawShaderMaterial && (!function (e, t) { e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking) }(i, t), function (e, t) { o.disableAll(), t.supportsVertexTextures && o.enable(0); t.instancing && o.enable(1); t.instancingColor && o.enable(2); t.instancingMorph && o.enable(3); t.matcap && o.enable(4); t.envMap && o.enable(5); t.normalMapObjectSpace && o.enable(6); t.normalMapTangentSpace && o.enable(7); t.clearcoat && o.enable(8); t.iridescence && o.enable(9); t.alphaTest && o.enable(10); t.vertexColors && o.enable(11); t.vertexAlphas && o.enable(12); t.vertexUv1s && o.enable(13); t.vertexUv2s && o.enable(14); t.vertexUv3s && o.enable(15); t.vertexTangents && o.enable(16); t.anisotropy && o.enable(17); t.alphaHash && o.enable(18); t.batching && o.enable(19); t.dispersion && o.enable(20); t.batchingColor && o.enable(21); e.push(o.mask), o.disableAll(), t.fog && o.enable(0); t.useFog && o.enable(1); t.flatShading && o.enable(2); t.logarithmicDepthBuffer && o.enable(3); t.reverseDepthBuffer && o.enable(4); t.skinning && o.enable(5); t.morphTargets && o.enable(6); t.morphNormals && o.enable(7); t.morphColors && o.enable(8); t.premultipliedAlpha && o.enable(9); t.shadowMapEnabled && o.enable(10); t.doubleSided && o.enable(11); t.flipSided && o.enable(12); t.useDepthPacking && o.enable(13); t.dithering && o.enable(14); t.transmission && o.enable(15); t.sheen && o.enable(16); t.opaque && o.enable(17); t.pointsUvs && o.enable(18); t.decodeVideoTexture && o.enable(19); t.decodeVideoTextureEmissive && o.enable(20); t.alphaToCoverage && o.enable(21); e.push(o.mask) }(i, t), i.push(e.outputColorSpace)), i.push(t.customProgramCacheKey), i.join() }, getUniforms: function (e) { const t = p[e.type]; let i; if (t) { const e = bo[t]; i = vr.clone(e.uniforms) } else i = e.uniforms; return i }, acquireProgram: function (t, i) { let n; for (let e = 0, t = h.length; e < t; e++) { const t = h[e]; if (t.cacheKey === i) { n = t, ++n.usedTimes; break } } return void 0 === n && (n = new Cc(e, i, t, a), h.push(n)), n }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = h.indexOf(e); h[t] = h[h.length - 1], h.pop(), e.destroy() } }, releaseShaderCache: function (e) { l.remove(e) }, programs: h, dispose: function () { l.dispose() } } } function Bc() { let e = new WeakMap; return { has: function (t) { return e.has(t) }, get: function (t) { let i = e.get(t); return void 0 === i && (i = {}, e.set(t, i)), i }, remove: function (t) { e.delete(t) }, update: function (t, i, n) { e.get(t)[i] = n }, dispose: function () { e = new WeakMap } } } function Tc(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function Rc(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function Dc() { const e = []; let t = 0; const i = [], n = [], r = []; function a(i, n, r, a, s, o) { let l = e[t]; return void 0 === l ? (l = { id: i.id, object: i, geometry: n, material: r, groupOrder: a, renderOrder: i.renderOrder, z: s, group: o }, e[t] = l) : (l.id = i.id, l.object = i, l.geometry = n, l.material = r, l.groupOrder = a, l.renderOrder = i.renderOrder, l.z = s, l.group = o), t++, l } return { opaque: i, transmissive: n, transparent: r, init: function () { t = 0, i.length = 0, n.length = 0, r.length = 0 }, push: function (e, t, s, o, l, c) { const h = a(e, t, s, o, l, c); s.transmission > 0 ? n.push(h) : !0 === s.transparent ? r.push(h) : i.push(h) }, unshift: function (e, t, s, o, l, c) { const h = a(e, t, s, o, l, c); s.transmission > 0 ? n.unshift(h) : !0 === s.transparent ? r.unshift(h) : i.unshift(h) }, finish: function () { for (let i = t, n = e.length; i < n; i++) { const t = e[i]; if (null === t.id) break; t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null } }, sort: function (e, t) { i.length > 1 && i.sort(e || Tc), n.length > 1 && n.sort(t || Rc), r.length > 1 && r.sort(t || Rc) } } } function Lc() { let e = new WeakMap; return { get: function (t, i) { const n = e.get(t); let r; return void 0 === n ? (r = new Dc, e.set(t, [r])) : i >= n.length ? (r = new Dc, n.push(r)) : r = n[i], r }, dispose: function () { e = new WeakMap } } } function Uc() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let i; switch (t.type) { case "DirectionalLight": i = { direction: new ci, color: new Dn }; break; case "SpotLight": i = { position: new ci, direction: new ci, color: new Dn, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": i = { position: new ci, color: new Dn, distance: 0, decay: 0 }; break; case "HemisphereLight": i = { direction: new ci, skyColor: new Dn, groundColor: new Dn }; break; case "RectAreaLight": i = { color: new Dn, position: new ci, halfWidth: new ci, halfHeight: new ci } }return e[t.id] = i, i } } } let Pc = 0; function Qc(e, t) { return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0) } function Fc(e) { const t = new Uc, i = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let i; switch (t.type) { case "DirectionalLight": case "SpotLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Qt }; break; case "PointLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Qt, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = i, i } } }(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let e = 0; e < 9; e++)n.probe.push(new ci); const r = new ci, a = new ki, s = new ki; return { setup: function (r) { let a = 0, s = 0, o = 0; for (let e = 0; e < 9; e++)n.probe[e].set(0, 0, 0); let l = 0, c = 0, h = 0, d = 0, u = 0, A = 0, p = 0, f = 0, g = 0, m = 0, _ = 0; r.sort(Qc); for (let e = 0, b = r.length; e < b; e++) { const b = r[e], v = b.color, E = b.intensity, y = b.distance, x = b.shadow && b.shadow.map ? b.shadow.map.texture : null; if (b.isAmbientLight) a += v.r * E, s += v.g * E, o += v.b * E; else if (b.isLightProbe) { for (let e = 0; e < 9; e++)n.probe[e].addScaledVector(b.sh.coefficients[e], E); _++ } else if (b.isDirectionalLight) { const e = t.get(b); if (e.color.copy(b.color).multiplyScalar(b.intensity), b.castShadow) { const e = b.shadow, t = i.get(b); t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, n.directionalShadow[l] = t, n.directionalShadowMap[l] = x, n.directionalShadowMatrix[l] = b.shadow.matrix, A++ } n.directional[l] = e, l++ } else if (b.isSpotLight) { const e = t.get(b); e.position.setFromMatrixPosition(b.matrixWorld), e.color.copy(v).multiplyScalar(E), e.distance = y, e.coneCos = Math.cos(b.angle), e.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)), e.decay = b.decay, n.spot[h] = e; const r = b.shadow; if (b.map && (n.spotLightMap[g] = b.map, g++, r.updateMatrices(b), b.castShadow && m++), n.spotLightMatrix[h] = r.matrix, b.castShadow) { const e = i.get(b); e.shadowIntensity = r.intensity, e.shadowBias = r.bias, e.shadowNormalBias = r.normalBias, e.shadowRadius = r.radius, e.shadowMapSize = r.mapSize, n.spotShadow[h] = e, n.spotShadowMap[h] = x, f++ } h++ } else if (b.isRectAreaLight) { const e = t.get(b); e.color.copy(v).multiplyScalar(E), e.halfWidth.set(.5 * b.width, 0, 0), e.halfHeight.set(0, .5 * b.height, 0), n.rectArea[d] = e, d++ } else if (b.isPointLight) { const e = t.get(b); if (e.color.copy(b.color).multiplyScalar(b.intensity), e.distance = b.distance, e.decay = b.decay, b.castShadow) { const e = b.shadow, t = i.get(b); t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, n.pointShadow[c] = t, n.pointShadowMap[c] = x, n.pointShadowMatrix[c] = b.shadow.matrix, p++ } n.point[c] = e, c++ } else if (b.isHemisphereLight) { const e = t.get(b); e.skyColor.copy(b.color).multiplyScalar(E), e.groundColor.copy(b.groundColor).multiplyScalar(E), n.hemi[u] = e, u++ } } d > 0 && (!0 === e.has("OES_texture_float_linear") ? (n.rectAreaLTC1 = _o.LTC_FLOAT_1, n.rectAreaLTC2 = _o.LTC_FLOAT_2) : (n.rectAreaLTC1 = _o.LTC_HALF_1, n.rectAreaLTC2 = _o.LTC_HALF_2)), n.ambient[0] = a, n.ambient[1] = s, n.ambient[2] = o; const b = n.hash; b.directionalLength === l && b.pointLength === c && b.spotLength === h && b.rectAreaLength === d && b.hemiLength === u && b.numDirectionalShadows === A && b.numPointShadows === p && b.numSpotShadows === f && b.numSpotMaps === g && b.numLightProbes === _ || (n.directional.length = l, n.spot.length = h, n.rectArea.length = d, n.point.length = c, n.hemi.length = u, n.directionalShadow.length = A, n.directionalShadowMap.length = A, n.pointShadow.length = p, n.pointShadowMap.length = p, n.spotShadow.length = f, n.spotShadowMap.length = f, n.directionalShadowMatrix.length = A, n.pointShadowMatrix.length = p, n.spotLightMatrix.length = f + g - m, n.spotLightMap.length = g, n.numSpotLightShadowsWithMaps = m, n.numLightProbes = _, b.directionalLength = l, b.pointLength = c, b.spotLength = h, b.rectAreaLength = d, b.hemiLength = u, b.numDirectionalShadows = A, b.numPointShadows = p, b.numSpotShadows = f, b.numSpotMaps = g, b.numLightProbes = _, n.version = Pc++) }, setupView: function (e, t) { let i = 0, o = 0, l = 0, c = 0, h = 0; const d = t.matrixWorldInverse; for (let t = 0, u = e.length; t < u; t++) { const u = e[t]; if (u.isDirectionalLight) { const e = n.directional[i]; e.direction.setFromMatrixPosition(u.matrixWorld), r.setFromMatrixPosition(u.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(d), i++ } else if (u.isSpotLight) { const e = n.spot[l]; e.position.setFromMatrixPosition(u.matrixWorld), e.position.applyMatrix4(d), e.direction.setFromMatrixPosition(u.matrixWorld), r.setFromMatrixPosition(u.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(d), l++ } else if (u.isRectAreaLight) { const e = n.rectArea[c]; e.position.setFromMatrixPosition(u.matrixWorld), e.position.applyMatrix4(d), s.identity(), a.copy(u.matrixWorld), a.premultiply(d), s.extractRotation(a), e.halfWidth.set(.5 * u.width, 0, 0), e.halfHeight.set(0, .5 * u.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), c++ } else if (u.isPointLight) { const e = n.point[o]; e.position.setFromMatrixPosition(u.matrixWorld), e.position.applyMatrix4(d), o++ } else if (u.isHemisphereLight) { const e = n.hemi[h]; e.direction.setFromMatrixPosition(u.matrixWorld), e.direction.transformDirection(d), h++ } } }, state: n } } function Nc(e) { const t = new Fc(e), i = [], n = []; const r = { lightsArray: i, shadowsArray: n, camera: null, lights: t, transmissionRenderTarget: {} }; return { init: function (e) { r.camera = e, i.length = 0, n.length = 0 }, state: r, setupLights: function () { t.setup(i) }, setupLightsView: function (e) { t.setupView(i, e) }, pushLight: function (e) { i.push(e) }, pushShadow: function (e) { n.push(e) } } } function kc(e) { let t = new WeakMap; return { get: function (i, n = 0) { const r = t.get(i); let a; return void 0 === r ? (a = new Nc(e), t.set(i, [a])) : n >= r.length ? (a = new Nc(e), r.push(a)) : a = r[n], a }, dispose: function () { t = new WeakMap } } } function Oc(e, t, i) { let n = new pa; const r = new Qt, a = new Qt, s = new ni, o = new ja({ depthPacking: 3201 }), l = new qa, c = {}, h = i.maxTextureSize, d = { [u]: 1, [A]: 0, [p]: 2 }, f = new Er({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Qt }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), g = f.clone(); g.defines.HORIZONTAL_PASS = 1; const m = new ir; m.setAttribute("position", new Wn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const _ = new pr(m, f), b = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1; let v = this.type; function E(i, n) { const a = t.update(_); f.defines.VSM_SAMPLES !== i.blurSamples && (f.defines.VSM_SAMPLES = i.blurSamples, g.defines.VSM_SAMPLES = i.blurSamples, f.needsUpdate = !0, g.needsUpdate = !0), null === i.mapPass && (i.mapPass = new ai(r.x, r.y)), f.uniforms.shadow_pass.value = i.map.texture, f.uniforms.resolution.value = i.mapSize, f.uniforms.radius.value = i.radius, e.setRenderTarget(i.mapPass), e.clear(), e.renderBufferDirect(n, null, a, f, _, null), g.uniforms.shadow_pass.value = i.mapPass.texture, g.uniforms.resolution.value = i.mapSize, g.uniforms.radius.value = i.radius, e.setRenderTarget(i.map), e.clear(), e.renderBufferDirect(n, null, a, g, _, null) } function y(t, i, n, r) { let a = null; const s = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial; if (void 0 !== s) a = s; else if (a = !0 === n.isPointLight ? l : o, e.localClippingEnabled && !0 === i.clipShadows && Array.isArray(i.clippingPlanes) && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0 || i.map && i.alphaTest > 0) { const e = a.uuid, t = i.uuid; let n = c[e]; void 0 === n && (n = {}, c[e] = n); let r = n[t]; void 0 === r && (r = a.clone(), n[t] = r, i.addEventListener("dispose", C)), a = r } if (a.visible = i.visible, a.wireframe = i.wireframe, a.side = 3 === r ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : d[i.side], a.alphaMap = i.alphaMap, a.alphaTest = i.alphaTest, a.map = i.map, a.clipShadows = i.clipShadows, a.clippingPlanes = i.clippingPlanes, a.clipIntersection = i.clipIntersection, a.displacementMap = i.displacementMap, a.displacementScale = i.displacementScale, a.displacementBias = i.displacementBias, a.wireframeLinewidth = i.wireframeLinewidth, a.linewidth = i.linewidth, !0 === n.isPointLight && !0 === a.isMeshDistanceMaterial) { e.properties.get(a).light = n } return a } function x(i, r, a, s, o) { if (!1 === i.visible) return; if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === o) && (!i.frustumCulled || n.intersectsObject(i))) { i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld); const n = t.update(i), l = i.material; if (Array.isArray(l)) { const t = n.groups; for (let c = 0, h = t.length; c < h; c++) { const h = t[c], d = l[h.materialIndex]; if (d && d.visible) { const t = y(i, d, s, o); i.onBeforeShadow(e, i, r, a, n, t, h), e.renderBufferDirect(a, null, n, t, i, h), i.onAfterShadow(e, i, r, a, n, t, h) } } } else if (l.visible) { const t = y(i, l, s, o); i.onBeforeShadow(e, i, r, a, n, t, null), e.renderBufferDirect(a, null, n, t, i, null), i.onAfterShadow(e, i, r, a, n, t, null) } } const l = i.children; for (let e = 0, t = l.length; e < t; e++)x(l[e], r, a, s, o) } function C(e) { e.target.removeEventListener("dispose", C); for (const t in c) { const i = c[t], n = e.target.uuid; if (n in i) { i[n].dispose(), delete i[n] } } } this.render = function (t, i, o) { if (!1 === b.enabled) return; if (!1 === b.autoUpdate && !1 === b.needsUpdate) return; if (0 === t.length) return; const l = e.getRenderTarget(), c = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), u = e.state; u.setBlending(0), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u.setScissorTest(!1); const A = 3 !== v && 3 === this.type, p = 3 === v && 3 !== this.type; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], d = c.shadow; if (void 0 === d) continue; if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue; r.copy(d.mapSize); const f = d.getFrameExtents(); if (r.multiply(f), a.copy(d.mapSize), (r.x > h || r.y > h) && (r.x > h && (a.x = Math.floor(h / f.x), r.x = a.x * f.x, d.mapSize.x = a.x), r.y > h && (a.y = Math.floor(h / f.y), r.y = a.y * f.y, d.mapSize.y = a.y)), null === d.map || !0 === A || !0 === p) { const e = 3 !== this.type ? { minFilter: K, magFilter: K } : {}; null !== d.map && d.map.dispose(), d.map = new ai(r.x, r.y, e), d.map.texture.name = c.name + ".shadowMap", d.camera.updateProjectionMatrix() } e.setRenderTarget(d.map), e.clear(); const g = d.getViewportCount(); for (let e = 0; e < g; e++) { const t = d.getViewport(e); s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w), u.viewport(s), d.updateMatrices(c, e), n = d.getFrustum(), x(i, o, d.camera, c, this.type) } !0 !== d.isPointLightShadow && 3 === this.type && E(d, o), d.needsUpdate = !1 } v = this.type, b.needsUpdate = !1, e.setRenderTarget(l, c, d) } } const Gc = { [L]: 1, [P]: 6, [F]: 7, [Q]: 5, [U]: 0, [k]: 2, [O]: 4, [N]: 3 }; function Hc(e, t) { const i = new function () { let t = !1; const i = new ni; let n = null; const r = new ni(0, 0, 0, 0); return { setMask: function (i) { n === i || t || (e.colorMask(i, i, i, i), n = i) }, setLocked: function (e) { t = e }, setClear: function (t, n, a, s, o) { !0 === o && (t *= s, n *= s, a *= s), i.set(t, n, a, s), !1 === r.equals(i) && (e.clearColor(t, n, a, s), r.copy(i)) }, reset: function () { t = !1, n = null, r.set(-1, 0, 0, 0) } } }, n = new function () { let i = !1, n = !1, r = null, a = null, s = null; return { setReversed: function (e) { if (n !== e) { const i = t.get("EXT_clip_control"); e ? i.clipControlEXT(i.LOWER_LEFT_EXT, i.ZERO_TO_ONE_EXT) : i.clipControlEXT(i.LOWER_LEFT_EXT, i.NEGATIVE_ONE_TO_ONE_EXT), n = e; const r = s; s = null, this.setClear(r) } }, getReversed: function () { return n }, setTest: function (t) { t ? re(e.DEPTH_TEST) : ae(e.DEPTH_TEST) }, setMask: function (t) { r === t || i || (e.depthMask(t), r = t) }, setFunc: function (t) { if (n && (t = Gc[t]), a !== t) { switch (t) { case 0: e.depthFunc(e.NEVER); break; case 1: e.depthFunc(e.ALWAYS); break; case 2: e.depthFunc(e.LESS); break; case 3: default: e.depthFunc(e.LEQUAL); break; case 4: e.depthFunc(e.EQUAL); break; case 5: e.depthFunc(e.GEQUAL); break; case 6: e.depthFunc(e.GREATER); break; case 7: e.depthFunc(e.NOTEQUAL) }a = t } }, setLocked: function (e) { i = e }, setClear: function (t) { s !== t && (n && (t = 1 - t), e.clearDepth(t), s = t) }, reset: function () { i = !1, r = null, a = null, s = null, n = !1 } } }, r = new function () { let t = !1, i = null, n = null, r = null, a = null, s = null, o = null, l = null, c = null; return { setTest: function (i) { t || (i ? re(e.STENCIL_TEST) : ae(e.STENCIL_TEST)) }, setMask: function (n) { i === n || t || (e.stencilMask(n), i = n) }, setFunc: function (t, i, s) { n === t && r === i && a === s || (e.stencilFunc(t, i, s), n = t, r = i, a = s) }, setOp: function (t, i, n) { s === t && o === i && l === n || (e.stencilOp(t, i, n), s = t, o = i, l = n) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, i = null, n = null, r = null, a = null, s = null, o = null, l = null, c = null } } }, a = new WeakMap, s = new WeakMap; let o = {}, l = {}, c = new WeakMap, h = [], d = null, u = !1, A = null, p = null, L = null, U = null, P = null, Q = null, F = null, N = new Dn(0, 0, 0), k = 0, O = !1, G = null, H = null, z = null, V = null, W = null; const j = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let q = !1, X = 0; const Y = e.getParameter(e.VERSION); -1 !== Y.indexOf("WebGL") ? (X = parseFloat(/^WebGL (\d)/.exec(Y)[1]), q = X >= 1) : -1 !== Y.indexOf("OpenGL ES") && (X = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]), q = X >= 2); let K = null, J = {}; const Z = e.getParameter(e.SCISSOR_BOX), $ = e.getParameter(e.VIEWPORT), ee = (new ni).fromArray(Z), te = (new ni).fromArray($); function ie(t, i, n, r) { const a = new Uint8Array(4), s = e.createTexture(); e.bindTexture(t, s), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST); for (let s = 0; s < n; s++)t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(i, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage2D(i + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a); return s } const ne = {}; function re(t) { !0 !== o[t] && (e.enable(t), o[t] = !0) } function ae(t) { !1 !== o[t] && (e.disable(t), o[t] = !1) } ne[e.TEXTURE_2D] = ie(e.TEXTURE_2D, e.TEXTURE_2D, 1), ne[e.TEXTURE_CUBE_MAP] = ie(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ne[e.TEXTURE_2D_ARRAY] = ie(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), ne[e.TEXTURE_3D] = ie(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), n.setClear(1), r.setClear(0), re(e.DEPTH_TEST), n.setFunc(3), ce(!1), he(1), re(e.CULL_FACE), le(0); const se = { [f]: e.FUNC_ADD, [g]: e.FUNC_SUBTRACT, [m]: e.FUNC_REVERSE_SUBTRACT }; se[103] = e.MIN, se[104] = e.MAX; const oe = { [_]: e.ZERO, [b]: e.ONE, [v]: e.SRC_COLOR, [y]: e.SRC_ALPHA, [M]: e.SRC_ALPHA_SATURATE, [S]: e.DST_COLOR, [C]: e.DST_ALPHA, [E]: e.ONE_MINUS_SRC_COLOR, [x]: e.ONE_MINUS_SRC_ALPHA, [w]: e.ONE_MINUS_DST_COLOR, [I]: e.ONE_MINUS_DST_ALPHA, [B]: e.CONSTANT_COLOR, [T]: e.ONE_MINUS_CONSTANT_COLOR, [R]: e.CONSTANT_ALPHA, [D]: e.ONE_MINUS_CONSTANT_ALPHA }; function le(t, i, n, r, a, s, o, l, c, h) { if (0 !== t) { if (!1 === u && (re(e.BLEND), u = !0), 5 === t) a = a || i, s = s || n, o = o || r, i === p && a === P || (e.blendEquationSeparate(se[i], se[a]), p = i, P = a), n === L && r === U && s === Q && o === F || (e.blendFuncSeparate(oe[n], oe[r], oe[s], oe[o]), L = n, U = r, Q = s, F = o), !1 !== l.equals(N) && c === k || (e.blendColor(l.r, l.g, l.b, c), N.copy(l), k = c), A = t, O = !1; else if (t !== A || h !== O) { if (p === f && P === f || (e.blendEquation(e.FUNC_ADD), p = f, P = f), h) switch (t) { case 1: e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case 2: e.blendFunc(e.ONE, e.ONE); break; case 3: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case 4: e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA) } else switch (t) { case 1: e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case 2: e.blendFunc(e.SRC_ALPHA, e.ONE); break; case 3: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case 4: e.blendFunc(e.ZERO, e.SRC_COLOR) }L = null, U = null, Q = null, F = null, N.set(0, 0, 0), k = 0, A = t, O = h } } else !0 === u && (ae(e.BLEND), u = !1) } function ce(t) { G !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), G = t) } function he(t) { 0 !== t ? (re(e.CULL_FACE), t !== H && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : ae(e.CULL_FACE), H = t } function de(t, i, n) { t ? (re(e.POLYGON_OFFSET_FILL), V === i && W === n || (e.polygonOffset(i, n), V = i, W = n)) : ae(e.POLYGON_OFFSET_FILL) } return { buffers: { color: i, depth: n, stencil: r }, enable: re, disable: ae, bindFramebuffer: function (t, i) { return l[t] !== i && (e.bindFramebuffer(t, i), l[t] = i, t === e.DRAW_FRAMEBUFFER && (l[e.FRAMEBUFFER] = i), t === e.FRAMEBUFFER && (l[e.DRAW_FRAMEBUFFER] = i), !0) }, drawBuffers: function (t, i) { let n = h, r = !1; if (t) { n = c.get(i), void 0 === n && (n = [], c.set(i, n)); const a = t.textures; if (n.length !== a.length || n[0] !== e.COLOR_ATTACHMENT0) { for (let t = 0, i = a.length; t < i; t++)n[t] = e.COLOR_ATTACHMENT0 + t; n.length = a.length, r = !0 } } else n[0] !== e.BACK && (n[0] = e.BACK, r = !0); r && e.drawBuffers(n) }, useProgram: function (t) { return d !== t && (e.useProgram(t), d = t, !0) }, setBlending: le, setMaterial: function (t, a) { 2 === t.side ? ae(e.CULL_FACE) : re(e.CULL_FACE); let s = 1 === t.side; a && (s = !s), ce(s), 1 === t.blending && !1 === t.transparent ? le(0) : le(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), n.setFunc(t.depthFunc), n.setTest(t.depthTest), n.setMask(t.depthWrite), i.setMask(t.colorWrite); const o = t.stencilWrite; r.setTest(o), o && (r.setMask(t.stencilWriteMask), r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), de(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? re(e.SAMPLE_ALPHA_TO_COVERAGE) : ae(e.SAMPLE_ALPHA_TO_COVERAGE) }, setFlipSided: ce, setCullFace: he, setLineWidth: function (t) { t !== z && (q && e.lineWidth(t), z = t) }, setPolygonOffset: de, setScissorTest: function (t) { t ? re(e.SCISSOR_TEST) : ae(e.SCISSOR_TEST) }, activeTexture: function (t) { void 0 === t && (t = e.TEXTURE0 + j - 1), K !== t && (e.activeTexture(t), K = t) }, bindTexture: function (t, i, n) { void 0 === n && (n = null === K ? e.TEXTURE0 + j - 1 : K); let r = J[n]; void 0 === r && (r = { type: void 0, texture: void 0 }, J[n] = r), r.type === t && r.texture === i || (K !== n && (e.activeTexture(n), K = n), e.bindTexture(t, i || ne[t]), r.type = t, r.texture = i) }, unbindTexture: function () { const t = J[K]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D(...arguments) } catch (e) { } }, compressedTexImage3D: function () { try { e.compressedTexImage3D(...arguments) } catch (e) { } }, texImage2D: function () { try { e.texImage2D(...arguments) } catch (e) { } }, texImage3D: function () { try { e.texImage3D(...arguments) } catch (e) { } }, updateUBOMapping: function (t, i) { let n = s.get(i); void 0 === n && (n = new WeakMap, s.set(i, n)); let r = n.get(t); void 0 === r && (r = e.getUniformBlockIndex(i, t.name), n.set(t, r)) }, uniformBlockBinding: function (t, i) { const n = s.get(i).get(t); a.get(i) !== n && (e.uniformBlockBinding(i, n, t.__bindingPointIndex), a.set(i, n)) }, texStorage2D: function () { try { e.texStorage2D(...arguments) } catch (e) { } }, texStorage3D: function () { try { e.texStorage3D(...arguments) } catch (e) { } }, texSubImage2D: function () { try { e.texSubImage2D(...arguments) } catch (e) { } }, texSubImage3D: function () { try { e.texSubImage3D(...arguments) } catch (e) { } }, compressedTexSubImage2D: function () { try { e.compressedTexSubImage2D(...arguments) } catch (e) { } }, compressedTexSubImage3D: function () { try { e.compressedTexSubImage3D(...arguments) } catch (e) { } }, scissor: function (t) { !1 === ee.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), ee.copy(t)) }, viewport: function (t) { !1 === te.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), te.copy(t)) }, reset: function () { e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), n.setReversed(!1), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), o = {}, K = null, J = {}, l = {}, c = new WeakMap, h = [], d = null, u = !1, A = null, p = null, L = null, U = null, P = null, Q = null, F = null, N = new Dn(0, 0, 0), k = 0, O = !1, G = null, H = null, z = null, V = null, W = null, ee.set(0, 0, e.canvas.width, e.canvas.height), te.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), n.reset(), r.reset() } } } function zc(e, t, i, n, r, a, s) { const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), c = new Qt, h = new WeakMap; let d; const u = new WeakMap; let A = !1; try { A = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function p(e, t) { return A ? new OffscreenCanvas(e, t) : Ot("canvas") } function f(e, t, i) { let n = 1; const r = G(e); if ((r.width > i || r.height > i) && (n = i / Math.max(r.width, r.height)), n < 1) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) { const i = Math.floor(n * r.width), a = Math.floor(n * r.height); void 0 === d && (d = p(i, a)); const s = t ? p(i, a) : d; s.width = i, s.height = a; return s.getContext("2d").drawImage(e, 0, 0, i, a), s } return e } return e } function g(e) { return e.generateMipmaps } function m(t) { e.generateMipmap(t) } function _(t) { return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D } function b(i, n, r, a, s = !1) { if (null !== i && void 0 !== e[i]) return e[i]; let o = n; if (n === e.RED && (r === e.FLOAT && (o = e.R32F), r === e.HALF_FLOAT && (o = e.R16F), r === e.UNSIGNED_BYTE && (o = e.R8)), n === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.R8UI), r === e.UNSIGNED_SHORT && (o = e.R16UI), r === e.UNSIGNED_INT && (o = e.R32UI), r === e.BYTE && (o = e.R8I), r === e.SHORT && (o = e.R16I), r === e.INT && (o = e.R32I)), n === e.RG && (r === e.FLOAT && (o = e.RG32F), r === e.HALF_FLOAT && (o = e.RG16F), r === e.UNSIGNED_BYTE && (o = e.RG8)), n === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RG8UI), r === e.UNSIGNED_SHORT && (o = e.RG16UI), r === e.UNSIGNED_INT && (o = e.RG32UI), r === e.BYTE && (o = e.RG8I), r === e.SHORT && (o = e.RG16I), r === e.INT && (o = e.RG32I)), n === e.RGB_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGB8UI), r === e.UNSIGNED_SHORT && (o = e.RGB16UI), r === e.UNSIGNED_INT && (o = e.RGB32UI), r === e.BYTE && (o = e.RGB8I), r === e.SHORT && (o = e.RGB16I), r === e.INT && (o = e.RGB32I)), n === e.RGBA_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI), r === e.UNSIGNED_SHORT && (o = e.RGBA16UI), r === e.UNSIGNED_INT && (o = e.RGBA32UI), r === e.BYTE && (o = e.RGBA8I), r === e.SHORT && (o = e.RGBA16I), r === e.INT && (o = e.RGBA32I)), n === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5), n === e.RGBA) { const t = s ? ct : qt.getTransfer(a); r === e.FLOAT && (o = e.RGBA32F), r === e.HALF_FLOAT && (o = e.RGBA16F), r === e.UNSIGNED_BYTE && (o = t === ht ? e.SRGB8_ALPHA8 : e.RGBA8), r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4), r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1) } return o !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || t.get("EXT_color_buffer_float"), o } function v(t, i) { let n; return t ? null === i || i === oe || i === ue ? n = e.DEPTH24_STENCIL8 : i === le ? n = e.DEPTH32F_STENCIL8 : i === ae && (n = e.DEPTH24_STENCIL8) : null === i || i === oe || i === ue ? n = e.DEPTH_COMPONENT24 : i === le ? n = e.DEPTH_COMPONENT32F : i === ae && (n = e.DEPTH_COMPONENT16), n } function E(e, t) { return !0 === g(e) || e.isFramebufferTexture && e.minFilter !== K && e.minFilter !== $ ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1 } function y(e) { const t = e.target; t.removeEventListener("dispose", y), function (e) { const t = n.get(e); if (void 0 === t.__webglInit) return; const i = e.source, r = u.get(i); if (r) { const n = r[t.__cacheKey]; n.usedTimes--, 0 === n.usedTimes && C(e), 0 === Object.keys(r).length && u.delete(i) } n.remove(e) }(t), t.isVideoTexture && h.delete(t) } function x(t) { const i = t.target; i.removeEventListener("dispose", x), function (t) { const i = n.get(t); t.depthTexture && (t.depthTexture.dispose(), n.remove(t.depthTexture)); if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) { if (Array.isArray(i.__webglFramebuffer[t])) for (let n = 0; n < i.__webglFramebuffer[t].length; n++)e.deleteFramebuffer(i.__webglFramebuffer[t][n]); else e.deleteFramebuffer(i.__webglFramebuffer[t]); i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]) } else { if (Array.isArray(i.__webglFramebuffer)) for (let t = 0; t < i.__webglFramebuffer.length; t++)e.deleteFramebuffer(i.__webglFramebuffer[t]); else e.deleteFramebuffer(i.__webglFramebuffer); if (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer) for (let t = 0; t < i.__webglColorRenderbuffer.length; t++)i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]); i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer) } const r = t.textures; for (let t = 0, i = r.length; t < i; t++) { const i = n.get(r[t]); i.__webglTexture && (e.deleteTexture(i.__webglTexture), s.memory.textures--), n.remove(r[t]) } n.remove(t) }(i) } function C(t) { const i = n.get(t); e.deleteTexture(i.__webglTexture); const r = t.source; delete u.get(r)[i.__cacheKey], s.memory.textures-- } let I = 0; function S(t, r) { const a = n.get(t); if (t.isVideoTexture && function (e) { const t = s.render.frame; h.get(e) !== t && (h.set(e, t), e.update()) }(t), !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) { const e = t.image; if (null === e); else if (!1 !== e.complete) return void D(a, t, r) } i.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + r) } const w = { [q]: e.REPEAT, [X]: e.CLAMP_TO_EDGE, [Y]: e.MIRRORED_REPEAT }, M = { [K]: e.NEAREST, [J]: e.NEAREST_MIPMAP_NEAREST, [Z]: e.NEAREST_MIPMAP_LINEAR, [$]: e.LINEAR, [ee]: e.LINEAR_MIPMAP_NEAREST, [te]: e.LINEAR_MIPMAP_LINEAR }, B = { [ut]: e.NEVER, [bt]: e.ALWAYS, [At]: e.LESS, [ft]: e.LEQUAL, [pt]: e.EQUAL, [_t]: e.GEQUAL, [gt]: e.GREATER, [mt]: e.NOTEQUAL }; function T(i, a) { if (a.type === le && !1 === t.has("OES_texture_float_linear") && (a.magFilter === $ || a.magFilter === ee || a.magFilter === Z || a.magFilter === te || a.minFilter === $ || a.minFilter === ee || a.minFilter === Z || a.minFilter), e.texParameteri(i, e.TEXTURE_WRAP_S, w[a.wrapS]), e.texParameteri(i, e.TEXTURE_WRAP_T, w[a.wrapT]), i !== e.TEXTURE_3D && i !== e.TEXTURE_2D_ARRAY || e.texParameteri(i, e.TEXTURE_WRAP_R, w[a.wrapR]), e.texParameteri(i, e.TEXTURE_MAG_FILTER, M[a.magFilter]), e.texParameteri(i, e.TEXTURE_MIN_FILTER, M[a.minFilter]), a.compareFunction && (e.texParameteri(i, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(i, e.TEXTURE_COMPARE_FUNC, B[a.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) { if (a.magFilter === K) return; if (a.minFilter !== Z && a.minFilter !== te) return; if (a.type === le && !1 === t.has("OES_texture_float_linear")) return; if (a.anisotropy > 1 || n.get(a).__currentAnisotropy) { const s = t.get("EXT_texture_filter_anisotropic"); e.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy } } } function R(t, i) { let n = !1; void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", y)); const r = i.source; let a = u.get(r); void 0 === a && (a = {}, u.set(r, a)); const o = function (e) { const t = []; return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join() }(i); if (o !== t.__cacheKey) { void 0 === a[o] && (a[o] = { texture: e.createTexture(), usedTimes: 0 }, s.memory.textures++, n = !0), a[o].usedTimes++; const r = a[t.__cacheKey]; void 0 !== r && (a[t.__cacheKey].usedTimes--, 0 === r.usedTimes && C(i)), t.__cacheKey = o, t.__webglTexture = a[o].texture } return n } function D(t, s, o) { let l = e.TEXTURE_2D; (s.isDataArrayTexture || s.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY), s.isData3DTexture && (l = e.TEXTURE_3D); const c = R(t, s), h = s.source; i.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o); const d = n.get(h); if (h.version !== d.__version || !0 === c) { i.activeTexture(e.TEXTURE0 + o); const t = qt.getPrimaries(qt.workingColorSpace), n = s.colorSpace === st ? null : qt.getPrimaries(s.colorSpace), u = s.colorSpace === st || t === n ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u); let A = f(s.image, !1, r.maxTextureSize); A = O(s, A); const p = a.convert(s.format, s.colorSpace), _ = a.convert(s.type); let y, x = b(s.internalFormat, p, _, s.colorSpace, s.isVideoTexture); T(l, s); const C = s.mipmaps, I = !0 !== s.isVideoTexture, S = void 0 === d.__version || !0 === c, w = h.dataReady, M = E(s, A); if (s.isDepthTexture) x = v(s.format === ge, s.type), S && (I ? i.texStorage2D(e.TEXTURE_2D, 1, x, A.width, A.height) : i.texImage2D(e.TEXTURE_2D, 0, x, A.width, A.height, 0, p, _, null)); else if (s.isDataTexture) if (C.length > 0) { I && S && i.texStorage2D(e.TEXTURE_2D, M, x, C[0].width, C[0].height); for (let t = 0, n = C.length; t < n; t++)y = C[t], I ? w && i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, y.width, y.height, p, _, y.data) : i.texImage2D(e.TEXTURE_2D, t, x, y.width, y.height, 0, p, _, y.data); s.generateMipmaps = !1 } else I ? (S && i.texStorage2D(e.TEXTURE_2D, M, x, A.width, A.height), w && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, A.width, A.height, p, _, A.data)) : i.texImage2D(e.TEXTURE_2D, 0, x, A.width, A.height, 0, p, _, A.data); else if (s.isCompressedTexture) if (s.isCompressedArrayTexture) { I && S && i.texStorage3D(e.TEXTURE_2D_ARRAY, M, x, C[0].width, C[0].height, A.depth); for (let t = 0, n = C.length; t < n; t++)if (y = C[t], s.format !== pe) { if (null !== p) if (I) { if (w) if (s.layerUpdates.size > 0) { const n = po(y.width, y.height, s.format, s.type); for (const r of s.layerUpdates) { const a = y.data.subarray(r * n / y.data.BYTES_PER_ELEMENT, (r + 1) * n / y.data.BYTES_PER_ELEMENT); i.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, y.width, y.height, 1, p, a) } s.clearLayerUpdates() } else i.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, y.width, y.height, A.depth, p, y.data) } else i.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, x, y.width, y.height, A.depth, 0, y.data, 0, 0) } else I ? w && i.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, y.width, y.height, A.depth, p, _, y.data) : i.texImage3D(e.TEXTURE_2D_ARRAY, t, x, y.width, y.height, A.depth, 0, p, _, y.data) } else { I && S && i.texStorage2D(e.TEXTURE_2D, M, x, C[0].width, C[0].height); for (let t = 0, n = C.length; t < n; t++)y = C[t], s.format !== pe ? null !== p && (I ? w && i.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, y.width, y.height, p, y.data) : i.compressedTexImage2D(e.TEXTURE_2D, t, x, y.width, y.height, 0, y.data)) : I ? w && i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, y.width, y.height, p, _, y.data) : i.texImage2D(e.TEXTURE_2D, t, x, y.width, y.height, 0, p, _, y.data) } else if (s.isDataArrayTexture) if (I) { if (S && i.texStorage3D(e.TEXTURE_2D_ARRAY, M, x, A.width, A.height, A.depth), w) if (s.layerUpdates.size > 0) { const t = po(A.width, A.height, s.format, s.type); for (const n of s.layerUpdates) { const r = A.data.subarray(n * t / A.data.BYTES_PER_ELEMENT, (n + 1) * t / A.data.BYTES_PER_ELEMENT); i.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, n, A.width, A.height, 1, p, _, r) } s.clearLayerUpdates() } else i.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, A.width, A.height, A.depth, p, _, A.data) } else i.texImage3D(e.TEXTURE_2D_ARRAY, 0, x, A.width, A.height, A.depth, 0, p, _, A.data); else if (s.isData3DTexture) I ? (S && i.texStorage3D(e.TEXTURE_3D, M, x, A.width, A.height, A.depth), w && i.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, A.width, A.height, A.depth, p, _, A.data)) : i.texImage3D(e.TEXTURE_3D, 0, x, A.width, A.height, A.depth, 0, p, _, A.data); else if (s.isFramebufferTexture) { if (S) if (I) i.texStorage2D(e.TEXTURE_2D, M, x, A.width, A.height); else { let t = A.width, n = A.height; for (let r = 0; r < M; r++)i.texImage2D(e.TEXTURE_2D, r, x, t, n, 0, p, _, null), t >>= 1, n >>= 1 } } else if (C.length > 0) { if (I && S) { const t = G(C[0]); i.texStorage2D(e.TEXTURE_2D, M, x, t.width, t.height) } for (let t = 0, n = C.length; t < n; t++)y = C[t], I ? w && i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, p, _, y) : i.texImage2D(e.TEXTURE_2D, t, x, p, _, y); s.generateMipmaps = !1 } else if (I) { if (S) { const t = G(A); i.texStorage2D(e.TEXTURE_2D, M, x, t.width, t.height) } w && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p, _, A) } else i.texImage2D(e.TEXTURE_2D, 0, x, p, _, A); g(s) && m(l), d.__version = h.version, s.onUpdate && s.onUpdate(s) } t.__version = s.version } function L(t, r, s, l, c, h) { const d = a.convert(s.format, s.colorSpace), u = a.convert(s.type), A = b(s.internalFormat, d, u, s.colorSpace), p = n.get(r), f = n.get(s); if (f.__renderTarget = r, !p.__hasExternalTextures) { const t = Math.max(1, r.width >> h), n = Math.max(1, r.height >> h); c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? i.texImage3D(c, h, A, t, n, r.depth, 0, d, u, null) : i.texImage2D(c, h, A, t, n, 0, d, u, null) } i.bindFramebuffer(e.FRAMEBUFFER, t), k(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, f.__webglTexture, 0, N(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, f.__webglTexture, h), i.bindFramebuffer(e.FRAMEBUFFER, null) } function U(t, i, n) { if (e.bindRenderbuffer(e.RENDERBUFFER, t), i.depthBuffer) { const r = i.depthTexture, a = r && r.isDepthTexture ? r.type : null, s = v(i.stencilBuffer, a), l = i.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, c = N(i); k(i) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, s, i.width, i.height) : n ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, s, i.width, i.height) : e.renderbufferStorage(e.RENDERBUFFER, s, i.width, i.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t) } else { const t = i.textures; for (let r = 0; r < t.length; r++) { const s = t[r], l = a.convert(s.format, s.colorSpace), c = a.convert(s.type), h = b(s.internalFormat, l, c, s.colorSpace), d = N(i); n && !1 === k(i) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, h, i.width, i.height) : k(i) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, h, i.width, i.height) : e.renderbufferStorage(e.RENDERBUFFER, h, i.width, i.height) } } e.bindRenderbuffer(e.RENDERBUFFER, null) } function P(t) { const r = n.get(t), a = !0 === t.isWebGLCubeRenderTarget; if (r.__boundDepthTexture !== t.depthTexture) { const e = t.depthTexture; if (r.__depthDisposeCallback && r.__depthDisposeCallback(), e) { const t = () => { delete r.__boundDepthTexture, delete r.__depthDisposeCallback, e.removeEventListener("dispose", t) }; e.addEventListener("dispose", t), r.__depthDisposeCallback = t } r.__boundDepthTexture = e } if (t.depthTexture && !r.__autoAllocateDepthBuffer) { if (a) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (i.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); const a = n.get(r.depthTexture); a.__renderTarget = r, a.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), S(r.depthTexture, 0); const s = a.__webglTexture, l = N(r); if (r.depthTexture.format === fe) k(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0); else { if (r.depthTexture.format !== ge) throw new Error("Unknown depthTexture format"); k(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0) } }(r.__webglFramebuffer, t) } else if (a) { r.__webglDepthbuffer = []; for (let n = 0; n < 6; n++)if (i.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[n]), void 0 === r.__webglDepthbuffer[n]) r.__webglDepthbuffer[n] = e.createRenderbuffer(), U(r.__webglDepthbuffer[n], t, !1); else { const i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, a = r.__webglDepthbuffer[n]; e.bindRenderbuffer(e.RENDERBUFFER, a), e.framebufferRenderbuffer(e.FRAMEBUFFER, i, e.RENDERBUFFER, a) } } else if (i.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), void 0 === r.__webglDepthbuffer) r.__webglDepthbuffer = e.createRenderbuffer(), U(r.__webglDepthbuffer, t, !1); else { const i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, n = r.__webglDepthbuffer; e.bindRenderbuffer(e.RENDERBUFFER, n), e.framebufferRenderbuffer(e.FRAMEBUFFER, i, e.RENDERBUFFER, n) } i.bindFramebuffer(e.FRAMEBUFFER, null) } const Q = [], F = []; function N(e) { return Math.min(r.maxSamples, e.samples) } function k(e) { const i = n.get(e); return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture } function O(e, t) { const i = e.colorSpace; e.format, e.type; return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || i !== lt && i !== st && qt.getTransfer(i), t } function G(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width, c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth, c.height = e.displayHeight) : (c.width = e.width, c.height = e.height), c } this.allocateTextureUnit = function () { const e = I; return r.maxTextures, I += 1, e }, this.resetTextureUnits = function () { I = 0 }, this.setTexture2D = S, this.setTexture2DArray = function (t, r) { const a = n.get(t); t.version > 0 && a.__version !== t.version ? D(a, t, r) : i.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + r) }, this.setTexture3D = function (t, r) { const a = n.get(t); t.version > 0 && a.__version !== t.version ? D(a, t, r) : i.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + r) }, this.setTextureCube = function (t, s) { const o = n.get(t); t.version > 0 && o.__version !== t.version ? function (t, s, o) { if (6 !== s.image.length) return; const l = R(t, s), c = s.source; i.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o); const h = n.get(c); if (c.version !== h.__version || !0 === l) { i.activeTexture(e.TEXTURE0 + o); const t = qt.getPrimaries(qt.workingColorSpace), n = s.colorSpace === st ? null : qt.getPrimaries(s.colorSpace), d = s.colorSpace === st || t === n ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d); const u = s.isCompressedTexture || s.image[0].isCompressedTexture, A = s.image[0] && s.image[0].isDataTexture, p = []; for (let e = 0; e < 6; e++)p[e] = u || A ? A ? s.image[e].image : s.image[e] : f(s.image[e], !0, r.maxCubemapSize), p[e] = O(s, p[e]); const _ = p[0], v = a.convert(s.format, s.colorSpace), y = a.convert(s.type), x = b(s.internalFormat, v, y, s.colorSpace), C = !0 !== s.isVideoTexture, I = void 0 === h.__version || !0 === l, S = c.dataReady; let w, M = E(s, _); if (T(e.TEXTURE_CUBE_MAP, s), u) { C && I && i.texStorage2D(e.TEXTURE_CUBE_MAP, M, x, _.width, _.height); for (let t = 0; t < 6; t++) { w = p[t].mipmaps; for (let n = 0; n < w.length; n++) { const r = w[n]; s.format !== pe ? null !== v && (C ? S && i.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, 0, 0, r.width, r.height, v, r.data) : i.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, x, r.width, r.height, 0, r.data)) : C ? S && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, 0, 0, r.width, r.height, v, y, r.data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, x, r.width, r.height, 0, v, y, r.data) } } } else { if (w = s.mipmaps, C && I) { w.length > 0 && M++; const t = G(p[0]); i.texStorage2D(e.TEXTURE_CUBE_MAP, M, x, t.width, t.height) } for (let t = 0; t < 6; t++)if (A) { C ? S && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, p[t].width, p[t].height, v, y, p[t].data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, x, p[t].width, p[t].height, 0, v, y, p[t].data); for (let n = 0; n < w.length; n++) { const r = w[n].image[t].image; C ? S && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, 0, 0, r.width, r.height, v, y, r.data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, x, r.width, r.height, 0, v, y, r.data) } } else { C ? S && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, v, y, p[t]) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, x, v, y, p[t]); for (let n = 0; n < w.length; n++) { const r = w[n]; C ? S && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, 0, 0, v, y, r.image[t]) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, x, v, y, r.image[t]) } } } g(s) && m(e.TEXTURE_CUBE_MAP), h.__version = c.version, s.onUpdate && s.onUpdate(s) } t.__version = s.version }(o, t, s) : i.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + s) }, this.rebindTextures = function (t, i, r) { const a = n.get(t); void 0 !== i && L(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== r && P(t) }, this.setupRenderTarget = function (t) { const r = t.texture, o = n.get(t), l = n.get(r); t.addEventListener("dispose", x); const c = t.textures, h = !0 === t.isWebGLCubeRenderTarget, d = c.length > 1; if (d || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = r.version, s.memory.textures++), h) { o.__webglFramebuffer = []; for (let t = 0; t < 6; t++)if (r.mipmaps && r.mipmaps.length > 0) { o.__webglFramebuffer[t] = []; for (let i = 0; i < r.mipmaps.length; i++)o.__webglFramebuffer[t][i] = e.createFramebuffer() } else o.__webglFramebuffer[t] = e.createFramebuffer() } else { if (r.mipmaps && r.mipmaps.length > 0) { o.__webglFramebuffer = []; for (let t = 0; t < r.mipmaps.length; t++)o.__webglFramebuffer[t] = e.createFramebuffer() } else o.__webglFramebuffer = e.createFramebuffer(); if (d) for (let t = 0, i = c.length; t < i; t++) { const i = n.get(c[t]); void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), s.memory.textures++) } if (t.samples > 0 && !1 === k(t)) { o.__webglMultisampledFramebuffer = e.createFramebuffer(), o.__webglColorRenderbuffer = [], i.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer); for (let i = 0; i < c.length; i++) { const n = c[i]; o.__webglColorRenderbuffer[i] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[i]); const r = a.convert(n.format, n.colorSpace), s = a.convert(n.type), l = b(n.internalFormat, r, s, n.colorSpace, !0 === t.isXRRenderTarget), h = N(t); e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + i, e.RENDERBUFFER, o.__webglColorRenderbuffer[i]) } e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(), U(o.__webglDepthRenderbuffer, t, !0)), i.bindFramebuffer(e.FRAMEBUFFER, null) } } if (h) { i.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), T(e.TEXTURE_CUBE_MAP, r); for (let i = 0; i < 6; i++)if (r.mipmaps && r.mipmaps.length > 0) for (let n = 0; n < r.mipmaps.length; n++)L(o.__webglFramebuffer[i][n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + i, n); else L(o.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0); g(r) && m(e.TEXTURE_CUBE_MAP), i.unbindTexture() } else if (d) { for (let r = 0, a = c.length; r < a; r++) { const a = c[r], s = n.get(a); i.bindTexture(e.TEXTURE_2D, s.__webglTexture), T(e.TEXTURE_2D, a), L(o.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0), g(a) && m(e.TEXTURE_2D) } i.unbindTexture() } else { let n = e.TEXTURE_2D; if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (n = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), i.bindTexture(n, l.__webglTexture), T(n, r), r.mipmaps && r.mipmaps.length > 0) for (let i = 0; i < r.mipmaps.length; i++)L(o.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, n, i); else L(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, n, 0); g(r) && m(n), i.unbindTexture() } t.depthBuffer && P(t) }, this.updateRenderTargetMipmap = function (e) { const t = e.textures; for (let r = 0, a = t.length; r < a; r++) { const a = t[r]; if (g(a)) { const t = _(e), r = n.get(a).__webglTexture; i.bindTexture(t, r), m(t), i.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (t) { if (t.samples > 0) if (!1 === k(t)) { const r = t.textures, a = t.width, s = t.height; let o = e.COLOR_BUFFER_BIT; const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, h = n.get(t), d = r.length > 1; if (d) for (let t = 0; t < r.length; t++)i.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), i.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0); i.bindFramebuffer(e.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), i.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer); for (let i = 0; i < r.length; i++) { if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)), d) { e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, h.__webglColorRenderbuffer[i]); const t = n.get(r[i]).__webglTexture; e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0) } e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST), !0 === l && (Q.length = 0, F.length = 0, Q.push(e.COLOR_ATTACHMENT0 + i), t.depthBuffer && !1 === t.resolveDepthBuffer && (Q.push(c), F.push(c), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, F)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, Q)) } if (i.bindFramebuffer(e.READ_FRAMEBUFFER, null), i.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), d) for (let t = 0; t < r.length; t++) { i.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, h.__webglColorRenderbuffer[t]); const a = n.get(r[t]).__webglTexture; i.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0) } i.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer) } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) { const i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT; e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [i]) } }, this.setupDepthRenderbuffer = P, this.setupFrameBufferTexture = L, this.useMultisampledRTT = k } function Vc(e, t) { return { convert: function (i, n = "") { let r; const a = qt.getTransfer(n); if (i === ie) return e.UNSIGNED_BYTE; if (i === he) return e.UNSIGNED_SHORT_4_4_4_4; if (i === de) return e.UNSIGNED_SHORT_5_5_5_1; if (i === Ae) return e.UNSIGNED_INT_5_9_9_9_REV; if (i === ne) return e.BYTE; if (i === re) return e.SHORT; if (i === ae) return e.UNSIGNED_SHORT; if (i === se) return e.INT; if (i === oe) return e.UNSIGNED_INT; if (i === le) return e.FLOAT; if (i === ce) return e.HALF_FLOAT; if (1021 === i) return e.ALPHA; if (1022 === i) return e.RGB; if (i === pe) return e.RGBA; if (1024 === i) return e.LUMINANCE; if (1025 === i) return e.LUMINANCE_ALPHA; if (i === fe) return e.DEPTH_COMPONENT; if (i === ge) return e.DEPTH_STENCIL; if (i === me) return e.RED; if (i === _e) return e.RED_INTEGER; if (i === be) return e.RG; if (i === ve) return e.RG_INTEGER; if (i === Ee) return e.RGBA_INTEGER; if (i === ye || i === xe || i === Ce || i === Ie) if (a === ht) { if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null; if (i === ye) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (i === xe) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (i === Ce) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (i === Ie) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null; if (i === ye) return r.COMPRESSED_RGB_S3TC_DXT1_EXT; if (i === xe) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (i === Ce) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (i === Ie) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (i === Se || i === we || i === Me || i === Be) { if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null; if (i === Se) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (i === we) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (i === Me) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (i === Be) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (i === Te || i === Re || i === De) { if (r = t.get("WEBGL_compressed_texture_etc"), null === r) return null; if (i === Te || i === Re) return a === ht ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2; if (i === De) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC } if (i === Le || i === Ue || i === Pe || i === Qe || i === Fe || i === Ne || i === ke || i === Oe || i === Ge || i === He || i === ze || i === Ve || i === We || i === je) { if (r = t.get("WEBGL_compressed_texture_astc"), null === r) return null; if (i === Le) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR; if (i === Ue) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR; if (i === Pe) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR; if (i === Qe) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR; if (i === Fe) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR; if (i === Ne) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR; if (i === ke) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR; if (i === Oe) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR; if (i === Ge) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR; if (i === He) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR; if (i === ze) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR; if (i === Ve) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR; if (i === We) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR; if (i === je) return a === ht ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR } if (i === qe || i === Xe || i === Ye) { if (r = t.get("EXT_texture_compression_bptc"), null === r) return null; if (i === qe) return a === ht ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (i === Xe) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (i === Ye) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } if (36283 === i || i === Ke || i === Je || i === Ze) { if (r = t.get("EXT_texture_compression_rgtc"), null === r) return null; if (i === qe) return r.COMPRESSED_RED_RGTC1_EXT; if (i === Ke) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (i === Je) return r.COMPRESSED_RED_GREEN_RGTC2_EXT; if (i === Ze) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } return i === ue ? e.UNSIGNED_INT_24_8 : void 0 !== e[i] ? e[i] : null } } } class Wc { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(e, t, i) { if (null === this.texture) { const n = new ii; e.properties.get(n).__webglTexture = t.texture, t.depthNear === i.depthNear && t.depthFar === i.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = n } } getMesh(e) { if (null !== this.texture && null === this.mesh) { const t = e.cameras[0].viewport, i = new Er({ vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}", fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}", uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } }); this.mesh = new pr(new Ha(20, 20), i) } return this.mesh } reset() { this.texture = null, this.mesh = null } getDepthTexture() { return this.texture } } class jc extends Ct { constructor(e, t) { super(); const i = this; let n = null, r = 1, a = null, s = "local-floor", o = 1, l = null, c = null, h = null, d = null, u = null, A = null; const p = new Wc, f = t.getContextAttributes(); let g = null, m = null; const _ = [], b = [], v = new Qt; let E = null; const y = new Sr; y.viewport = new ni; const x = new Sr; x.viewport = new ni; const C = [y, x], I = new Hs; let S = null, w = null; function M(e) { const t = b.indexOf(e.inputSource); if (-1 === t) return; const i = _[t]; void 0 !== i && (i.update(e.inputSource, e.frame, l || a), i.dispatchEvent({ type: e.type, data: e.inputSource })) } function B() { n.removeEventListener("select", M), n.removeEventListener("selectstart", M), n.removeEventListener("selectend", M), n.removeEventListener("squeeze", M), n.removeEventListener("squeezestart", M), n.removeEventListener("squeezeend", M), n.removeEventListener("end", B), n.removeEventListener("inputsourceschange", T); for (let e = 0; e < _.length; e++) { const t = b[e]; null !== t && (b[e] = null, _[e].disconnect(t)) } S = null, w = null, p.reset(), e.setRenderTarget(g), u = null, d = null, h = null, n = null, m = null, P.stop(), i.isPresenting = !1, e.setPixelRatio(E), e.setSize(v.width, v.height, !1), i.dispatchEvent({ type: "sessionend" }) } function T(e) { for (let t = 0; t < e.removed.length; t++) { const i = e.removed[t], n = b.indexOf(i); n >= 0 && (b[n] = null, _[n].disconnect(i)) } for (let t = 0; t < e.added.length; t++) { const i = e.added[t]; let n = b.indexOf(i); if (-1 === n) { for (let e = 0; e < _.length; e++) { if (e >= b.length) { b.push(i), n = e; break } if (null === b[e]) { b[e] = i, n = e; break } } if (-1 === n) break } const r = _[n]; r && r.connect(i) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = _[e]; return void 0 === t && (t = new Lr, _[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = _[e]; return void 0 === t && (t = new Lr, _[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = _[e]; return void 0 === t && (t = new Lr, _[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { r = e, i.isPresenting }, this.setReferenceSpaceType = function (e) { s = e, i.isPresenting }, this.getReferenceSpace = function () { return l || a }, this.setReferenceSpace = function (e) { l = e }, this.getBaseLayer = function () { return null !== d ? d : u }, this.getBinding = function () { return h }, this.getFrame = function () { return A }, this.getSession = function () { return n }, this.setSession = async function (c) { if (n = c, null !== n) { g = e.getRenderTarget(), n.addEventListener("select", M), n.addEventListener("selectstart", M), n.addEventListener("selectend", M), n.addEventListener("squeeze", M), n.addEventListener("squeezestart", M), n.addEventListener("squeezeend", M), n.addEventListener("end", B), n.addEventListener("inputsourceschange", T), !0 !== f.xrCompatible && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(v); if ("undefined" != typeof XRWebGLBinding && "createProjectionLayer" in XRWebGLBinding.prototype) { let i = null, a = null, s = null; f.depth && (s = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, i = f.stencil ? ge : fe, a = f.stencil ? ue : oe); const o = { colorFormat: t.RGBA8, depthFormat: s, scaleFactor: r }; h = new XRWebGLBinding(n, t), d = h.createProjectionLayer(o), n.updateRenderState({ layers: [d] }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), m = new ai(d.textureWidth, d.textureHeight, { format: pe, type: ie, depthTexture: new ka(d.textureWidth, d.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, i), stencilBuffer: f.stencil, colorSpace: e.outputColorSpace, samples: f.antialias ? 4 : 0, resolveDepthBuffer: !1 === d.ignoreDepthValues, resolveStencilBuffer: !1 === d.ignoreDepthValues }) } else { const i = { antialias: f.antialias, alpha: !0, depth: f.depth, stencil: f.stencil, framebufferScaleFactor: r }; u = new XRWebGLLayer(n, t, i), n.updateRenderState({ baseLayer: u }), e.setPixelRatio(1), e.setSize(u.framebufferWidth, u.framebufferHeight, !1), m = new ai(u.framebufferWidth, u.framebufferHeight, { format: pe, type: ie, colorSpace: e.outputColorSpace, stencilBuffer: f.stencil, resolveDepthBuffer: !1 === u.ignoreDepthValues, resolveStencilBuffer: !1 === u.ignoreDepthValues }) } m.isXRRenderTarget = !0, this.setFoveation(o), l = null, a = await n.requestReferenceSpace(s), P.setContext(n), P.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (null !== n) return n.environmentBlendMode }, this.getDepthTexture = function () { return p.getDepthTexture() }; const R = new ci, D = new ci; function L(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === n) return; let t = e.near, i = e.far; null !== p.texture && (p.depthNear > 0 && (t = p.depthNear), p.depthFar > 0 && (i = p.depthFar)), I.near = x.near = y.near = t, I.far = x.far = y.far = i, S === I.near && w === I.far || (n.updateRenderState({ depthNear: I.near, depthFar: I.far }), S = I.near, w = I.far), y.layers.mask = 2 | e.layers.mask, x.layers.mask = 4 | e.layers.mask, I.layers.mask = y.layers.mask | x.layers.mask; const r = e.parent, a = I.cameras; L(I, r); for (let e = 0; e < a.length; e++)L(a[e], r); 2 === a.length ? function (e, t, i) { R.setFromMatrixPosition(t.matrixWorld), D.setFromMatrixPosition(i.matrixWorld); const n = R.distanceTo(D), r = t.projectionMatrix.elements, a = i.projectionMatrix.elements, s = r[14] / (r[10] - 1), o = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], d = (a[8] + 1) / a[0], u = s * h, A = s * d, p = n / (-h + d), f = p * -h; if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(p), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === r[10]) e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse); else { const t = s + p, i = o + p, r = u - f, a = A + (n - f), h = l * o / i * t, d = c * o / i * t; e.projectionMatrix.makePerspective(r, a, h, d, t, i), e.projectionMatrixInverse.copy(e.projectionMatrix).invert() } }(I, y, x) : I.projectionMatrix.copy(y.projectionMatrix), function (e, t, i) { null === i ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(i.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld)); e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * Mt * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1) }(e, I, r) }, this.getCamera = function () { return I }, this.getFoveation = function () { if (null !== d || null !== u) return o }, this.setFoveation = function (e) { o = e, null !== d && (d.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e) }, this.hasDepthSensing = function () { return null !== p.texture }, this.getDepthSensingMesh = function () { return p.getMesh(I) }; let U = null; const P = new fo; P.setAnimationLoop((function (t, r) { if (c = r.getViewerPose(l || a), A = r, null !== c) { const t = c.views; null !== u && (e.setRenderTargetFramebuffer(m, u.framebuffer), e.setRenderTarget(m)); let i = !1; t.length !== I.cameras.length && (I.cameras.length = 0, i = !0); for (let n = 0; n < t.length; n++) { const r = t[n]; let a = null; if (null !== u) a = u.getViewport(r); else { const t = h.getViewSubImage(d, r); a = t.viewport, 0 === n && (e.setRenderTargetTextures(m, t.colorTexture, t.depthStencilTexture), e.setRenderTarget(m)) } let s = C[n]; void 0 === s && (s = new Sr, s.layers.enable(n), s.viewport = new ni, C[n] = s), s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.quaternion, s.scale), s.projectionMatrix.fromArray(r.projectionMatrix), s.projectionMatrixInverse.copy(s.projectionMatrix).invert(), s.viewport.set(a.x, a.y, a.width, a.height), 0 === n && (I.matrix.copy(s.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale)), !0 === i && I.cameras.push(s) } const r = n.enabledFeatures; if (r && r.includes("depth-sensing") && "gpu-optimized" == n.depthUsage && h) { const i = h.getDepthInformation(t[0]); i && i.isValid && i.texture && p.init(e, i, n.renderState) } } for (let e = 0; e < _.length; e++) { const t = b[e], i = _[e]; null !== t && void 0 !== i && i.update(t, r, l || a) } U && U(t, r), r.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: r }), A = null })), this.setAnimationLoop = function (e) { U = e }, this.dispose = function () { } } } const qc = new Yi, Xc = new ki; function Yc(e, t) { function i(e, t) { !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix) } function n(e, n) { e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map, i(n.map, e.mapTransform)), n.alphaMap && (e.alphaMap.value = n.alphaMap, i(n.alphaMap, e.alphaMapTransform)), n.bumpMap && (e.bumpMap.value = n.bumpMap, i(n.bumpMap, e.bumpMapTransform), e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, i(n.normalMap, e.normalMapTransform), e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, i(n.displacementMap, e.displacementMapTransform), e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap, i(n.emissiveMap, e.emissiveMapTransform)), n.specularMap && (e.specularMap.value = n.specularMap, i(n.specularMap, e.specularMapTransform)), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest); const r = t.get(n), a = r.envMap, s = r.envMapRotation; a && (e.envMap.value = a, qc.copy(s), qc.x *= -1, qc.y *= -1, qc.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (qc.y *= -1, qc.z *= -1), e.envMapRotation.value.setFromMatrix4(Xc.makeRotationFromEuler(qc)), e.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity, i(n.lightMap, e.lightMapTransform)), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity, i(n.aoMap, e.aoMapTransform)) } return { refreshFogUniforms: function (t, i) { i.color.getRGB(t.fogColor.value, br(e)), i.isFog ? (t.fogNear.value = i.near, t.fogFar.value = i.far) : i.isFogExp2 && (t.fogDensity.value = i.density) }, refreshMaterialUniforms: function (e, r, a, s, o) { r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(e, r) : r.isMeshToonMaterial ? (n(e, r), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap) }(e, r)) : r.isMeshPhongMaterial ? (n(e, r), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4) }(e, r)) : r.isMeshStandardMaterial ? (n(e, r), function (e, t) { e.metalness.value = t.metalness, t.metalnessMap && (e.metalnessMap.value = t.metalnessMap, i(t.metalnessMap, e.metalnessMapTransform)); e.roughness.value = t.roughness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap, i(t.roughnessMap, e.roughnessMapTransform)); t.envMap && (e.envMapIntensity.value = t.envMapIntensity) }(e, r), r.isMeshPhysicalMaterial && function (e, t, n) { e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, i(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, i(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))); t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, i(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, i(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, i(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), 1 === t.side && e.clearcoatNormalScale.value.negate())); t.dispersion > 0 && (e.dispersion.value = t.dispersion); t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, i(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, i(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))); t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = n.texture, e.transmissionSamplerSize.value.set(n.width, n.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, i(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, i(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)); t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, i(t.anisotropyMap, e.anisotropyMapTransform))); e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, i(t.specularColorMap, e.specularColorMapTransform)); t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, i(t.specularIntensityMap, e.specularIntensityMapTransform)) }(e, r, o)) : r.isMeshMatcapMaterial ? (n(e, r), function (e, t) { t.matcap && (e.matcap.value = t.matcap) }(e, r)) : r.isMeshDepthMaterial ? n(e, r) : r.isMeshDistanceMaterial ? (n(e, r), function (e, i) { const n = t.get(i).light; e.referencePosition.value.setFromMatrixPosition(n.matrixWorld), e.nearDistance.value = n.shadow.camera.near, e.farDistance.value = n.shadow.camera.far }(e, r)) : r.isMeshNormalMaterial ? n(e, r) : r.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, i(t.map, e.mapTransform)) }(e, r), r.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, r)) : r.isPointsMaterial ? function (e, t, n, r) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && (e.map.value = t.map, i(t.map, e.uvTransform)); t.alphaMap && (e.alphaMap.value = t.alphaMap, i(t.alphaMap, e.alphaMapTransform)); t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest) }(e, r, a, s) : r.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, i(t.map, e.mapTransform)); t.alphaMap && (e.alphaMap.value = t.alphaMap, i(t.alphaMap, e.alphaMapTransform)); t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest) }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function Kc(e, t, i, n) { let r = {}, a = {}, s = []; const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS); function l(e, t, i, n) { const r = e.value, a = t + "_" + i; if (void 0 === n[a]) return n[a] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0; { const e = n[a]; if ("number" == typeof r || "boolean" == typeof r) { if (e !== r) return n[a] = r, !0 } else if (!1 === e.equals(r)) return e.copy(r), !0 } return !1 } function c(e) { const t = { boundary: 0, storage: 0 }; return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture, t } function h(t) { const i = t.target; i.removeEventListener("dispose", h); const n = s.indexOf(i.__bindingPointIndex); s.splice(n, 1), e.deleteBuffer(r[i.id]), delete r[i.id], delete a[i.id] } return { bind: function (e, t) { const i = t.program; n.uniformBlockBinding(e, i) }, update: function (i, d) { let u = r[i.id]; void 0 === u && (!function (e) { const t = e.uniforms; let i = 0; const n = 16; for (let e = 0, r = t.length; e < r; e++) { const r = Array.isArray(t[e]) ? t[e] : [t[e]]; for (let e = 0, t = r.length; e < t; e++) { const t = r[e], a = Array.isArray(t.value) ? t.value : [t.value]; for (let e = 0, r = a.length; e < r; e++) { const r = c(a[e]), s = i % n, o = s % r.boundary, l = s + o; i += o, 0 !== l && n - l < r.storage && (i += n - l), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = i, i += r.storage } } } const r = i % n; r > 0 && (i += n - r); e.__size = i, e.__cache = {} }(i), u = function (t) { const i = function () { for (let e = 0; e < o; e++)if (-1 === s.indexOf(e)) return s.push(e), e; return 0 }(); t.__bindingPointIndex = i; const n = e.createBuffer(), r = t.__size, a = t.usage; return e.bindBuffer(e.UNIFORM_BUFFER, n), e.bufferData(e.UNIFORM_BUFFER, r, a), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, i, n), n }(i), r[i.id] = u, i.addEventListener("dispose", h)); const A = d.program; n.updateUBOMapping(i, A); const p = t.render.frame; a[i.id] !== p && (!function (t) { const i = r[t.id], n = t.uniforms, a = t.__cache; e.bindBuffer(e.UNIFORM_BUFFER, i); for (let t = 0, i = n.length; t < i; t++) { const i = Array.isArray(n[t]) ? n[t] : [n[t]]; for (let n = 0, r = i.length; n < r; n++) { const r = i[n]; if (!0 === l(r, t, n, a)) { const t = r.__offset, i = Array.isArray(r.value) ? r.value : [r.value]; let n = 0; for (let a = 0; a < i.length; a++) { const s = i[a], o = c(s); "number" == typeof s || "boolean" == typeof s ? (r.__data[0] = s, e.bufferSubData(e.UNIFORM_BUFFER, t + n, r.__data)) : s.isMatrix3 ? (r.__data[0] = s.elements[0], r.__data[1] = s.elements[1], r.__data[2] = s.elements[2], r.__data[3] = 0, r.__data[4] = s.elements[3], r.__data[5] = s.elements[4], r.__data[6] = s.elements[5], r.__data[7] = 0, r.__data[8] = s.elements[6], r.__data[9] = s.elements[7], r.__data[10] = s.elements[8], r.__data[11] = 0) : (s.toArray(r.__data, n), n += o.storage / Float32Array.BYTES_PER_ELEMENT) } e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data) } } } e.bindBuffer(e.UNIFORM_BUFFER, null) }(i), a[i.id] = p) }, dispose: function () { for (const t in r) e.deleteBuffer(r[t]); s = [], r = {}, a = {} } } } class Jc { constructor(e = {}) { const { canvas: t = Gt(), context: i = null, depth: n = !0, stencil: a = !1, alpha: s = !1, antialias: o = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: c = !1, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = !1, reverseDepthBuffer: u = !1 } = e; let A; if (this.isWebGLRenderer = !0, null !== i) { if ("undefined" != typeof WebGLRenderingContext && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163."); A = i.getContextAttributes().alpha } else A = s; const p = new Uint32Array(4), f = new Int32Array(4); let g = null, m = null; const _ = [], b = []; this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1; const v = this; let E = !1; this._outputColorSpace = ot; let y = 0, x = 0, C = null, I = -1, S = null; const w = new ni, M = new ni; let B = null; const T = new Dn(0); let R = 0, D = t.width, L = t.height, U = 1, P = null, Q = null; const F = new ni(0, 0, D, L), N = new ni(0, 0, D, L); let k = !1; const O = new pa; let G = !1, H = !1; const z = new ki, V = new ki, W = new ci, j = new ni, q = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; let X = !1; function Y() { return null === C ? U : 1 } let K, J, Z, $, ee, ne, re, se, le, Ae, pe, fe, ge, me, be, ye, xe, Ce, Ie, Se, we, Me, Be, Te, Re = i; function De(e, i) { return t.getContext(e, i) } try { const e = { alpha: !0, depth: n, stencil: a, antialias: o, premultipliedAlpha: l, preserveDrawingBuffer: c, powerPreference: h, failIfMajorPerformanceCaveat: d }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${r}`), t.addEventListener("webglcontextlost", Pe, !1), t.addEventListener("webglcontextrestored", Qe, !1), t.addEventListener("webglcontextcreationerror", Fe, !1), null === Re) { const t = "webgl2"; if (Re = De(t, e), null === Re) throw De(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } } catch (e) { throw e } function Le() { K = new Xo(Re), K.init(), Me = new Vc(Re, K), J = new So(Re, K, e, Me), Z = new Hc(Re, K), J.reverseDepthBuffer && u && Z.buffers.depth.setReversed(!0), $ = new Jo(Re), ee = new Bc, ne = new zc(Re, K, Z, ee, J, Me, $), re = new Mo(v), se = new qo(v), le = new go(Re), Be = new Co(Re, le), Ae = new Yo(Re, le, $, Be), pe = new $o(Re, Ae, le, $), Ie = new Zo(Re, J, ne), ye = new wo(ee), fe = new Mc(v, re, se, K, J, Be, ye), ge = new Yc(v, ee), me = new Lc, be = new kc(K), Ce = new xo(v, re, se, Z, pe, A, l), xe = new Oc(v, pe, J), Te = new Kc(Re, $, J, Z), Se = new Io(Re, K, $), we = new Ko(Re, K, $), $.programs = fe.programs, v.capabilities = J, v.extensions = K, v.properties = ee, v.renderLists = me, v.shadowMap = xe, v.state = Z, v.info = $ } Le(); const Ue = new jc(v, Re); function Pe(e) { e.preventDefault(), E = !0 } function Qe() { E = !1; const e = $.autoReset, t = xe.enabled, i = xe.autoUpdate, n = xe.needsUpdate, r = xe.type; Le(), $.autoReset = e, xe.enabled = t, xe.autoUpdate = i, xe.needsUpdate = n, xe.type = r } function Fe(e) { } function Ne(e) { const t = e.target; t.removeEventListener("dispose", Ne), function (e) { (function (e) { const t = ee.get(e).programs; void 0 !== t && (t.forEach((function (e) { fe.releaseProgram(e) })), e.isShaderMaterial && fe.releaseShaderCache(e)) })(e), ee.remove(e) }(t) } function ke(e, t, i) { !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1, e.needsUpdate = !0, Ye(e, t, i), e.side = 0, e.needsUpdate = !0, Ye(e, t, i), e.side = 2) : Ye(e, t, i) } this.xr = Ue, this.getContext = function () { return Re }, this.getContextAttributes = function () { return Re.getContextAttributes() }, this.forceContextLoss = function () { const e = K.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = K.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return U }, this.setPixelRatio = function (e) { void 0 !== e && (U = e, this.setSize(D, L, !1)) }, this.getSize = function (e) { return e.set(D, L) }, this.setSize = function (e, i, n = !0) { Ue.isPresenting || (D = e, L = i, t.width = Math.floor(e * U), t.height = Math.floor(i * U), !0 === n && (t.style.width = e + "px", t.style.height = i + "px"), this.setViewport(0, 0, e, i)) }, this.getDrawingBufferSize = function (e) { return e.set(D * U, L * U).floor() }, this.setDrawingBufferSize = function (e, i, n) { D = e, L = i, U = n, t.width = Math.floor(e * n), t.height = Math.floor(i * n), this.setViewport(0, 0, e, i) }, this.getCurrentViewport = function (e) { return e.copy(w) }, this.getViewport = function (e) { return e.copy(F) }, this.setViewport = function (e, t, i, n) { e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, i, n), Z.viewport(w.copy(F).multiplyScalar(U).round()) }, this.getScissor = function (e) { return e.copy(N) }, this.setScissor = function (e, t, i, n) { e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, i, n), Z.scissor(M.copy(N).multiplyScalar(U).round()) }, this.getScissorTest = function () { return k }, this.setScissorTest = function (e) { Z.setScissorTest(k = e) }, this.setOpaqueSort = function (e) { P = e }, this.setTransparentSort = function (e) { Q = e }, this.getClearColor = function (e) { return e.copy(Ce.getClearColor()) }, this.setClearColor = function () { Ce.setClearColor(...arguments) }, this.getClearAlpha = function () { return Ce.getClearAlpha() }, this.setClearAlpha = function () { Ce.setClearAlpha(...arguments) }, this.clear = function (e = !0, t = !0, i = !0) { let n = 0; if (e) { let e = !1; if (null !== C) { const t = C.texture.format; e = t === Ee || t === ve || t === _e } if (e) { const e = C.texture.type, t = e === ie || e === oe || e === ae || e === ue || e === he || e === de, i = Ce.getClearColor(), n = Ce.getClearAlpha(), r = i.r, a = i.g, s = i.b; t ? (p[0] = r, p[1] = a, p[2] = s, p[3] = n, Re.clearBufferuiv(Re.COLOR, 0, p)) : (f[0] = r, f[1] = a, f[2] = s, f[3] = n, Re.clearBufferiv(Re.COLOR, 0, f)) } else n |= Re.COLOR_BUFFER_BIT } t && (n |= Re.DEPTH_BUFFER_BIT), i && (n |= Re.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Re.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", Pe, !1), t.removeEventListener("webglcontextrestored", Qe, !1), t.removeEventListener("webglcontextcreationerror", Fe, !1), Ce.dispose(), me.dispose(), be.dispose(), ee.dispose(), re.dispose(), se.dispose(), pe.dispose(), Be.dispose(), Te.dispose(), fe.dispose(), Ue.dispose(), Ue.removeEventListener("sessionstart", Ge), Ue.removeEventListener("sessionend", He), ze.stop() }, this.renderBufferDirect = function (e, t, i, n, r, a) { null === t && (t = q); const s = r.isMesh && r.matrixWorld.determinant() < 0, o = function (e, t, i, n, r) { !0 !== t.isScene && (t = q); ne.resetTextureUnits(); const a = t.fog, s = n.isMeshStandardMaterial ? t.environment : null, o = null === C ? v.outputColorSpace : !0 === C.isXRRenderTarget ? C.texture.colorSpace : lt, l = (n.isMeshStandardMaterial ? se : re).get(n.envMap || s), c = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize, h = !!i.attributes.tangent && (!!n.normalMap || n.anisotropy > 0), d = !!i.morphAttributes.position, u = !!i.morphAttributes.normal, A = !!i.morphAttributes.color; let p = 0; n.toneMapped && (null !== C && !0 !== C.isXRRenderTarget || (p = v.toneMapping)); const f = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, g = void 0 !== f ? f.length : 0, _ = ee.get(n), b = m.state.lights; if (!0 === G && (!0 === H || e !== S)) { const t = e === S && n.id === I; ye.setState(n, e, t) } let E = !1; n.version === _.__version ? _.needsLights && _.lightsStateVersion !== b.state.version || _.outputColorSpace !== o || r.isBatchedMesh && !1 === _.batching ? E = !0 : r.isBatchedMesh || !0 !== _.batching ? r.isBatchedMesh && !0 === _.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === _.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === _.instancing ? E = !0 : r.isInstancedMesh || !0 !== _.instancing ? r.isSkinnedMesh && !1 === _.skinning ? E = !0 : r.isSkinnedMesh || !0 !== _.skinning ? r.isInstancedMesh && !0 === _.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === _.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === _.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === _.instancingMorph && null !== r.morphTexture || _.envMap !== l || !0 === n.fog && _.fog !== a ? E = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === ye.numPlanes && _.numIntersection === ye.numIntersection ? (_.vertexAlphas !== c || _.vertexTangents !== h || _.morphTargets !== d || _.morphNormals !== u || _.morphColors !== A || _.toneMapping !== p || _.morphTargetsCount !== g) && (E = !0) : E = !0 : E = !0 : E = !0 : E = !0 : (E = !0, _.__version = n.version); let y = _.currentProgram; !0 === E && (y = Ye(n, t, r)); let x = !1, w = !1, M = !1; const B = y.getUniforms(), T = _.uniforms; Z.useProgram(y.program) && (x = !0, w = !0, M = !0); n.id !== I && (I = n.id, w = !0); if (x || S !== e) { Z.buffers.depth.getReversed() ? (z.copy(e.projectionMatrix), function (e) { const t = e.elements; t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15] }(z), function (e) { const t = e.elements; -1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = 1 - t[14]) }(z), B.setValue(Re, "projectionMatrix", z)) : B.setValue(Re, "projectionMatrix", e.projectionMatrix), B.setValue(Re, "viewMatrix", e.matrixWorldInverse); const t = B.map.cameraPosition; void 0 !== t && t.setValue(Re, W.setFromMatrixPosition(e.matrixWorld)), J.logarithmicDepthBuffer && B.setValue(Re, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && B.setValue(Re, "isOrthographic", !0 === e.isOrthographicCamera), S !== e && (S = e, w = !0, M = !0) } if (r.isSkinnedMesh) { B.setOptional(Re, r, "bindMatrix"), B.setOptional(Re, r, "bindMatrixInverse"); const e = r.skeleton; e && (null === e.boneTexture && e.computeBoneTexture(), B.setValue(Re, "boneTexture", e.boneTexture, ne)) } r.isBatchedMesh && (B.setOptional(Re, r, "batchingTexture"), B.setValue(Re, "batchingTexture", r._matricesTexture, ne), B.setOptional(Re, r, "batchingIdTexture"), B.setValue(Re, "batchingIdTexture", r._indirectTexture, ne), B.setOptional(Re, r, "batchingColorTexture"), null !== r._colorsTexture && B.setValue(Re, "batchingColorTexture", r._colorsTexture, ne)); const R = i.morphAttributes; void 0 === R.position && void 0 === R.normal && void 0 === R.color || Ie.update(r, i, y); (w || _.receiveShadow !== r.receiveShadow) && (_.receiveShadow = r.receiveShadow, B.setValue(Re, "receiveShadow", r.receiveShadow)); n.isMeshGouraudMaterial && null !== n.envMap && (T.envMap.value = l, T.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1); n.isMeshStandardMaterial && null === n.envMap && null !== t.environment && (T.envMapIntensity.value = t.environmentIntensity); w && (B.setValue(Re, "toneMappingExposure", v.toneMappingExposure), _.needsLights && (P = M, (D = T).ambientLightColor.needsUpdate = P, D.lightProbe.needsUpdate = P, D.directionalLights.needsUpdate = P, D.directionalLightShadows.needsUpdate = P, D.pointLights.needsUpdate = P, D.pointLightShadows.needsUpdate = P, D.spotLights.needsUpdate = P, D.spotLightShadows.needsUpdate = P, D.rectAreaLights.needsUpdate = P, D.hemisphereLights.needsUpdate = P), a && !0 === n.fog && ge.refreshFogUniforms(T, a), ge.refreshMaterialUniforms(T, n, U, L, m.state.transmissionRenderTarget[e.id]), rc.upload(Re, Ke(_), T, ne)); var D, P; n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (rc.upload(Re, Ke(_), T, ne), n.uniformsNeedUpdate = !1); n.isSpriteMaterial && B.setValue(Re, "center", r.center); if (B.setValue(Re, "modelViewMatrix", r.modelViewMatrix), B.setValue(Re, "normalMatrix", r.normalMatrix), B.setValue(Re, "modelMatrix", r.matrixWorld), n.isShaderMaterial || n.isRawShaderMaterial) { const e = n.uniformsGroups; for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; Te.update(i, y), Te.bind(i, y) } } return y }(e, t, i, n, r); Z.setMaterial(n, s); let l = i.index, c = 1; if (!0 === n.wireframe) { if (l = Ae.getWireframeAttribute(i), void 0 === l) return; c = 2 } const h = i.drawRange, d = i.attributes.position; let u = h.start * c, A = (h.start + h.count) * c; null !== a && (u = Math.max(u, a.start * c), A = Math.min(A, (a.start + a.count) * c)), null !== l ? (u = Math.max(u, 0), A = Math.min(A, l.count)) : null != d && (u = Math.max(u, 0), A = Math.min(A, d.count)); const p = A - u; if (p < 0 || p === 1 / 0) return; let f; Be.setup(r, n, o, i, l); let g = Se; if (null !== l && (f = le.get(l), g = we, g.setIndex(f)), r.isMesh) !0 === n.wireframe ? (Z.setLineWidth(n.wireframeLinewidth * Y()), g.setMode(Re.LINES)) : g.setMode(Re.TRIANGLES); else if (r.isLine) { let e = n.linewidth; void 0 === e && (e = 1), Z.setLineWidth(e * Y()), r.isLineSegments ? g.setMode(Re.LINES) : r.isLineLoop ? g.setMode(Re.LINE_LOOP) : g.setMode(Re.LINE_STRIP) } else r.isPoints ? g.setMode(Re.POINTS) : r.isSprite && g.setMode(Re.TRIANGLES); if (r.isBatchedMesh) if (null !== r._multiDrawInstances) zt("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances); else if (K.get("WEBGL_multi_draw")) g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount); else { const e = r._multiDrawStarts, t = r._multiDrawCounts, i = r._multiDrawCount, a = l ? le.get(l).bytesPerElement : 1, s = ee.get(n).currentProgram.getUniforms(); for (let n = 0; n < i; n++)s.setValue(Re, "_gl_DrawID", n), g.render(e[n] / a, t[n]) } else if (r.isInstancedMesh) g.renderInstances(u, p, r.count); else if (i.isInstancedBufferGeometry) { const e = void 0 !== i._maxInstanceCount ? i._maxInstanceCount : 1 / 0, t = Math.min(i.instanceCount, e); g.renderInstances(u, p, t) } else g.render(u, p) }, this.compile = function (e, t, i = null) { null === i && (i = e), m = be.get(i), m.init(t), b.push(m), i.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), e !== i && e.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), m.setupLights(); const n = new Set; return e.traverse((function (e) { if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return; const t = e.material; if (t) if (Array.isArray(t)) for (let r = 0; r < t.length; r++) { const a = t[r]; ke(a, i, e), n.add(a) } else ke(t, i, e), n.add(t) })), m = b.pop(), n }, this.compileAsync = function (e, t, i = null) { const n = this.compile(e, t, i); return new Promise((t => { function i() { n.forEach((function (e) { ee.get(e).currentProgram.isReady() && n.delete(e) })), 0 !== n.size ? setTimeout(i, 10) : t(e) } null !== K.get("KHR_parallel_shader_compile") ? i() : setTimeout(i, 10) })) }; let Oe = null; function Ge() { ze.stop() } function He() { ze.start() } const ze = new fo; function Ve(e, t, i, n) { if (!1 === e.visible) return; if (e.layers.test(t.layers)) if (e.isGroup) i = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) m.pushLight(e), e.castShadow && m.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || O.intersectsSprite(e)) { n && j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V); const t = pe.update(e), r = e.material; r.visible && g.push(e, t, r, i, j.z, null) } } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || O.intersectsObject(e))) { const t = pe.update(e), r = e.material; if (n && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), j.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), j.copy(t.boundingSphere.center)), j.applyMatrix4(e.matrixWorld).applyMatrix4(V)), Array.isArray(r)) { const n = t.groups; for (let a = 0, s = n.length; a < s; a++) { const s = n[a], o = r[s.materialIndex]; o && o.visible && g.push(e, t, o, i, j.z, s) } } else r.visible && g.push(e, t, r, i, j.z, null) } const r = e.children; for (let e = 0, a = r.length; e < a; e++)Ve(r[e], t, i, n) } function We(e, t, i, n) { const r = e.opaque, a = e.transmissive, s = e.transparent; m.setupLightsView(i), !0 === G && ye.setGlobalState(v.clippingPlanes, i), n && Z.viewport(w.copy(n)), r.length > 0 && qe(r, t, i), a.length > 0 && qe(a, t, i), s.length > 0 && qe(s, t, i), Z.buffers.depth.setTest(!0), Z.buffers.depth.setMask(!0), Z.buffers.color.setMask(!0), Z.setPolygonOffset(!1) } function je(e, t, i, n) { if (null !== (!0 === i.isScene ? i.overrideMaterial : null)) return; void 0 === m.state.transmissionRenderTarget[n.id] && (m.state.transmissionRenderTarget[n.id] = new ai(1, 1, { generateMipmaps: !0, type: K.has("EXT_color_buffer_half_float") || K.has("EXT_color_buffer_float") ? ce : ie, minFilter: te, samples: 4, stencilBuffer: a, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: qt.workingColorSpace })); const r = m.state.transmissionRenderTarget[n.id], s = n.viewport || w; r.setSize(s.z * v.transmissionResolutionScale, s.w * v.transmissionResolutionScale); const o = v.getRenderTarget(); v.setRenderTarget(r), v.getClearColor(T), R = v.getClearAlpha(), R < 1 && v.setClearColor(16777215, .5), v.clear(), X && Ce.render(i); const l = v.toneMapping; v.toneMapping = 0; const c = n.viewport; if (void 0 !== n.viewport && (n.viewport = void 0), m.setupLightsView(n), !0 === G && ye.setGlobalState(v.clippingPlanes, n), qe(e, i, n), ne.updateMultisampleRenderTarget(r), ne.updateRenderTargetMipmap(r), !1 === K.has("WEBGL_multisampled_render_to_texture")) { let e = !1; for (let r = 0, a = t.length; r < a; r++) { const a = t[r], s = a.object, o = a.geometry, l = a.material, c = a.group; if (2 === l.side && s.layers.test(n.layers)) { const t = l.side; l.side = 1, l.needsUpdate = !0, Xe(s, i, n, o, l, c), l.side = t, l.needsUpdate = !0, e = !0 } } !0 === e && (ne.updateMultisampleRenderTarget(r), ne.updateRenderTargetMipmap(r)) } v.setRenderTarget(o), v.setClearColor(T, R), void 0 !== c && (n.viewport = c), v.toneMapping = l } function qe(e, t, i) { const n = !0 === t.isScene ? t.overrideMaterial : null; for (let r = 0, a = e.length; r < a; r++) { const a = e[r], s = a.object, o = a.geometry, l = a.group; let c = a.material; !0 === c.allowOverride && null !== n && (c = n), s.layers.test(i.layers) && Xe(s, t, i, o, c, l) } } function Xe(e, t, i, n, r, a) { e.onBeforeRender(v, t, i, n, r, a), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(v, t, i, n, e, a), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, v.renderBufferDirect(i, t, n, r, e, a), r.side = 0, r.needsUpdate = !0, v.renderBufferDirect(i, t, n, r, e, a), r.side = 2) : v.renderBufferDirect(i, t, n, r, e, a), e.onAfterRender(v, t, i, n, r, a) } function Ye(e, t, i) { !0 !== t.isScene && (t = q); const n = ee.get(e), r = m.state.lights, a = m.state.shadowsArray, s = r.state.version, o = fe.getParameters(e, r.state, a, t, i), l = fe.getProgramCacheKey(o); let c = n.programs; n.environment = e.isMeshStandardMaterial ? t.environment : null, n.fog = t.fog, n.envMap = (e.isMeshStandardMaterial ? se : re).get(e.envMap || n.environment), n.envMapRotation = null !== n.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === c && (e.addEventListener("dispose", Ne), c = new Map, n.programs = c); let h = c.get(l); if (void 0 !== h) { if (n.currentProgram === h && n.lightsStateVersion === s) return Je(e, o), h } else o.uniforms = fe.getUniforms(e), e.onBeforeCompile(o, v), h = fe.acquireProgram(o, l), c.set(l, h), n.uniforms = o.uniforms; const d = n.uniforms; return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = ye.uniform), Je(e, o), n.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), n.lightsStateVersion = s, n.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.ltc_1.value = r.state.rectAreaLTC1, d.ltc_2.value = r.state.rectAreaLTC2, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotLightMatrix.value = r.state.spotLightMatrix, d.spotLightMap.value = r.state.spotLightMap, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix), n.currentProgram = h, n.uniformsList = null, h } function Ke(e) { if (null === e.uniformsList) { const t = e.currentProgram.getUniforms(); e.uniformsList = rc.seqWithValue(t.seq, e.uniforms) } return e.uniformsList } function Je(e, t) { const i = ee.get(e); i.outputColorSpace = t.outputColorSpace, i.batching = t.batching, i.batchingColor = t.batchingColor, i.instancing = t.instancing, i.instancingColor = t.instancingColor, i.instancingMorph = t.instancingMorph, i.skinning = t.skinning, i.morphTargets = t.morphTargets, i.morphNormals = t.morphNormals, i.morphColors = t.morphColors, i.morphTargetsCount = t.morphTargetsCount, i.numClippingPlanes = t.numClippingPlanes, i.numIntersection = t.numClipIntersection, i.vertexAlphas = t.vertexAlphas, i.vertexTangents = t.vertexTangents, i.toneMapping = t.toneMapping } ze.setAnimationLoop((function (e) { Oe && Oe(e) })), "undefined" != typeof self && ze.setContext(self), this.setAnimationLoop = function (e) { Oe = e, Ue.setAnimationLoop(e), null === e ? ze.stop() : ze.start() }, Ue.addEventListener("sessionstart", Ge), Ue.addEventListener("sessionend", He), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) return; if (!0 === E) return; if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === Ue.enabled && !0 === Ue.isPresenting && (!0 === Ue.cameraAutoUpdate && Ue.updateCamera(t), t = Ue.getCamera()), !0 === e.isScene && e.onBeforeRender(v, e, t, C), m = be.get(e, b.length), m.init(t), b.push(m), V.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), O.setFromProjectionMatrix(V), H = this.localClippingEnabled, G = ye.init(this.clippingPlanes, H), g = me.get(e, _.length), g.init(), _.push(g), !0 === Ue.enabled && !0 === Ue.isPresenting) { const e = v.xr.getDepthSensingMesh(); null !== e && Ve(e, t, -1 / 0, v.sortObjects) } Ve(e, t, 0, v.sortObjects), g.finish(), !0 === v.sortObjects && g.sort(P, Q), X = !1 === Ue.enabled || !1 === Ue.isPresenting || !1 === Ue.hasDepthSensing(), X && Ce.addToRenderList(g, e), this.info.render.frame++, !0 === G && ye.beginShadows(); const i = m.state.shadowsArray; xe.render(i, e, t), !0 === G && ye.endShadows(), !0 === this.info.autoReset && this.info.reset(); const n = g.opaque, r = g.transmissive; if (m.setupLights(), t.isArrayCamera) { const i = t.cameras; if (r.length > 0) for (let t = 0, a = i.length; t < a; t++) { je(n, r, e, i[t]) } X && Ce.render(e); for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; We(g, e, n, n.viewport) } } else r.length > 0 && je(n, r, e, t), X && Ce.render(e), We(g, e, t); null !== C && 0 === x && (ne.updateMultisampleRenderTarget(C), ne.updateRenderTargetMipmap(C)), !0 === e.isScene && e.onAfterRender(v, e, t), Be.resetDefaultState(), I = -1, S = null, b.pop(), b.length > 0 ? (m = b[b.length - 1], !0 === G && ye.setGlobalState(v.clippingPlanes, m.state.camera)) : m = null, _.pop(), g = _.length > 0 ? _[_.length - 1] : null }, this.getActiveCubeFace = function () { return y }, this.getActiveMipmapLevel = function () { return x }, this.getRenderTarget = function () { return C }, this.setRenderTargetTextures = function (e, t, i) { const n = ee.get(e); n.__autoAllocateDepthBuffer = !1 === e.resolveDepthBuffer, !1 === n.__autoAllocateDepthBuffer && (n.__useRenderToTexture = !1), ee.get(e.texture).__webglTexture = t, ee.get(e.depthTexture).__webglTexture = n.__autoAllocateDepthBuffer ? void 0 : i, n.__hasExternalTextures = !0 }, this.setRenderTargetFramebuffer = function (e, t) { const i = ee.get(e); i.__webglFramebuffer = t, i.__useDefaultFramebuffer = void 0 === t }; const Ze = Re.createFramebuffer(); this.setRenderTarget = function (e, t = 0, i = 0) { C = e, y = t, x = i; let n = !0, r = null, a = !1, s = !1; if (e) { const o = ee.get(e); if (void 0 !== o.__useDefaultFramebuffer) Z.bindFramebuffer(Re.FRAMEBUFFER, null), n = !1; else if (void 0 === o.__webglFramebuffer) ne.setupRenderTarget(e); else if (o.__hasExternalTextures) ne.rebindTextures(e, ee.get(e.texture).__webglTexture, ee.get(e.depthTexture).__webglTexture); else if (e.depthBuffer) { const t = e.depthTexture; if (o.__boundDepthTexture !== t) { if (null !== t && ee.has(t) && (e.width !== t.image.width || e.height !== t.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."); ne.setupDepthRenderbuffer(e) } } const l = e.texture; (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0); const c = ee.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][i] : c[t], a = !0) : r = e.samples > 0 && !1 === ne.useMultisampledRTT(e) ? ee.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[i] : c, w.copy(e.viewport), M.copy(e.scissor), B = e.scissorTest } else w.copy(F).multiplyScalar(U).floor(), M.copy(N).multiplyScalar(U).floor(), B = k; 0 !== i && (r = Ze); if (Z.bindFramebuffer(Re.FRAMEBUFFER, r) && n && Z.drawBuffers(e, r), Z.viewport(w), Z.scissor(M), Z.setScissorTest(B), a) { const n = ee.get(e.texture); Re.framebufferTexture2D(Re.FRAMEBUFFER, Re.COLOR_ATTACHMENT0, Re.TEXTURE_CUBE_MAP_POSITIVE_X + t, n.__webglTexture, i) } else if (s) { const n = ee.get(e.texture), r = t; Re.framebufferTextureLayer(Re.FRAMEBUFFER, Re.COLOR_ATTACHMENT0, n.__webglTexture, i, r) } else if (null !== e && 0 !== i) { const t = ee.get(e.texture); Re.framebufferTexture2D(Re.FRAMEBUFFER, Re.COLOR_ATTACHMENT0, Re.TEXTURE_2D, t.__webglTexture, i) } I = -1 }, this.readRenderTargetPixels = function (e, t, i, n, r, a, s) { if (!e || !e.isWebGLRenderTarget) return; let o = ee.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) { Z.bindFramebuffer(Re.FRAMEBUFFER, o); try { const s = e.texture, o = s.format, l = s.type; if (!J.textureFormatReadable(o)) return; if (!J.textureTypeReadable(l)) return; t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && Re.readPixels(t, i, n, r, Me.convert(o), Me.convert(l), a) } finally { const e = null !== C ? ee.get(C).__webglFramebuffer : null; Z.bindFramebuffer(Re.FRAMEBUFFER, e) } } }, this.readRenderTargetPixelsAsync = async function (e, t, i, n, r, a, s) { if (!e || !e.isWebGLRenderTarget) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let o = ee.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) { if (t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r) { Z.bindFramebuffer(Re.FRAMEBUFFER, o); const s = e.texture, l = s.format, c = s.type; if (!J.textureFormatReadable(l)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."); if (!J.textureTypeReadable(c)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."); const h = Re.createBuffer(); Re.bindBuffer(Re.PIXEL_PACK_BUFFER, h), Re.bufferData(Re.PIXEL_PACK_BUFFER, a.byteLength, Re.STREAM_READ), Re.readPixels(t, i, n, r, Me.convert(l), Me.convert(c), 0); const d = null !== C ? ee.get(C).__webglFramebuffer : null; Z.bindFramebuffer(Re.FRAMEBUFFER, d); const u = Re.fenceSync(Re.SYNC_GPU_COMMANDS_COMPLETE, 0); return Re.flush(), await function (e, t, i) { return new Promise((function (n, r) { setTimeout((function a() { switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) { case e.WAIT_FAILED: r(); break; case e.TIMEOUT_EXPIRED: setTimeout(a, i); break; default: n() } }), i) })) }(Re, u, 4), Re.bindBuffer(Re.PIXEL_PACK_BUFFER, h), Re.getBufferSubData(Re.PIXEL_PACK_BUFFER, 0, a), Re.deleteBuffer(h), Re.deleteSync(u), a } throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.") } }, this.copyFramebufferToTexture = function (e, t = null, i = 0) { const n = Math.pow(2, -i), r = Math.floor(e.image.width * n), a = Math.floor(e.image.height * n), s = null !== t ? t.x : 0, o = null !== t ? t.y : 0; ne.setTexture2D(e, 0), Re.copyTexSubImage2D(Re.TEXTURE_2D, i, 0, 0, s, o, r, a), Z.unbindTexture() }; const $e = Re.createFramebuffer(), et = Re.createFramebuffer(); this.copyTextureToTexture = function (e, t, i = null, n = null, r = 0, a = null) { let s, o, l, c, h, d, u, A, p; null === a && (0 !== r ? (zt("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), a = r, r = 0) : a = 0); const f = e.isCompressedTexture ? e.mipmaps[a] : e.image; if (null !== i) s = i.max.x - i.min.x, o = i.max.y - i.min.y, l = i.isBox3 ? i.max.z - i.min.z : 1, c = i.min.x, h = i.min.y, d = i.isBox3 ? i.min.z : 0; else { const t = Math.pow(2, -r); s = Math.floor(f.width * t), o = Math.floor(f.height * t), l = e.isDataArrayTexture ? f.depth : e.isData3DTexture ? Math.floor(f.depth * t) : 1, c = 0, h = 0, d = 0 } null !== n ? (u = n.x, A = n.y, p = n.z) : (u = 0, A = 0, p = 0); const g = Me.convert(t.format), m = Me.convert(t.type); let _; t.isData3DTexture ? (ne.setTexture3D(t, 0), _ = Re.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (ne.setTexture2DArray(t, 0), _ = Re.TEXTURE_2D_ARRAY) : (ne.setTexture2D(t, 0), _ = Re.TEXTURE_2D), Re.pixelStorei(Re.UNPACK_FLIP_Y_WEBGL, t.flipY), Re.pixelStorei(Re.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), Re.pixelStorei(Re.UNPACK_ALIGNMENT, t.unpackAlignment); const b = Re.getParameter(Re.UNPACK_ROW_LENGTH), v = Re.getParameter(Re.UNPACK_IMAGE_HEIGHT), E = Re.getParameter(Re.UNPACK_SKIP_PIXELS), y = Re.getParameter(Re.UNPACK_SKIP_ROWS), x = Re.getParameter(Re.UNPACK_SKIP_IMAGES); Re.pixelStorei(Re.UNPACK_ROW_LENGTH, f.width), Re.pixelStorei(Re.UNPACK_IMAGE_HEIGHT, f.height), Re.pixelStorei(Re.UNPACK_SKIP_PIXELS, c), Re.pixelStorei(Re.UNPACK_SKIP_ROWS, h), Re.pixelStorei(Re.UNPACK_SKIP_IMAGES, d); const C = e.isDataArrayTexture || e.isData3DTexture, I = t.isDataArrayTexture || t.isData3DTexture; if (e.isDepthTexture) { const i = ee.get(e), n = ee.get(t), f = ee.get(i.__renderTarget), g = ee.get(n.__renderTarget); Z.bindFramebuffer(Re.READ_FRAMEBUFFER, f.__webglFramebuffer), Z.bindFramebuffer(Re.DRAW_FRAMEBUFFER, g.__webglFramebuffer); for (let i = 0; i < l; i++)C && (Re.framebufferTextureLayer(Re.READ_FRAMEBUFFER, Re.COLOR_ATTACHMENT0, ee.get(e).__webglTexture, r, d + i), Re.framebufferTextureLayer(Re.DRAW_FRAMEBUFFER, Re.COLOR_ATTACHMENT0, ee.get(t).__webglTexture, a, p + i)), Re.blitFramebuffer(c, h, s, o, u, A, s, o, Re.DEPTH_BUFFER_BIT, Re.NEAREST); Z.bindFramebuffer(Re.READ_FRAMEBUFFER, null), Z.bindFramebuffer(Re.DRAW_FRAMEBUFFER, null) } else if (0 !== r || e.isRenderTargetTexture || ee.has(e)) { const i = ee.get(e), n = ee.get(t); Z.bindFramebuffer(Re.READ_FRAMEBUFFER, $e), Z.bindFramebuffer(Re.DRAW_FRAMEBUFFER, et); for (let e = 0; e < l; e++)C ? Re.framebufferTextureLayer(Re.READ_FRAMEBUFFER, Re.COLOR_ATTACHMENT0, i.__webglTexture, r, d + e) : Re.framebufferTexture2D(Re.READ_FRAMEBUFFER, Re.COLOR_ATTACHMENT0, Re.TEXTURE_2D, i.__webglTexture, r), I ? Re.framebufferTextureLayer(Re.DRAW_FRAMEBUFFER, Re.COLOR_ATTACHMENT0, n.__webglTexture, a, p + e) : Re.framebufferTexture2D(Re.DRAW_FRAMEBUFFER, Re.COLOR_ATTACHMENT0, Re.TEXTURE_2D, n.__webglTexture, a), 0 !== r ? Re.blitFramebuffer(c, h, s, o, u, A, s, o, Re.COLOR_BUFFER_BIT, Re.NEAREST) : I ? Re.copyTexSubImage3D(_, a, u, A, p + e, c, h, s, o) : Re.copyTexSubImage2D(_, a, u, A, c, h, s, o); Z.bindFramebuffer(Re.READ_FRAMEBUFFER, null), Z.bindFramebuffer(Re.DRAW_FRAMEBUFFER, null) } else I ? e.isDataTexture || e.isData3DTexture ? Re.texSubImage3D(_, a, u, A, p, s, o, l, g, m, f.data) : t.isCompressedArrayTexture ? Re.compressedTexSubImage3D(_, a, u, A, p, s, o, l, g, f.data) : Re.texSubImage3D(_, a, u, A, p, s, o, l, g, m, f) : e.isDataTexture ? Re.texSubImage2D(Re.TEXTURE_2D, a, u, A, s, o, g, m, f.data) : e.isCompressedTexture ? Re.compressedTexSubImage2D(Re.TEXTURE_2D, a, u, A, f.width, f.height, g, f.data) : Re.texSubImage2D(Re.TEXTURE_2D, a, u, A, s, o, g, m, f); Re.pixelStorei(Re.UNPACK_ROW_LENGTH, b), Re.pixelStorei(Re.UNPACK_IMAGE_HEIGHT, v), Re.pixelStorei(Re.UNPACK_SKIP_PIXELS, E), Re.pixelStorei(Re.UNPACK_SKIP_ROWS, y), Re.pixelStorei(Re.UNPACK_SKIP_IMAGES, x), 0 === a && t.generateMipmaps && Re.generateMipmap(_), Z.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, i = null, n = null, r = 0) { return zt('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(e, t, i, n, r) }, this.initRenderTarget = function (e) { void 0 === ee.get(e).__webglFramebuffer && ne.setupRenderTarget(e) }, this.initTexture = function (e) { e.isCubeTexture ? ne.setTextureCube(e, 0) : e.isData3DTexture ? ne.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? ne.setTexture2DArray(e, 0) : ne.setTexture2D(e, 0), Z.unbindTexture() }, this.resetState = function () { y = 0, x = 0, C = null, Z.reset(), Be.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return yt } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; const t = this.getContext(); t.drawingBufferColorSpace = qt._getDrawingBufferColorSpace(e), t.unpackColorSpace = qt._getUnpackColorSpace() } } var Zc = function () { var e = 0, t = document.createElement("div"); function i(e) { return t.appendChild(e.dom), e } function n(i) { for (var n = 0; n < t.children.length; n++)t.children[n].style.display = n === i ? "block" : "none"; e = i } t.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", t.addEventListener("click", (function (i) { i.preventDefault(), n(++e % t.children.length) }), !1); var r = (performance || Date).now(), a = r, s = 0, o = i(new Zc.Panel("FPS", "#0ff", "#002")), l = i(new Zc.Panel("MS", "#0f0", "#020")); if (self.performance && self.performance.memory) var c = i(new Zc.Panel("MB", "#f08", "#201")); return n(0), { REVISION: 16, dom: t, addPanel: i, showPanel: n, begin: function () { r = (performance || Date).now() }, end: function () { s++; var e = (performance || Date).now(); if (l.update(e - r, 200), e >= a + 1e3 && (o.update(1e3 * s / (e - a), 100), a = e, s = 0, c)) { var t = performance.memory; c.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576) } return e }, update: function () { r = this.end() }, domElement: t, setMode: n } }; Zc.Panel = function (e, t, i) { var n = 1 / 0, r = 0, a = Math.round, s = a(window.devicePixelRatio || 1), o = 80 * s, l = 48 * s, c = 3 * s, h = 2 * s, d = 3 * s, u = 15 * s, A = 74 * s, p = 30 * s, f = document.createElement("canvas"); f.width = o, f.height = l, f.style.cssText = "width:80px;height:48px"; var g = f.getContext("2d"); return g.font = "bold " + 9 * s + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = i, g.fillRect(0, 0, o, l), g.fillStyle = t, g.fillText(e, c, h), g.fillRect(d, u, A, p), g.fillStyle = i, g.globalAlpha = .9, g.fillRect(d, u, A, p), { dom: f, update: function (l, m) { n = Math.min(n, l), r = Math.max(r, l), g.fillStyle = i, g.globalAlpha = 1, g.fillRect(0, 0, o, u), g.fillStyle = t, g.fillText(a(l) + " " + e + " (" + a(n) + "-" + a(r) + ")", c, h), g.drawImage(f, d + s, u, A - s, p, d, u, A - s, p), g.fillRect(d + A - s, u, s, p), g.fillStyle = i, g.globalAlpha = .9, g.fillRect(d + A - s, u, s, a((1 - l / m) * p)) } } }; const $c = Zc; function eh(e, t) { if (0 === t) return e; if (2 === t || 1 === t) { let i = e.getIndex(); if (null === i) { const t = [], n = e.getAttribute("position"); if (void 0 === n) return e; for (let e = 0; e < n.count; e++)t.push(e); e.setIndex(t), i = e.getIndex() } const n = i.count - 2, r = []; if (2 === t) for (let e = 1; e <= n; e++)r.push(i.getX(0)), r.push(i.getX(e)), r.push(i.getX(e + 1)); else for (let e = 0; e < n; e++)e % 2 == 0 ? (r.push(i.getX(e)), r.push(i.getX(e + 1)), r.push(i.getX(e + 2))) : (r.push(i.getX(e + 2)), r.push(i.getX(e + 1)), r.push(i.getX(e))); r.length; const a = e.clone(); return a.setIndex(r), a.clearGroups(), a } return e } class th extends gs { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new oh(e) })), this.register((function (e) { return new lh(e) })), this.register((function (e) { return new mh(e) })), this.register((function (e) { return new _h(e) })), this.register((function (e) { return new bh(e) })), this.register((function (e) { return new hh(e) })), this.register((function (e) { return new dh(e) })), this.register((function (e) { return new uh(e) })), this.register((function (e) { return new Ah(e) })), this.register((function (e) { return new sh(e) })), this.register((function (e) { return new ph(e) })), this.register((function (e) { return new ch(e) })), this.register((function (e) { return new gh(e) })), this.register((function (e) { return new fh(e) })), this.register((function (e) { return new rh(e) })), this.register((function (e) { return new vh(e) })), this.register((function (e) { return new Eh(e) })) } load(e, t, i, n) { const r = this; let a; if ("" !== this.resourcePath) a = this.resourcePath; else if ("" !== this.path) { const t = Os.extractUrlBase(e); a = Os.resolveURL(t, this.path) } else a = Os.extractUrlBase(e); this.manager.itemStart(e); const s = function (t) { n && n(t), r.manager.itemError(e), r.manager.itemEnd(e) }, o = new bs(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (i) { try { r.parse(i, a, (function (i) { t(i), r.manager.itemEnd(e) }), s) } catch (e) { s(e) } }), i, s) } setDRACOLoader(e) { return this.dracoLoader = e, this } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, i, n) { let r; const a = {}, s = {}, o = new TextDecoder; if ("string" == typeof e) r = JSON.parse(e); else if (e instanceof ArrayBuffer) { if (o.decode(new Uint8Array(e, 0, 4)) === yh) { try { a[nh.KHR_BINARY_GLTF] = new Ih(e) } catch (e) { return void (n && n(e)) } r = JSON.parse(a[nh.KHR_BINARY_GLTF].content) } else r = JSON.parse(o.decode(e)) } else r = e; if (void 0 === r.asset || r.asset.version[0] < 2) return void (n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const l = new Kh(r, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](l); t.name, s[t.name] = t, a[t.name] = !0 } if (r.extensionsUsed) for (let e = 0; e < r.extensionsUsed.length; ++e) { const t = r.extensionsUsed[e], i = r.extensionsRequired || []; switch (t) { case nh.KHR_MATERIALS_UNLIT: a[t] = new ah; break; case nh.KHR_DRACO_MESH_COMPRESSION: a[t] = new Sh(r, this.dracoLoader); break; case nh.KHR_TEXTURE_TRANSFORM: a[t] = new wh; break; case nh.KHR_MESH_QUANTIZATION: a[t] = new Mh; break; default: i.indexOf(t) >= 0 && s[t] } } l.setExtensions(a), l.setPlugins(s), l.parse(i, n) } parseAsync(e, t) { const i = this; return new Promise((function (n, r) { i.parse(e, t, n, r) })) } } function ih() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, i) { e[t] = i }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const nh = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_MATERIALS_BUMP: "EXT_materials_bump", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class rh { constructor(e) { this.parser = e, this.name = nh.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let i = 0, n = t.length; i < n; i++) { const n = t[i]; n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, i = "light:" + e; let n = t.cache.get(i); if (n) return n; const r = t.json, a = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e]; let s; const o = new Dn(16777215); void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], lt); const l = void 0 !== a.range ? a.range : 0; switch (a.type) { case "directional": s = new Ns(o), s.target.position.set(0, 0, -1), s.add(s.target); break; case "point": s = new Ps(o), s.distance = l; break; case "spot": s = new Ts(o), s.distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, s.angle = a.spot.outerConeAngle, s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, s.target.position.set(0, 0, -1), s.add(s.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type) }return s.position.set(0, 0, 0), Vh(s, a), void 0 !== a.intensity && (s.intensity = a.intensity), s.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(s), t.cache.add(i, n), n } getDependency(e, t) { if ("light" === e) return this._loadLight(t) } createNodeAttachment(e) { const t = this, i = this.parser, n = i.json.nodes[e], r = (n.extensions && n.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then((function (e) { return i._getNodeRef(t.cache, r, e) })) } } class ah { constructor() { this.name = nh.KHR_MATERIALS_UNLIT } getMaterialType() { return Qn } extendParams(e, t, i) { const n = []; e.color = new Dn(1, 1, 1), e.opacity = 1; const r = t.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const t = r.baseColorFactor; e.color.setRGB(t[0], t[1], t[2], lt), e.opacity = t[3] } void 0 !== r.baseColorTexture && n.push(i.assignTexture(e, "map", r.baseColorTexture, ot)) } return Promise.all(n) } } class sh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const n = i.extensions[this.name].emissiveStrength; return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve() } } class oh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && r.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && r.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (r.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { const e = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Qt(e, e) } return Promise.all(r) } } class lh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_DISPERSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const n = i.extensions[this.name]; return t.dispersion = void 0 !== n.dispersion ? n.dispersion : 0, Promise.resolve() } } class ch { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor), void 0 !== a.iridescenceTexture && r.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), void 0 !== a.iridescenceThicknessTexture && r.push(i.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r) } } class hh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = []; t.sheenColor = new Dn(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const a = n.extensions[this.name]; if (void 0 !== a.sheenColorFactor) { const e = a.sheenColorFactor; t.sheenColor.setRGB(e[0], e[1], e[2], lt) } return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && r.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, ot)), void 0 !== a.sheenRoughnessTexture && r.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r) } } class dh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && r.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r) } } class uh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_VOLUME } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && r.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0; const s = a.attenuationColor || [1, 1, 1]; return t.attenuationColor = (new Dn).setRGB(s[0], s[1], s[2], lt), Promise.all(r) } } class Ah { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const n = i.extensions[this.name]; return t.ior = void 0 !== n.ior ? n.ior : 1.5, Promise.resolve() } } class ph { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && r.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture)); const s = a.specularColorFactor || [1, 1, 1]; return t.specularColor = (new Dn).setRGB(s[0], s[1], s[2], lt), void 0 !== a.specularColorTexture && r.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture, ot)), Promise.all(r) } } class fh { constructor(e) { this.parser = e, this.name = nh.EXT_MATERIALS_BUMP } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1, void 0 !== a.bumpTexture && r.push(i.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r) } } class gh { constructor(e) { this.parser = e, this.name = nh.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Wa : null } extendMaterialParams(e, t) { const i = this.parser, n = i.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const r = [], a = n.extensions[this.name]; return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength), void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation), void 0 !== a.anisotropyTexture && r.push(i.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r) } } class mh { constructor(e) { this.parser = e, this.name = nh.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, i = t.json, n = i.textures[e]; if (!n.extensions || !n.extensions[this.name]) return null; const r = n.extensions[this.name], a = t.options.ktx2Loader; if (!a) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, r.source, a) } } class _h { constructor(e) { this.parser = e, this.name = nh.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, i = this.parser, n = i.json, r = n.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const a = r.extensions[t], s = n.images[a.source]; let o = i.textureLoader; if (s.uri) { const e = i.options.manager.getHandler(s.uri); null !== e && (o = e) } return this.detectSupport().then((function (r) { if (r) return i.loadTextureImage(e, a.source, o); if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return i.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class bh { constructor(e) { this.parser = e, this.name = nh.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, i = this.parser, n = i.json, r = n.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const a = r.extensions[t], s = n.images[a.source]; let o = i.textureLoader; if (s.uri) { const e = i.options.manager.getHandler(s.uri); null !== e && (o = e) } return this.detectSupport().then((function (r) { if (r) return i.loadTextureImage(e, a.source, o); if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return i.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class vh { constructor(e) { this.name = nh.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, i = t.bufferViews[e]; if (i.extensions && i.extensions[this.name]) { const e = i.extensions[this.name], n = this.parser.getDependency("buffer", e.buffer), r = this.parser.options.meshoptDecoder; if (!r || !r.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return n.then((function (t) { const i = e.byteOffset || 0, n = e.byteLength || 0, a = e.count, s = e.byteStride, o = new Uint8Array(t, i, n); return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(a, s, o, e.mode, e.filter).then((function (e) { return e.buffer })) : r.ready.then((function () { const t = new ArrayBuffer(a * s); return r.decodeGltfBuffer(new Uint8Array(t), a, s, o, e.mode, e.filter), t })) })) } return null } } class Eh { constructor(e) { this.name = nh.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, i = t.nodes[e]; if (!i.extensions || !i.extensions[this.name] || void 0 === i.mesh) return null; const n = t.meshes[i.mesh]; for (const e of n.primitives) if (e.mode !== Dh.TRIANGLES && e.mode !== Dh.TRIANGLE_STRIP && e.mode !== Dh.TRIANGLE_FAN && void 0 !== e.mode) return null; const r = i.extensions[this.name].attributes, a = [], s = {}; for (const e in r) a.push(this.parser.getDependency("accessor", r[e]).then((t => (s[e] = t, s[e])))); return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((e => { const t = e.pop(), i = t.isGroup ? t.children : [t], n = e[0].count, r = []; for (const e of i) { const t = new ki, i = new ci, a = new li, o = new ci(1, 1, 1), l = new oa(e.geometry, e.material, n); for (let e = 0; e < n; e++)s.TRANSLATION && i.fromBufferAttribute(s.TRANSLATION, e), s.ROTATION && a.fromBufferAttribute(s.ROTATION, e), s.SCALE && o.fromBufferAttribute(s.SCALE, e), l.setMatrixAt(e, t.compose(i, a, o)); for (const t in s) if ("_COLOR_0" === t) { const e = s[t]; l.instanceColor = new $r(e.array, e.itemSize, e.normalized) } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]); An.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), r.push(l) } return t.isGroup ? (t.clear(), t.add(...r), t) : r[0] }))) } } const yh = "glTF", xh = 1313821514, Ch = 5130562; class Ih { constructor(e) { this.name = nh.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12), i = new TextDecoder; if (this.header = { magic: i.decode(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== yh) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, r = new DataView(e, 12); let a = 0; for (; a < n;) { const t = r.getUint32(a, !0); a += 4; const n = r.getUint32(a, !0); if (a += 4, n === xh) { const n = new Uint8Array(e, 12 + a, t); this.content = i.decode(n) } else if (n === Ch) { const i = 12 + a; this.body = e.slice(i, i + t) } a += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class Sh { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = nh.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const i = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, s = {}, o = {}, l = {}; for (const e in a) { const t = Fh[e] || e.toLowerCase(); s[t] = a[e] } for (const t in e.attributes) { const n = Fh[t] || t.toLowerCase(); if (void 0 !== a[t]) { const r = i.accessors[e.attributes[t]], a = Lh[r.componentType]; l[n] = a.name, o[n] = !0 === r.normalized } } return t.getDependency("bufferView", r).then((function (e) { return new Promise((function (t, i) { n.decodeDracoFile(e, (function (e) { for (const t in e.attributes) { const i = e.attributes[t], n = o[t]; void 0 !== n && (i.normalized = n) } t(e) }), s, l, lt, i) })) })) } } class wh { constructor() { this.name = nh.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e } } class Mh { constructor() { this.name = nh.KHR_MESH_QUANTIZATION } } class Bh extends $a { constructor(e, t, i, n) { super(e, t, i, n) } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n * 3 + n; for (let e = 0; e !== n; e++)t[e] = i[r + e]; return t } interpolate_(e, t, i, n) { const r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = 2 * s, l = 3 * s, c = n - t, h = (i - t) / c, d = h * h, u = d * h, A = e * l, p = A - l, f = -2 * u + 3 * d, g = u - d, m = 1 - f, _ = g - d + h; for (let e = 0; e !== s; e++) { const t = a[p + e + s], i = a[p + e + o] * c, n = a[A + e + s], l = a[A + e] * c; r[e] = m * t + _ * i + f * n + g * l } return r } } const Th = new li; class Rh extends Bh { interpolate_(e, t, i, n) { const r = super.interpolate_(e, t, i, n); return Th.fromArray(r).normalize().toArray(r), r } } const Dh = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, Lh = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Uh = { 9728: K, 9729: $, 9984: J, 9985: ee, 9986: Z, 9987: te }, Ph = { 33071: X, 33648: Y, 10497: q }, Qh = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, Fh = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, Nh = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, kh = { CUBICSPLINE: void 0, LINEAR: et, STEP: $e }, Oh = "OPAQUE", Gh = "MASK", Hh = "BLEND"; function zh(e, t, i) { for (const n in i.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = i.extensions[n]) } function Vh(e, t) { void 0 !== t.extras && "object" == typeof t.extras && Object.assign(e.userData, t.extras) } function Wh(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let i = 0, n = t.weights.length; i < n; i++)e.morphTargetInfluences[i] = t.weights[i]; if (t.extras && Array.isArray(t.extras.targetNames)) { const i = t.extras.targetNames; if (e.morphTargetInfluences.length === i.length) { e.morphTargetDictionary = {}; for (let t = 0, n = i.length; t < n; t++)e.morphTargetDictionary[i[t]] = t } } } function jh(e) { let t; const i = e.extensions && e.extensions[nh.KHR_DRACO_MESH_COMPRESSION]; if (t = i ? "draco:" + i.bufferView + ":" + i.indices + ":" + qh(i.attributes) : e.indices + ":" + qh(e.attributes) + ":" + e.mode, void 0 !== e.targets) for (let i = 0, n = e.targets.length; i < n; i++)t += ":" + qh(e.targets[i]); return t } function qh(e) { let t = ""; const i = Object.keys(e).sort(); for (let n = 0, r = i.length; n < r; n++)t += i[n] + ":" + e[i[n]] + ";"; return t } function Xh(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } const Yh = new ki; class Kh { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new ih, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let i = !1, n = -1, r = !1, a = -1; if ("undefined" != typeof navigator) { const e = navigator.userAgent; i = !0 === /^((?!chrome|android).)*safari/i.test(e); const t = e.match(/Version\/(\d+)/); n = i && t ? parseInt(t[1], 10) : -1, r = e.indexOf("Firefox") > -1, a = r ? e.match(/Firefox\/([0-9]+)\./)[1] : -1 } "undefined" == typeof createImageBitmap || i && n < 17 || r && a < 98 ? this.textureLoader = new ys(this.options.manager) : this.textureLoader = new Gs(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new bs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const i = this, n = this.json, r = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]) })).then((function (t) { const a = { scene: t[0][n.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: n.asset, parser: i, userData: {} }; return zh(r, a, n), Vh(a, n), Promise.all(i._invokeAll((function (e) { return e.afterRoot && e.afterRoot(a) }))).then((function () { for (const e of a.scenes) e.updateMatrixWorld(); e(a) })) })).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || []; for (let i = 0, n = t.length; i < n; i++) { const n = t[i].joints; for (let t = 0, i = n.length; t < i; t++)e[n[t]].isBone = !0 } for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, i) { if (e.refs[t] <= 1) return i; const n = i.clone(), r = (e, t) => { const i = this.associations.get(e); null != i && this.associations.set(t, i); for (const [i, n] of e.children.entries()) r(n, t.children[i]) }; return r(i, n), n.name += "_instance_" + e.uses[t]++, n } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let i = 0; i < t.length; i++) { const n = e(t[i]); if (n) return n } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const i = []; for (let n = 0; n < t.length; n++) { const r = e(t[n]); r && i.push(r) } return i } getDependency(e, t) { const i = e + ":" + t; let n = this.cache.get(i); if (!n) { switch (e) { case "scene": n = this.loadScene(t); break; case "node": n = this._invokeOne((function (e) { return e.loadNode && e.loadNode(t) })); break; case "mesh": n = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": n = this.loadAccessor(t); break; case "bufferView": n = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": n = this.loadBuffer(t); break; case "material": n = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": n = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": n = this.loadSkin(t); break; case "animation": n = this._invokeOne((function (e) { return e.loadAnimation && e.loadAnimation(t) })); break; case "camera": n = this.loadCamera(t); break; default: if (n = this._invokeOne((function (i) { return i != this && i.getDependency && i.getDependency(e, t) })), !n) throw new Error("Unknown type: " + e) }this.cache.add(i, n) } return n } getDependencies(e) { let t = this.cache.get(e); if (!t) { const i = this, n = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(n.map((function (t, n) { return i.getDependency(e, n) }))), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], i = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[nh.KHR_BINARY_GLTF].body); const n = this.options; return new Promise((function (e, r) { i.load(Os.resolveURL(t.uri, n.path), e, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { const i = t.byteLength || 0, n = t.byteOffset || 0; return e.slice(n, n + i) })) } loadAccessor(e) { const t = this, i = this.json, n = this.json.accessors[e]; if (void 0 === n.bufferView && void 0 === n.sparse) { const e = Qh[n.type], t = Lh[n.componentType], i = !0 === n.normalized, r = new t(n.count * e); return Promise.resolve(new Wn(r, e, i)) } const r = []; return void 0 !== n.bufferView ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), void 0 !== n.sparse && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then((function (e) { const r = e[0], a = Qh[n.type], s = Lh[n.componentType], o = s.BYTES_PER_ELEMENT, l = o * a, c = n.byteOffset || 0, h = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0, d = !0 === n.normalized; let u, A; if (h && h !== l) { const e = Math.floor(c / h), i = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + e + ":" + n.count; let l = t.cache.get(i); l || (u = new s(r, e * h, n.count * h / o), l = new Pr(u, h / o), t.cache.add(i, l)), A = new Fr(l, a, c % h / o, d) } else u = null === r ? new s(n.count * a) : new s(r, c, n.count * a), A = new Wn(u, a, d); if (void 0 !== n.sparse) { const t = Qh.SCALAR, i = Lh[n.sparse.indices.componentType], o = n.sparse.indices.byteOffset || 0, l = n.sparse.values.byteOffset || 0, c = new i(e[1], o, n.sparse.count * t), h = new s(e[2], l, n.sparse.count * a); null !== r && (A = new Wn(A.array.slice(), A.itemSize, A.normalized)), A.normalized = !1; for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (A.setX(t, h[e * a]), a >= 2 && A.setY(t, h[e * a + 1]), a >= 3 && A.setZ(t, h[e * a + 2]), a >= 4 && A.setW(t, h[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } A.normalized = d } return A })) } loadTexture(e) { const t = this.json, i = this.options, n = t.textures[e].source, r = t.images[n]; let a = this.textureLoader; if (r.uri) { const e = i.manager.getHandler(r.uri); null !== e && (a = e) } return this.loadTextureImage(e, n, a) } loadTextureImage(e, t, i) { const n = this, r = this.json, a = r.textures[e], s = r.images[t], o = (s.uri || s.bufferView) + ":" + a.sampler; if (this.textureCache[o]) return this.textureCache[o]; const l = this.loadImageSource(t, i).then((function (t) { t.flipY = !1, t.name = a.name || s.name || "", "" === t.name && "string" == typeof s.uri && !1 === s.uri.startsWith("data:image/") && (t.name = s.uri); const i = (r.samplers || {})[a.sampler] || {}; return t.magFilter = Uh[i.magFilter] || $, t.minFilter = Uh[i.minFilter] || te, t.wrapS = Ph[i.wrapS] || q, t.wrapT = Ph[i.wrapT] || q, t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== K && t.minFilter !== $, n.associations.set(t, { textures: e }), t })).catch((function () { return null })); return this.textureCache[o] = l, l } loadImageSource(e, t) { const i = this, n = this.json, r = this.options; if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone())); const a = n.images[e], s = self.URL || self.webkitURL; let o = a.uri || "", l = !1; if (void 0 !== a.bufferView) o = i.getDependency("bufferView", a.bufferView).then((function (e) { l = !0; const t = new Blob([e], { type: a.mimeType }); return o = s.createObjectURL(t), o })); else if (void 0 === a.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const c = Promise.resolve(o).then((function (e) { return new Promise((function (i, n) { let a = i; !0 === t.isImageBitmapLoader && (a = function (e) { const t = new ii(e); t.needsUpdate = !0, i(t) }), t.load(Os.resolveURL(e, r.path), a, void 0, n) })) })).then((function (e) { var t; return !0 === l && s.revokeObjectURL(o), Vh(e, a), e.userData.mimeType = a.mimeType || ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"), e })).catch((function (e) { throw e })); return this.sourceCache[e] = c, c } assignTexture(e, t, i, n) { const r = this; return this.getDependency("texture", i.index).then((function (a) { if (!a) return null; if (void 0 !== i.texCoord && i.texCoord > 0 && ((a = a.clone()).channel = i.texCoord), r.extensions[nh.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== i.extensions ? i.extensions[nh.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = r.associations.get(a); a = r.extensions[nh.KHR_TEXTURE_TRANSFORM].extendTexture(a, e), r.associations.set(a, t) } } return void 0 !== n && (a.colorSpace = n), e[t] = a, a })) } assignFinalMaterial(e) { const t = e.geometry; let i = e.material; const n = void 0 === t.attributes.tangent, r = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + i.uuid; let t = this.cache.get(e); t || (t = new Ba, Pn.prototype.copy.call(t, i), t.color.copy(i.color), t.map = i.map, t.sizeAttenuation = !1, this.cache.add(e, t)), i = t } else if (e.isLine) { const e = "LineBasicMaterial:" + i.uuid; let t = this.cache.get(e); t || (t = new fa, Pn.prototype.copy.call(t, i), t.color.copy(i.color), t.map = i.map, this.cache.add(e, t)), i = t } if (n || r || a) { let e = "ClonedMaterial:" + i.uuid + ":"; n && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), a && (e += "flat-shading:"); let t = this.cache.get(e); t || (t = i.clone(), r && (t.vertexColors = !0), a && (t.flatShading = !0), n && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(i))), i = t } e.material = i } getMaterialType() { return Va } loadMaterial(e) { const t = this, i = this.json, n = this.extensions, r = i.materials[e]; let a; const s = {}, o = []; if ((r.extensions || {})[nh.KHR_MATERIALS_UNLIT]) { const e = n[nh.KHR_MATERIALS_UNLIT]; a = e.getMaterialType(), o.push(e.extendParams(s, r, t)) } else { const i = r.pbrMetallicRoughness || {}; if (s.color = new Dn(1, 1, 1), s.opacity = 1, Array.isArray(i.baseColorFactor)) { const e = i.baseColorFactor; s.color.setRGB(e[0], e[1], e[2], lt), s.opacity = e[3] } void 0 !== i.baseColorTexture && o.push(t.assignTexture(s, "map", i.baseColorTexture, ot)), s.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1, s.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1, void 0 !== i.metallicRoughnessTexture && (o.push(t.assignTexture(s, "metalnessMap", i.metallicRoughnessTexture)), o.push(t.assignTexture(s, "roughnessMap", i.metallicRoughnessTexture))), a = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), o.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, s) })))) } !0 === r.doubleSided && (s.side = 2); const l = r.alphaMode || Oh; if (l === Hh ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, l === Gh && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && a !== Qn && (o.push(t.assignTexture(s, "normalMap", r.normalTexture)), s.normalScale = new Qt(1, 1), void 0 !== r.normalTexture.scale)) { const e = r.normalTexture.scale; s.normalScale.set(e, e) } if (void 0 !== r.occlusionTexture && a !== Qn && (o.push(t.assignTexture(s, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && a !== Qn) { const e = r.emissiveFactor; s.emissive = (new Dn).setRGB(e[0], e[1], e[2], lt) } return void 0 !== r.emissiveTexture && a !== Qn && o.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture, ot)), Promise.all(o).then((function () { const i = new a(s); return r.name && (i.name = r.name), Vh(i, r), t.associations.set(i, { materials: e }), r.extensions && zh(n, i, r), i })) } createUniqueName(e) { const t = Ks.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, i = this.extensions, n = this.primitiveCache; function r(e) { return i[nh.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (i) { return Jh(i, e, t) })) } const a = []; for (let i = 0, s = e.length; i < s; i++) { const s = e[i], o = jh(s), l = n[o]; if (l) a.push(l.promise); else { let e; e = s.extensions && s.extensions[nh.KHR_DRACO_MESH_COMPRESSION] ? r(s) : Jh(new ir, s, t), n[o] = { primitive: s, promise: e }, a.push(e) } } return Promise.all(a) } loadMesh(e) { const t = this, i = this.json, n = this.extensions, r = i.meshes[e], a = r.primitives, s = []; for (let e = 0, t = a.length; e < t; e++) { const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new Va({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 })), o.DefaultMaterial) : this.getDependency("material", a[e].material); s.push(t) } var o; return s.push(t.loadGeometries(a)), Promise.all(s).then((function (i) { const s = i.slice(0, i.length - 1), o = i[i.length - 1], l = []; for (let i = 0, c = o.length; i < c; i++) { const c = o[i], h = a[i]; let d; const u = s[i]; if (h.mode === Dh.TRIANGLES || h.mode === Dh.TRIANGLE_STRIP || h.mode === Dh.TRIANGLE_FAN || void 0 === h.mode) d = !0 === r.isSkinnedMesh ? new qr(c, u) : new pr(c, u), !0 === d.isSkinnedMesh && d.normalizeSkinWeights(), h.mode === Dh.TRIANGLE_STRIP ? d.geometry = eh(d.geometry, 1) : h.mode === Dh.TRIANGLE_FAN && (d.geometry = eh(d.geometry, 2)); else if (h.mode === Dh.LINES) d = new wa(c, u); else if (h.mode === Dh.LINE_STRIP) d = new xa(c, u); else if (h.mode === Dh.LINE_LOOP) d = new Ma(c, u); else { if (h.mode !== Dh.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode); d = new Ua(c, u) } Object.keys(d.geometry.morphAttributes).length > 0 && Wh(d, r), d.name = t.createUniqueName(r.name || "mesh_" + e), Vh(d, r), h.extensions && zh(n, d, h), t.assignFinalMaterial(d), l.push(d) } for (let i = 0, n = l.length; i < n; i++)t.associations.set(l[i], { meshes: e, primitives: i }); if (1 === l.length) return r.extensions && zh(n, l[0], r), l[0]; const c = new Rr; r.extensions && zh(n, c, r), t.associations.set(c, { meshes: e }); for (let e = 0, t = l.length; e < t; e++)c.add(l[e]); return c })) } loadCamera(e) { let t; const i = this.json.cameras[e], n = i[i.type]; if (n) return "perspective" === i.type ? t = new Sr(Pt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === i.type && (t = new Qs(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), Vh(t, i), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], i = []; for (let e = 0, n = t.joints.length; e < n; e++)i.push(this._loadNodeShallow(t.joints[e])); return void 0 !== t.inverseBindMatrices ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then((function (e) { const t = e.pop(), i = e, n = [], r = []; for (let e = 0, a = i.length; e < a; e++) { const a = i[e]; if (a) { n.push(a); const i = new ki; null !== t && i.fromArray(t.array, 16 * e), r.push(i) } } return new Zr(n, r) })) } loadAnimation(e) { const t = this.json, i = this, n = t.animations[e], r = n.name ? n.name : "animation_" + e, a = [], s = [], o = [], l = [], c = []; for (let e = 0, t = n.channels.length; e < t; e++) { const t = n.channels[e], i = n.samplers[t.sampler], r = t.target, h = r.node, d = void 0 !== n.parameters ? n.parameters[i.input] : i.input, u = void 0 !== n.parameters ? n.parameters[i.output] : i.output; void 0 !== r.node && (a.push(this.getDependency("node", h)), s.push(this.getDependency("accessor", d)), o.push(this.getDependency("accessor", u)), l.push(i), c.push(r)) } return Promise.all([Promise.all(a), Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(c)]).then((function (e) { const t = e[0], n = e[1], a = e[2], s = e[3], o = e[4], l = []; for (let e = 0, r = t.length; e < r; e++) { const r = t[e], c = n[e], h = a[e], d = s[e], u = o[e]; if (void 0 === r) continue; r.updateMatrix && r.updateMatrix(); const A = i._createAnimationTracks(r, c, h, d, u); if (A) for (let e = 0; e < A.length; e++)l.push(A[e]) } return new ds(r, void 0, l) })) } createNodeMesh(e) { const t = this.json, i = this, n = t.nodes[e]; return void 0 === n.mesh ? null : i.getDependency("mesh", n.mesh).then((function (e) { const t = i._getNodeRef(i.meshCache, n.mesh, e); return void 0 !== n.weights && t.traverse((function (e) { if (e.isMesh) for (let t = 0, i = n.weights.length; t < i; t++)e.morphTargetInfluences[t] = n.weights[t] })), t })) } loadNode(e) { const t = this, i = this.json.nodes[e], n = t._loadNodeShallow(e), r = [], a = i.children || []; for (let e = 0, i = a.length; e < i; e++)r.push(t.getDependency("node", a[e])); const s = void 0 === i.skin ? Promise.resolve(null) : t.getDependency("skin", i.skin); return Promise.all([n, Promise.all(r), s]).then((function (e) { const t = e[0], i = e[1], n = e[2]; null !== n && t.traverse((function (e) { e.isSkinnedMesh && e.bind(n, Yh) })); for (let e = 0, n = i.length; e < n; e++)t.add(i[e]); return t })) } _loadNodeShallow(e) { const t = this.json, i = this.extensions, n = this; if (void 0 !== this.nodeCache[e]) return this.nodeCache[e]; const r = t.nodes[e], a = r.name ? n.createUniqueName(r.name) : "", s = [], o = n._invokeOne((function (t) { return t.createNodeMesh && t.createNodeMesh(e) })); return o && s.push(o), void 0 !== r.camera && s.push(n.getDependency("camera", r.camera).then((function (e) { return n._getNodeRef(n.cameraCache, r.camera, e) }))), n._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { s.push(e) })), this.nodeCache[e] = Promise.all(s).then((function (t) { let s; if (s = !0 === r.isBone ? new Xr : t.length > 1 ? new Rr : 1 === t.length ? t[0] : new An, s !== t[0]) for (let e = 0, i = t.length; e < i; e++)s.add(t[e]); if (r.name && (s.userData.name = r.name, s.name = a), Vh(s, r), r.extensions && zh(i, s, r), void 0 !== r.matrix) { const e = new ki; e.fromArray(r.matrix), s.applyMatrix4(e) } else void 0 !== r.translation && s.position.fromArray(r.translation), void 0 !== r.rotation && s.quaternion.fromArray(r.rotation), void 0 !== r.scale && s.scale.fromArray(r.scale); return n.associations.has(s) || n.associations.set(s, {}), n.associations.get(s).nodes = e, s })), this.nodeCache[e] } loadScene(e) { const t = this.extensions, i = this.json.scenes[e], n = this, r = new Rr; i.name && (r.name = n.createUniqueName(i.name)), Vh(r, i), i.extensions && zh(t, r, i); const a = i.nodes || [], s = []; for (let e = 0, t = a.length; e < t; e++)s.push(n.getDependency("node", a[e])); return Promise.all(s).then((function (e) { for (let t = 0, i = e.length; t < i; t++)r.add(e[t]); return n.associations = (e => { const t = new Map; for (const [e, i] of n.associations) (e instanceof Pn || e instanceof ii) && t.set(e, i); return e.traverse((e => { const i = n.associations.get(e); null != i && t.set(e, i) })), t })(r), r })) } _createAnimationTracks(e, t, i, n, r) { const a = [], s = e.name ? e.name : e.uuid, o = []; let l; switch (Nh[r.path] === Nh.weights ? e.traverse((function (e) { e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid) })) : o.push(s), Nh[r.path]) { case Nh.weights: l = ss; break; case Nh.rotation: l = ls; break; case Nh.translation: case Nh.scale: l = hs; break; default: if (1 === i.itemSize) l = ss; else l = hs }const c = void 0 !== n.interpolation ? kh[n.interpolation] : et, h = this._getArrayFromAccessor(i); for (let e = 0, i = o.length; e < i; e++) { const i = new l(o[e] + "." + Nh[r.path], t.array, h, c); "CUBICSPLINE" === n.interpolation && this._createCubicSplineTrackInterpolant(i), a.push(i) } return a } _getArrayFromAccessor(e) { let t = e.array; if (e.normalized) { const e = Xh(t.constructor), i = new Float32Array(t.length); for (let n = 0, r = t.length; n < r; n++)i[n] = t[n] * e; t = i } return t } _createCubicSplineTrackInterpolant(e) { e.createInterpolant = function (e) { return new (this instanceof ls ? Rh : Bh)(this.times, this.values, this.getValueSize() / 3, e) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0 } } function Jh(e, t, i) { const n = t.attributes, r = []; function a(t, n) { return i.getDependency("accessor", t).then((function (t) { e.setAttribute(n, t) })) } for (const t in n) { const i = Fh[t] || t.toLowerCase(); i in e.attributes || r.push(a(n[t], i)) } if (void 0 !== t.indices && !e.index) { const n = i.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); r.push(n) } return qt.workingColorSpace, Vh(e, t), function (e, t, i) { const n = t.attributes, r = new ui; if (void 0 === n.POSITION) return; { const e = i.json.accessors[n.POSITION], t = e.min, a = e.max; if (void 0 === t || void 0 === a) return; if (r.set(new ci(t[0], t[1], t[2]), new ci(a[0], a[1], a[2])), e.normalized) { const t = Xh(Lh[e.componentType]); r.min.multiplyScalar(t), r.max.multiplyScalar(t) } } const a = t.targets; if (void 0 !== a) { const e = new ci, t = new ci; for (let n = 0, r = a.length; n < r; n++) { const r = a[n]; if (void 0 !== r.POSITION) { const n = i.json.accessors[r.POSITION], a = n.min, s = n.max; if (void 0 !== a && void 0 !== s) { if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))), t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))), t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))), n.normalized) { const e = Xh(Lh[n.componentType]); t.multiplyScalar(e) } e.max(t) } } } r.expandByVector(e) } e.boundingBox = r; const s = new Ti; r.getCenter(s.center), s.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = s }(e, t, i), Promise.all(r).then((function () { return void 0 !== t.targets ? function (e, t, i) { let n = !1, r = !1, a = !1; for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; if (void 0 !== i.POSITION && (n = !0), void 0 !== i.NORMAL && (r = !0), void 0 !== i.COLOR_0 && (a = !0), n && r && a) break } if (!n && !r && !a) return Promise.resolve(e); const s = [], o = [], l = []; for (let c = 0, h = t.length; c < h; c++) { const h = t[c]; if (n) { const t = void 0 !== h.POSITION ? i.getDependency("accessor", h.POSITION) : e.attributes.position; s.push(t) } if (r) { const t = void 0 !== h.NORMAL ? i.getDependency("accessor", h.NORMAL) : e.attributes.normal; o.push(t) } if (a) { const t = void 0 !== h.COLOR_0 ? i.getDependency("accessor", h.COLOR_0) : e.attributes.color; l.push(t) } } return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function (t) { const i = t[0], s = t[1], o = t[2]; return n && (e.morphAttributes.position = i), r && (e.morphAttributes.normal = s), a && (e.morphAttributes.color = o), e.morphTargetsRelative = !0, e })) }(e, t.targets, i) : e })) } class Zh { constructor(e = 4) { this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0, this.workerCreator = null } _initWorker(e) { if (!this.workers[e]) { const t = this.workerCreator(); t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t } } _getIdleWorker() { for (let e = 0; e < this.pool; e++)if (!(this.workerStatus & 1 << e)) return e; return -1 } _onMessage(e, t) { const i = this.workersResolve[e]; if (i && i(t), this.queue.length) { const { resolve: t, msg: i, transfer: n } = this.queue.shift(); this.workersResolve[e] = t, this.workers[e].postMessage(i, n) } else this.workerStatus ^= 1 << e } setWorkerCreator(e) { this.workerCreator = e } setWorkerLimit(e) { this.pool = e } postMessage(e, t) { return new Promise((i => { const n = this._getIdleWorker(); -1 !== n ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = i, this.workers[n].postMessage(e, t)) : this.queue.push({ resolve: i, msg: e, transfer: t }) })) } dispose() { this.workers.forEach((e => e.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0 } } const $h = 9, ed = 15, td = 16, id = 22, nd = 37, rd = 43, ad = 76, sd = 83, od = 97, ld = 100, cd = 103, hd = 109, dd = 165, ud = 166, Ad = 1000066e3; class pd { constructor() { this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null } } class fd { constructor(e, t, i, n) { this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, i), this._littleEndian = n, this._offset = 0 } _nextUint8() { const e = this._dataView.getUint8(this._offset); return this._offset += 1, e } _nextUint16() { const e = this._dataView.getUint16(this._offset, this._littleEndian); return this._offset += 2, e } _nextUint32() { const e = this._dataView.getUint32(this._offset, this._littleEndian); return this._offset += 4, e } _nextUint64() { const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian); return this._offset += 8, e } _nextInt32() { const e = this._dataView.getInt32(this._offset, this._littleEndian); return this._offset += 4, e } _nextUint8Array(e) { const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e); return this._offset += e, t } _skip(e) { return this._offset += e, this } _scan(e, t) { void 0 === t && (t = 0); const i = this._offset; let n = 0; for (; this._dataView.getUint8(this._offset) !== t && n < e;)n++, this._offset++; return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n) } } new Uint8Array([0]); const gd = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]; function md(e) { return (new TextDecoder).decode(e) } let _d, bd, vd; const Ed = { env: { emscripten_notify_memory_growth: function (e) { vd = new Uint8Array(bd.exports.memory.buffer) } } }; class yd { init() { return _d || (_d = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + xd).then((e => e.arrayBuffer())).then((e => WebAssembly.instantiate(e, Ed))).then(this._init) : WebAssembly.instantiate(Buffer.from(xd, "base64"), Ed).then(this._init), _d) } _init(e) { bd = e.instance, Ed.env.emscripten_notify_memory_growth(0) } decode(e, t = 0) { if (!bd) throw new Error("ZSTDDecoder: Await .init() before decoding."); const i = e.byteLength, n = bd.exports.malloc(i); vd.set(e, n), t = t || Number(bd.exports.ZSTD_findDecompressedSize(n, i)); const r = bd.exports.malloc(t), a = bd.exports.ZSTD_decompress(r, t, n, i), s = vd.slice(r, r + a); return bd.exports.free(n), bd.exports.free(r), s } } const xd = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Cd = "display-p3", Id = new WeakMap; let Sd; class wd extends gs { constructor(e) { super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Zh, this.workerSourceURL = "", this.workerConfig = null } setTranscoderPath(e) { return this.transcoderPath = e, this } setWorkerLimit(e) { return this.workerPool.setWorkerLimit(e), this } async detectSupportAsync(e) { return this.workerConfig = { astcSupported: await e.hasFeatureAsync("texture-compression-astc"), astcHDRSupported: !1, etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"), etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"), dxtSupported: await e.hasFeatureAsync("texture-compression-bc"), bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"), pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc") }, this } detectSupport(e) { return !0 === e.isWebGPURenderer ? this.workerConfig = { astcSupported: e.hasFeature("texture-compression-astc"), astcHDRSupported: !1, etc1Supported: e.hasFeature("texture-compression-etc1"), etc2Supported: e.hasFeature("texture-compression-etc2"), dxtSupported: e.hasFeature("texture-compression-bc"), bptcSupported: e.hasFeature("texture-compression-bptc"), pvrtcSupported: e.hasFeature("texture-compression-pvrtc") } : this.workerConfig = { astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"), astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"), etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: e.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, this } init() { if (!this.transcoderPending) { const e = new bs(this.manager); e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials); const t = e.loadAsync("basis_transcoder.js"), i = new bs(this.manager); i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials); const n = i.loadAsync("basis_transcoder.wasm"); this.transcoderPending = Promise.all([t, n]).then((([e, t]) => { const i = wd.BasisWorker.toString(), n = ["/* constants */", "let _EngineFormat = " + JSON.stringify(wd.EngineFormat), "let _EngineType = " + JSON.stringify(wd.EngineType), "let _TranscoderFormat = " + JSON.stringify(wd.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(wd.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([n])), this.transcoderBinary = t, this.workerPool.setWorkerCreator((() => { const e = new Worker(this.workerSourceURL), t = this.transcoderBinary.slice(0); return e.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: t }, [t]), e })) })) } return this.transcoderPending } load(e, t, i, n) { if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); const r = new bs(this.manager); r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (e => { this.parse(e, t, n) }), i, n) } parse(e, t, i) { if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); if (Id.has(e)) { return Id.get(e).promise.then(t).catch(i) } this._createTexture(e).then((e => t ? t(e) : null)).catch(i) } _createTextureFrom(e, t) { const { type: i, error: n, data: { faces: r, width: a, height: s, format: o, type: l, dfdFlags: c } } = e; if ("error" === i) return Promise.reject(n); let h; if (6 === t.faceCount) h = new Na(r, o, l); else { const e = r[0].mipmaps; h = t.layerCount > 1 ? new Fa(e, a, s, t.layerCount, o, l) : new Qa(e, a, s, o, l) } return h.minFilter = 1 === r[0].mipmaps.length ? $ : te, h.magFilter = $, h.generateMipmaps = !1, h.needsUpdate = !0, h.colorSpace = Rd(t), h.premultiplyAlpha = !!(1 & c), h } async _createTexture(e, t = {}) { const i = function (e) { const t = new Uint8Array(e.buffer, e.byteOffset, gd.length); if (t[0] !== gd[0] || t[1] !== gd[1] || t[2] !== gd[2] || t[3] !== gd[3] || t[4] !== gd[4] || t[5] !== gd[5] || t[6] !== gd[6] || t[7] !== gd[7] || t[8] !== gd[8] || t[9] !== gd[9] || t[10] !== gd[10] || t[11] !== gd[11]) throw new Error("Missing KTX 2.0 identifier."); const i = new pd, n = 17 * Uint32Array.BYTES_PER_ELEMENT, r = new fd(e, gd.length, n, !0); i.vkFormat = r._nextUint32(), i.typeSize = r._nextUint32(), i.pixelWidth = r._nextUint32(), i.pixelHeight = r._nextUint32(), i.pixelDepth = r._nextUint32(), i.layerCount = r._nextUint32(), i.faceCount = r._nextUint32(); const a = r._nextUint32(); i.supercompressionScheme = r._nextUint32(); const s = r._nextUint32(), o = r._nextUint32(), l = r._nextUint32(), c = r._nextUint32(), h = r._nextUint64(), d = r._nextUint64(), u = new fd(e, gd.length + n, 3 * a * 8, !0); for (let t = 0; t < a; t++)i.levels.push({ levelData: new Uint8Array(e.buffer, e.byteOffset + u._nextUint64(), u._nextUint64()), uncompressedByteLength: u._nextUint64() }); const A = new fd(e, s, o, !0), p = { vendorId: A._skip(4)._nextUint16(), descriptorType: A._nextUint16(), versionNumber: A._nextUint16(), descriptorBlockSize: A._nextUint16(), colorModel: A._nextUint8(), colorPrimaries: A._nextUint8(), transferFunction: A._nextUint8(), flags: A._nextUint8(), texelBlockDimension: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()], bytesPlane: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()], samples: [] }, f = (p.descriptorBlockSize / 4 - 6) / 4; for (let e = 0; e < f; e++) { const t = { bitOffset: A._nextUint16(), bitLength: A._nextUint8(), channelType: A._nextUint8(), samplePosition: [A._nextUint8(), A._nextUint8(), A._nextUint8(), A._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 }; 64 & t.channelType ? (t.sampleLower = A._nextInt32(), t.sampleUpper = A._nextInt32()) : (t.sampleLower = A._nextUint32(), t.sampleUpper = A._nextUint32()), p.samples[e] = t } i.dataFormatDescriptor.length = 0, i.dataFormatDescriptor.push(p); const g = new fd(e, l, c, !0); for (; g._offset < c;) { const e = g._nextUint32(), t = g._scan(e), n = md(t); if (i.keyValue[n] = g._nextUint8Array(e - t.byteLength - 1), n.match(/^ktx/i)) { const e = md(i.keyValue[n]); i.keyValue[n] = e.substring(0, e.lastIndexOf("\0")) } g._skip(e % 4 ? 4 - e % 4 : 0) } if (d <= 0) return i; const m = new fd(e, h, d, !0), _ = m._nextUint16(), b = m._nextUint16(), v = m._nextUint32(), E = m._nextUint32(), y = m._nextUint32(), x = m._nextUint32(), C = []; for (let e = 0; e < a; e++)C.push({ imageFlags: m._nextUint32(), rgbSliceByteOffset: m._nextUint32(), rgbSliceByteLength: m._nextUint32(), alphaSliceByteOffset: m._nextUint32(), alphaSliceByteLength: m._nextUint32() }); const I = h + m._offset, S = I + v, w = S + E, M = w + y, B = new Uint8Array(e.buffer, e.byteOffset + I, v), T = new Uint8Array(e.buffer, e.byteOffset + S, E), R = new Uint8Array(e.buffer, e.byteOffset + w, y), D = new Uint8Array(e.buffer, e.byteOffset + M, x); return i.globalData = { endpointCount: _, selectorCount: b, imageDescs: C, endpointsData: B, selectorsData: T, tablesData: R, extendedData: D }, i }(new Uint8Array(e)), n = i.vkFormat === Ad && 167 === i.dataFormatDescriptor[0].colorModel; if (!(0 === i.vkFormat || n && !this.workerConfig.astcHDRSupported)) return async function (e) { const { vkFormat: t } = e; if (void 0 === Bd[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat."); let i; 2 === e.supercompressionScheme && (Sd || (Sd = new Promise((async e => { const t = new yd; await t.init(), e(t) }))), i = await Sd); const n = []; for (let r = 0; r < e.levels.length; r++) { const a = Math.max(1, e.pixelWidth >> r), s = Math.max(1, e.pixelHeight >> r), o = e.pixelDepth ? Math.max(1, e.pixelDepth >> r) : 0, l = e.levels[r]; let c, h; if (0 === e.supercompressionScheme) c = l.levelData; else { if (2 !== e.supercompressionScheme) throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme."); c = i.decode(l.levelData, l.uncompressedByteLength) } h = Td[t] === le ? new Float32Array(c.buffer, c.byteOffset, c.byteLength / Float32Array.BYTES_PER_ELEMENT) : Td[t] === ce ? new Uint16Array(c.buffer, c.byteOffset, c.byteLength / Uint16Array.BYTES_PER_ELEMENT) : c, n.push({ data: h, width: a, height: s, depth: o }) } let r; if (Md.has(Bd[t])) r = 0 === e.pixelDepth ? new Yr(n[0].data, e.pixelWidth, e.pixelHeight) : new oi(n[0].data, e.pixelWidth, e.pixelHeight, e.pixelDepth); else { if (e.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth."); r = new Qa(n, e.pixelWidth, e.pixelHeight), r.minFilter = 1 === n.length ? $ : te, r.magFilter = $ } return r.mipmaps = n, r.type = Td[t], r.format = Bd[t], r.colorSpace = Rd(e), r.needsUpdate = !0, Promise.resolve(r) }(i); const r = t, a = this.init().then((() => this.workerPool.postMessage({ type: "transcode", buffer: e, taskConfig: r }, [e]))).then((e => this._createTextureFrom(e.data, i))); return Id.set(e, { promise: a }), a } dispose() { this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL) } } wd.BasisFormat = { ETC1S: 0, UASTC: 1, UASTC_HDR: 2 }, wd.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16, BC6H: 22, RGB_HALF: 24, RGBA_HALF: 25 }, wd.EngineFormat = { RGBAFormat: pe, RGBA_ASTC_4x4_Format: Le, RGB_BPTC_UNSIGNED_Format: Ye, RGBA_BPTC_Format: qe, RGBA_ETC2_EAC_Format: De, RGBA_PVRTC_4BPPV1_Format: Me, RGBA_S3TC_DXT5_Format: Ie, RGB_ETC1_Format: Te, RGB_ETC2_Format: Re, RGB_PVRTC_4BPPV1_Format: Se, RGBA_S3TC_DXT1_Format: xe }, wd.EngineType = { UnsignedByteType: ie, HalfFloatType: ce, FloatType: le }, wd.BasisWorker = function () { let e, t, i; const n = _EngineFormat, r = _EngineType, a = _TranscoderFormat, s = _BasisFormat; self.addEventListener("message", (function (n) { const a = n.data; switch (a.type) { case "init": e = a.config, o = a.transcoderBinary, t = new Promise((e => { i = { wasmBinary: o, onRuntimeInitialized: e }, BASIS(i) })).then((() => { i.initializeBasis(), i.KTX2File })); break; case "transcode": t.then((() => { try { const { faces: t, buffers: n, width: o, height: d, hasAlpha: u, format: A, type: p, dfdFlags: f } = function (t) { const n = new i.KTX2File(new Uint8Array(t)); function a() { n.close(), n.delete() } if (!n.isValid()) throw a(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file"); let o; if (n.isUASTC()) o = s.UASTC; else if (n.isETC1S()) o = s.ETC1S; else { if (!n.isHDR()) throw new Error("THREE.KTX2Loader: Unknown Basis encoding"); o = s.UASTC_HDR } const d = n.getWidth(), u = n.getHeight(), A = n.getLayers() || 1, p = n.getLevels(), f = n.getFaces(), g = n.getHasAlpha(), m = n.getDFDFlags(), { transcoderFormat: _, engineFormat: b, engineType: v } = function (t, i, n, r) { const a = l[t]; for (let s = 0; s < a.length; s++) { const o = a[s]; if (o.if && !e[o.if]) continue; if (!o.basisFormat.includes(t)) continue; if (r && o.transcoderFormat.length < 2) continue; if (o.needsPowerOfTwo && (!c(i) || !c(n))) continue; return { transcoderFormat: o.transcoderFormat[r ? 1 : 0], engineFormat: o.engineFormat[r ? 1 : 0], engineType: o.engineType[0] } } throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.") }(o, d, u, g); if (!d || !u || !p) throw a(), new Error("THREE.KTX2Loader:\tInvalid texture"); if (!n.startTranscoding()) throw a(), new Error("THREE.KTX2Loader: .startTranscoding failed"); const E = [], y = []; for (let e = 0; e < f; e++) { const t = []; for (let i = 0; i < p; i++) { const s = []; let o, l; for (let t = 0; t < A; t++) { const c = n.getImageLevelInfo(i, t, e); 0 === e && 0 === i && 0 === t && (c.origWidth % 4 != 0 || c.origHeight), p > 1 ? (o = c.origWidth, l = c.origHeight) : (o = c.width, l = c.height); let h = new Uint8Array(n.getImageTranscodedSizeInBytes(i, t, 0, _)); const d = n.transcodeImage(h, i, t, e, _, 0, -1, -1); if (v === r.HalfFloatType && (h = new Uint16Array(h.buffer, h.byteOffset, h.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !d) throw a(), new Error("THREE.KTX2Loader: .transcodeImage failed."); s.push(h) } const c = h(s); t.push({ data: c, width: o, height: l }), y.push(c.buffer) } E.push({ mipmaps: t, width: d, height: u, format: b, type: v }) } return a(), { faces: E, buffers: y, width: d, height: u, hasAlpha: g, dfdFlags: m, format: b, type: v } }(a.buffer); self.postMessage({ type: "transcode", id: a.id, data: { faces: t, width: o, height: d, hasAlpha: u, format: A, type: p, dfdFlags: f } }, n) } catch (e) { self.postMessage({ type: "error", id: a.id, error: e.message }) } })) }var o })); const o = [{ if: "astcSupported", basisFormat: [s.UASTC], transcoderFormat: [a.ASTC_4x4, a.ASTC_4x4], engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format], engineType: [r.UnsignedByteType], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [s.ETC1S, s.UASTC], transcoderFormat: [a.BC7_M5, a.BC7_M5], engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format], engineType: [r.UnsignedByteType], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [s.ETC1S, s.UASTC], transcoderFormat: [a.BC1, a.BC3], engineFormat: [n.RGBA_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format], engineType: [r.UnsignedByteType], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [s.ETC1S, s.UASTC], transcoderFormat: [a.ETC1, a.ETC2], engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format], engineType: [r.UnsignedByteType], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [s.ETC1S, s.UASTC], transcoderFormat: [a.ETC1], engineFormat: [n.RGB_ETC1_Format], engineType: [r.UnsignedByteType], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [s.ETC1S, s.UASTC], transcoderFormat: [a.PVRTC1_4_RGB, a.PVRTC1_4_RGBA], engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format], engineType: [r.UnsignedByteType], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }, { if: "bptcSupported", basisFormat: [s.UASTC_HDR], transcoderFormat: [a.BC6H], engineFormat: [n.RGB_BPTC_UNSIGNED_Format], engineType: [r.HalfFloatType], priorityHDR: 1, needsPowerOfTwo: !1 }, { basisFormat: [s.ETC1S, s.UASTC], transcoderFormat: [a.RGBA32, a.RGBA32], engineFormat: [n.RGBAFormat, n.RGBAFormat], engineType: [r.UnsignedByteType, r.UnsignedByteType], priorityETC1S: 100, priorityUASTC: 100, needsPowerOfTwo: !1 }, { basisFormat: [s.UASTC_HDR], transcoderFormat: [a.RGBA_HALF], engineFormat: [n.RGBAFormat], engineType: [r.HalfFloatType], priorityHDR: 100, needsPowerOfTwo: !1 }], l = { [s.ETC1S]: o.filter((e => e.basisFormat.includes(s.ETC1S))).sort(((e, t) => e.priorityUASTC - t.priorityUASTC)), [s.UASTC]: o.filter((e => e.basisFormat.includes(s.UASTC))).sort(((e, t) => e.priorityUASTC - t.priorityUASTC)), [s.UASTC_HDR]: o.filter((e => e.basisFormat.includes(s.UASTC_HDR))).sort(((e, t) => e.priorityHDR - t.priorityHDR)) }; function c(e) { return e <= 2 || !(e & e - 1) && 0 !== e } function h(e) { if (1 === e.length) return e[0]; let t = 0; for (let i = 0; i < e.length; i++) { t += e[i].byteLength } const i = new Uint8Array(t); let n = 0; for (let t = 0; t < e.length; t++) { const r = e[t]; i.set(r, n), n += r.byteLength } return i } }; const Md = new Set([pe, be, me]), Bd = { [hd]: pe, [od]: pe, [nd]: pe, [rd]: pe, [cd]: be, [sd]: be, [td]: be, [id]: be, [ld]: me, [ad]: me, [ed]: me, [$h]: me, [Ad]: Le, [ud]: Fe, [dd]: Fe }, Td = { [hd]: le, [od]: ce, [nd]: ie, [rd]: ie, [cd]: le, [sd]: ce, [td]: ie, [id]: ie, [ld]: le, [ad]: ce, [ed]: ie, [$h]: ie, [Ad]: ce, [ud]: ie, [dd]: ie }; function Rd(e) { const t = e.dataFormatDescriptor[0]; return 1 === t.colorPrimaries ? 2 === t.transferFunction ? ot : lt : 10 === t.colorPrimaries ? 2 === t.transferFunction ? Cd : "display-p3-linear" : (t.colorPrimaries, st) } const Dd = new WeakMap; function Ld() { let e, t; function i(e, t, i, n, r, a) { const s = a.num_components(), o = i.num_points() * s, l = o * r.BYTES_PER_ELEMENT, c = function (e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(e, r), h = e._malloc(l); t.GetAttributeDataArrayForAllPoints(i, a, c, l, h); const d = new r(e.HEAPF32.buffer, h, o).slice(); return e._free(h), { name: n, array: d, itemSize: s } } onmessage = function (n) { const r = n.data; switch (r.type) { case "init": e = r.decoderConfig, t = new Promise((function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) })); break; case "decode": const n = r.buffer, a = r.taskConfig; t.then((e => { const t = e.draco, s = new t.Decoder; try { const e = function (e, t, n, r) { const a = r.attributeIDs, s = r.attributeTypes; let o, l; const c = t.GetEncodedGeometryType(n); if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeArrayToMesh(n, n.byteLength, o); else { if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); o = new e.PointCloud, l = t.DecodeArrayToPointCloud(n, n.byteLength, o) } if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg()); const h = { index: null, attributes: [] }; for (const n in a) { const l = self[s[n]]; let c, d; if (r.useUniqueIDs) d = a[n], c = t.GetAttributeByUniqueId(o, d); else { if (d = t.GetAttributeId(o, e[a[n]]), -1 === d) continue; c = t.GetAttribute(o, d) } const u = i(e, t, o, n, l, c); "color" === n && (u.vertexColorSpace = r.vertexColorSpace), h.attributes.push(u) } c === e.TRIANGULAR_MESH && (h.index = function (e, t, i) { const n = i.num_faces(), r = 3 * n, a = 4 * r, s = e._malloc(a); t.GetTrianglesUInt32Array(i, a, s); const o = new Uint32Array(e.HEAPF32.buffer, s, r).slice(); return e._free(s), { array: o, itemSize: 1 } }(e, t, o)); return e.destroy(o), h }(t, s, new Int8Array(n), a), o = e.attributes.map((e => e.array.buffer)); e.index && o.push(e.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: e }, o) } catch (e) { self.postMessage({ type: "error", id: r.id, error: e.message }) } finally { t.destroy(s) } })) } } } var Ud = function () { var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), t = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]); if ("object" != typeof WebAssembly) return { supported: !1 }; var i, n = WebAssembly.validate(e) ? "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb" : "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", r = WebAssembly.instantiate(a(n), {}).then((function (e) { (i = e.instance).exports.__wasm_call_ctors() })); function a(e) { for (var i = new Uint8Array(e.length), n = 0; n < e.length; ++n) { var r = e.charCodeAt(n); i[n] = r > 96 ? r - 97 : r > 64 ? r - 39 : r + 4 } var a = 0; for (n = 0; n < e.length; ++n)i[a++] = i[n] < 60 ? t[i[n]] : 64 * (i[n] - 60) + i[++n]; return i.buffer.slice(0, a) } function s(e, t, n, r, a, s) { var o = i.exports.sbrk, l = n + 3 & -4, c = o(l * r), h = o(a.length), d = new Uint8Array(i.exports.memory.buffer); d.set(a, h); var u = e(c, n, r, h, a.length); if (0 == u && s && s(c, l, r), t.set(d.subarray(c, c + n * r)), o(c - o(0)), 0 != u) throw new Error("Malformed buffer data: " + u) } var o = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, l = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }, c = [], h = 0; function d(e) { var t = { object: new Worker(e), pending: 0, requests: {} }; return t.object.onmessage = function (e) { var i = e.data; t.pending -= i.count, t.requests[i.id][i.action](i.value), delete t.requests[i.id] }, t } function u(e) { for (var t = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(a(n)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + s.toString() + A.toString(), i = new Blob([t], { type: "text/javascript" }), r = URL.createObjectURL(i), o = 0; o < e; ++o)c[o] = d(r); URL.revokeObjectURL(r) } function A(e) { r.then((function () { var t = e.data; try { var n = new Uint8Array(t.count * t.size); s(i.exports[t.mode], n, t.count, t.size, t.source, i.exports[t.filter]), self.postMessage({ id: t.id, count: t.count, action: "resolve", value: n }, [n.buffer]) } catch (e) { self.postMessage({ id: t.id, count: t.count, action: "reject", value: e }) } })) } return { ready: r, supported: !0, useWorkers: function (e) { u(e) }, decodeVertexBuffer: function (e, t, n, r, a) { s(i.exports.meshopt_decodeVertexBuffer, e, t, n, r, i.exports[o[a]]) }, decodeIndexBuffer: function (e, t, n, r) { s(i.exports.meshopt_decodeIndexBuffer, e, t, n, r) }, decodeIndexSequence: function (e, t, n, r) { s(i.exports.meshopt_decodeIndexSequence, e, t, n, r) }, decodeGltfBuffer: function (e, t, n, r, a, c) { s(i.exports[l[a]], e, t, n, r, i.exports[o[c]]) }, decodeGltfBufferAsync: function (e, t, n, a, d) { return c.length > 0 ? function (e, t, i, n, r) { for (var a = c[0], s = 1; s < c.length; ++s)c[s].pending < a.pending && (a = c[s]); return new Promise((function (s, o) { var l = new Uint8Array(i), c = h++; a.pending += e, a.requests[c] = { resolve: s, reject: o }, a.object.postMessage({ id: c, count: e, size: t, source: l, mode: n, filter: r }, [l.buffer]) })) }(e, t, n, l[a], o[d]) : r.then((function () { var r = new Uint8Array(e * t); return s(i.exports[l[a]], r, e, t, n, i.exports[o[d]]), r })) } } }(); const Pd = { type: "change" }, Qd = { type: "start" }, Fd = { type: "end" }, Nd = new Ni, kd = new da, Od = Math.cos(70 * Pt.DEG2RAD), Gd = new ci, Hd = 2 * Math.PI, zd = -1, Vd = 0, Wd = 1, jd = 2, qd = 3, Xd = 4, Yd = 5, Kd = 6, Jd = 1e-6; class Zd extends Ao { constructor(e, t = null) { super(e, t), this.state = zd, this.target = new ci, this.cursor = new ci, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: a, MIDDLE: s, RIGHT: o }, this.touches = { ONE: l, TWO: h }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new ci, this._lastQuaternion = new li, this._lastTargetPosition = new ci, this._quat = (new li).setFromUnitVectors(e.up, new ci(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new ro, this._sphericalDelta = new ro, this._scale = 1, this._panOffset = new ci, this._rotateStart = new Qt, this._rotateEnd = new Qt, this._rotateDelta = new Qt, this._panStart = new Qt, this._panEnd = new Qt, this._panDelta = new Qt, this._dollyStart = new Qt, this._dollyEnd = new Qt, this._dollyDelta = new Qt, this._dollyDirection = new ci, this._mouse = new Qt, this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = eu.bind(this), this._onPointerDown = $d.bind(this), this._onPointerUp = tu.bind(this), this._onContextMenu = lu.bind(this), this._onMouseWheel = ru.bind(this), this._onKeyDown = au.bind(this), this._onTouchStart = su.bind(this), this._onTouchMove = ou.bind(this), this._onMouseDown = iu.bind(this), this._onMouseMove = nu.bind(this), this._interceptControlDown = cu.bind(this), this._interceptControlUp = hu.bind(this), null !== this.domElement && this.connect(this.domElement), this.update() } connect(e) { super.connect(e), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }); this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none" } disconnect() { this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(); this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto" } dispose() { this.disconnect() } getPolarAngle() { return this._spherical.phi } getAzimuthalAngle() { return this._spherical.theta } getDistance() { return this.object.position.distanceTo(this.target) } listenToKeyEvents(e) { e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e } stopListenToKeyEvents() { null !== this._domElementKeyEvents && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null) } saveState() { this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom } reset() { this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(Pd), this.update(), this.state = zd } update(e = null) { const t = this.object.position; Gd.copy(t).sub(this.target), Gd.applyQuaternion(this._quat), this._spherical.setFromVector3(Gd), this.autoRotate && this.state === zd && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi); let i = this.minAzimuthAngle, n = this.maxAzimuthAngle; isFinite(i) && isFinite(n) && (i < -Math.PI ? i += Hd : i > Math.PI && (i -= Hd), n < -Math.PI ? n += Hd : n > Math.PI && (n -= Hd), this._spherical.theta = i <= n ? Math.max(i, Math.min(n, this._spherical.theta)) : this._spherical.theta > (i + n) / 2 ? Math.max(i, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), !0 === this.enableDamping ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor); let r = !1; if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius); else { const e = this._spherical.radius; this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = e != this._spherical.radius } if (Gd.setFromSpherical(this._spherical), Gd.applyQuaternion(this._quatInverse), t.copy(this.target).add(Gd), this.object.lookAt(this.target), !0 === this.enableDamping ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) { let e = null; if (this.object.isPerspectiveCamera) { const t = Gd.length(); e = this._clampDistance(t * this._scale); const i = t - e; this.object.position.addScaledVector(this._dollyDirection, i), this.object.updateMatrixWorld(), r = !!i } else if (this.object.isOrthographicCamera) { const t = new ci(this._mouse.x, this._mouse.y, 0); t.unproject(this.object); const i = this.object.zoom; this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = i !== this.object.zoom; const n = new ci(this._mouse.x, this._mouse.y, 0); n.unproject(this.object), this.object.position.sub(n).add(t), this.object.updateMatrixWorld(), e = Gd.length() } else this.zoomToCursor = !1; null !== e && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(e).add(this.object.position) : (Nd.origin.copy(this.object.position), Nd.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Nd.direction)) < Od ? this.object.lookAt(this.target) : (kd.setFromNormalAndCoplanarPoint(this.object.up, this.target), Nd.intersectPlane(kd, this.target)))) } else if (this.object.isOrthographicCamera) { const e = this.object.zoom; this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), e !== this.object.zoom && (this.object.updateProjectionMatrix(), r = !0) } return this._scale = 1, this._performCursorZoom = !1, !!(r || this._lastPosition.distanceToSquared(this.object.position) > Jd || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Jd || this._lastTargetPosition.distanceToSquared(this.target) > Jd) && (this.dispatchEvent(Pd), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) } _getAutoRotationAngle(e) { return null !== e ? Hd / 60 * this.autoRotateSpeed * e : Hd / 60 / 60 * this.autoRotateSpeed } _getZoomScale(e) { const t = Math.abs(.01 * e); return Math.pow(.95, this.zoomSpeed * t) } _rotateLeft(e) { this._sphericalDelta.theta -= e } _rotateUp(e) { this._sphericalDelta.phi -= e } _panLeft(e, t) { Gd.setFromMatrixColumn(t, 0), Gd.multiplyScalar(-e), this._panOffset.add(Gd) } _panUp(e, t) { !0 === this.screenSpacePanning ? Gd.setFromMatrixColumn(t, 1) : (Gd.setFromMatrixColumn(t, 0), Gd.crossVectors(this.object.up, Gd)), Gd.multiplyScalar(e), this._panOffset.add(Gd) } _pan(e, t) { const i = this.domElement; if (this.object.isPerspectiveCamera) { const n = this.object.position; Gd.copy(n).sub(this.target); let r = Gd.length(); r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * r / i.clientHeight, this.object.matrix), this._panUp(2 * t * r / i.clientHeight, this.object.matrix) } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : this.enablePan = !1 } _dollyOut(e) { this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : this.enableZoom = !1 } _dollyIn(e) { this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : this.enableZoom = !1 } _updateZoomParameters(e, t) { if (!this.zoomToCursor) return; this._performCursorZoom = !0; const i = this.domElement.getBoundingClientRect(), n = e - i.left, r = t - i.top, a = i.width, s = i.height; this._mouse.x = n / a * 2 - 1, this._mouse.y = -r / s * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize() } _clampDistance(e) { return Math.max(this.minDistance, Math.min(this.maxDistance, e)) } _handleMouseDownRotate(e) { this._rotateStart.set(e.clientX, e.clientY) } _handleMouseDownDolly(e) { this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY) } _handleMouseDownPan(e) { this._panStart.set(e.clientX, e.clientY) } _handleMouseMoveRotate(e) { this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed); const t = this.domElement; this._rotateLeft(Hd * this._rotateDelta.x / t.clientHeight), this._rotateUp(Hd * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update() } _handleMouseMoveDolly(e) { this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update() } _handleMouseMovePan(e) { this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update() } _handleMouseWheel(e) { this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update() } _handleKeyDown(e) { let t = !1; switch (e.code) { case this.keys.UP: e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(Hd * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), t = !0; break; case this.keys.BOTTOM: e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-Hd * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), t = !0; break; case this.keys.LEFT: e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(Hd * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), t = !0; break; case this.keys.RIGHT: e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-Hd * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), this.update()) } _handleTouchStartRotate(e) { if (1 === this._pointers.length) this._rotateStart.set(e.pageX, e.pageY); else { const t = this._getSecondPointerPosition(e), i = .5 * (e.pageX + t.x), n = .5 * (e.pageY + t.y); this._rotateStart.set(i, n) } } _handleTouchStartPan(e) { if (1 === this._pointers.length) this._panStart.set(e.pageX, e.pageY); else { const t = this._getSecondPointerPosition(e), i = .5 * (e.pageX + t.x), n = .5 * (e.pageY + t.y); this._panStart.set(i, n) } } _handleTouchStartDolly(e) { const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n); this._dollyStart.set(0, r) } _handleTouchStartDollyPan(e) { this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e) } _handleTouchStartDollyRotate(e) { this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e) } _handleTouchMoveRotate(e) { if (1 == this._pointers.length) this._rotateEnd.set(e.pageX, e.pageY); else { const t = this._getSecondPointerPosition(e), i = .5 * (e.pageX + t.x), n = .5 * (e.pageY + t.y); this._rotateEnd.set(i, n) } this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed); const t = this.domElement; this._rotateLeft(Hd * this._rotateDelta.x / t.clientHeight), this._rotateUp(Hd * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd) } _handleTouchMovePan(e) { if (1 === this._pointers.length) this._panEnd.set(e.pageX, e.pageY); else { const t = this._getSecondPointerPosition(e), i = .5 * (e.pageX + t.x), n = .5 * (e.pageY + t.y); this._panEnd.set(i, n) } this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd) } _handleTouchMoveDolly(e) { const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n); this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd); const a = .5 * (e.pageX + t.x), s = .5 * (e.pageY + t.y); this._updateZoomParameters(a, s) } _handleTouchMoveDollyPan(e) { this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e) } _handleTouchMoveDollyRotate(e) { this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e) } _addPointer(e) { this._pointers.push(e.pointerId) } _removePointer(e) { delete this._pointerPositions[e.pointerId]; for (let t = 0; t < this._pointers.length; t++)if (this._pointers[t] == e.pointerId) return void this._pointers.splice(t, 1) } _isTrackingPointer(e) { for (let t = 0; t < this._pointers.length; t++)if (this._pointers[t] == e.pointerId) return !0; return !1 } _trackPointer(e) { let t = this._pointerPositions[e.pointerId]; void 0 === t && (t = new Qt, this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY) } _getSecondPointerPosition(e) { const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0]; return this._pointerPositions[t] } _customWheelEvent(e) { const t = e.deltaMode, i = { clientX: e.clientX, clientY: e.clientY, deltaY: e.deltaY }; switch (t) { case 1: i.deltaY *= 16; break; case 2: i.deltaY *= 100 }return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i } } function $d(e) { !1 !== this.enabled && (0 === this._pointers.length && (this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._isTrackingPointer(e) || (this._addPointer(e), "touch" === e.pointerType ? this._onTouchStart(e) : this._onMouseDown(e))) } function eu(e) { !1 !== this.enabled && ("touch" === e.pointerType ? this._onTouchMove(e) : this._onMouseMove(e)) } function tu(e) { switch (this._removePointer(e), this._pointers.length) { case 0: this.domElement.releasePointerCapture(e.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(Fd), this.state = zd; break; case 1: const t = this._pointers[0], i = this._pointerPositions[t]; this._onTouchStart({ pointerId: t, pageX: i.x, pageY: i.y }) } } function iu(e) { let t; switch (e.button) { case 0: t = this.mouseButtons.LEFT; break; case 1: t = this.mouseButtons.MIDDLE; break; case 2: t = this.mouseButtons.RIGHT; break; default: t = -1 }switch (t) { case s: if (!1 === this.enableZoom) return; this._handleMouseDownDolly(e), this.state = Wd; break; case a: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === this.enablePan) return; this._handleMouseDownPan(e), this.state = jd } else { if (!1 === this.enableRotate) return; this._handleMouseDownRotate(e), this.state = Vd } break; case o: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === this.enableRotate) return; this._handleMouseDownRotate(e), this.state = Vd } else { if (!1 === this.enablePan) return; this._handleMouseDownPan(e), this.state = jd } break; default: this.state = zd }this.state !== zd && this.dispatchEvent(Qd) } function nu(e) { switch (this.state) { case Vd: if (!1 === this.enableRotate) return; this._handleMouseMoveRotate(e); break; case Wd: if (!1 === this.enableZoom) return; this._handleMouseMoveDolly(e); break; case jd: if (!1 === this.enablePan) return; this._handleMouseMovePan(e) } } function ru(e) { !1 !== this.enabled && !1 !== this.enableZoom && this.state === zd && (e.preventDefault(), this.dispatchEvent(Qd), this._handleMouseWheel(this._customWheelEvent(e)), this.dispatchEvent(Fd)) } function au(e) { !1 !== this.enabled && this._handleKeyDown(e) } function su(e) { switch (this._trackPointer(e), this._pointers.length) { case 1: switch (this.touches.ONE) { case l: if (!1 === this.enableRotate) return; this._handleTouchStartRotate(e), this.state = qd; break; case c: if (!1 === this.enablePan) return; this._handleTouchStartPan(e), this.state = Xd; break; default: this.state = zd }break; case 2: switch (this.touches.TWO) { case h: if (!1 === this.enableZoom && !1 === this.enablePan) return; this._handleTouchStartDollyPan(e), this.state = Yd; break; case d: if (!1 === this.enableZoom && !1 === this.enableRotate) return; this._handleTouchStartDollyRotate(e), this.state = Kd; break; default: this.state = zd }break; default: this.state = zd }this.state !== zd && this.dispatchEvent(Qd) } function ou(e) { switch (this._trackPointer(e), this.state) { case qd: if (!1 === this.enableRotate) return; this._handleTouchMoveRotate(e), this.update(); break; case Xd: if (!1 === this.enablePan) return; this._handleTouchMovePan(e), this.update(); break; case Yd: if (!1 === this.enableZoom && !1 === this.enablePan) return; this._handleTouchMoveDollyPan(e), this.update(); break; case Kd: if (!1 === this.enableZoom && !1 === this.enableRotate) return; this._handleTouchMoveDollyRotate(e), this.update(); break; default: this.state = zd } } function lu(e) { !1 !== this.enabled && e.preventDefault() } function cu(e) { if ("Control" === e.key) { this._controlActive = !0; this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }) } } function hu(e) { if ("Control" === e.key) { this._controlActive = !1; this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }) } } class du extends Ur { constructor() { super(); const e = new gr; e.deleteAttribute("uv"); const t = new Va({ side: 1 }), i = new Va, n = new Ps(16777215, 900, 28, 2); n.position.set(.418, 16.199, .3), this.add(n); const r = new pr(e, t); r.position.set(-.757, 13.219, .717), r.scale.set(31.713, 28.305, 28.591), this.add(r); const a = new pr(e, i); a.position.set(-10.906, 2.009, 1.846), a.rotation.set(0, -.195, 0), a.scale.set(2.328, 7.905, 4.651), this.add(a); const s = new pr(e, i); s.position.set(-5.607, -.754, -.758), s.rotation.set(0, .994, 0), s.scale.set(1.97, 1.534, 3.955), this.add(s); const o = new pr(e, i); o.position.set(6.167, .857, 7.803), o.rotation.set(0, .561, 0), o.scale.set(3.927, 6.285, 3.687), this.add(o); const l = new pr(e, i); l.position.set(-2.017, .018, 6.124), l.rotation.set(0, .333, 0), l.scale.set(2.002, 4.566, 2.064), this.add(l); const c = new pr(e, i); c.position.set(2.291, -.756, -2.621), c.rotation.set(0, -.286, 0), c.scale.set(1.546, 1.552, 1.496), this.add(c); const h = new pr(e, i); h.position.set(-2.193, -.369, -5.547), h.rotation.set(0, .516, 0), h.scale.set(3.875, 3.487, 2.986), this.add(h); const d = new pr(e, uu(50)); d.position.set(-16.116, 14.37, 8.208), d.scale.set(.1, 2.428, 2.739), this.add(d); const u = new pr(e, uu(50)); u.position.set(-16.109, 18.021, -8.207), u.scale.set(.1, 2.425, 2.751), this.add(u); const A = new pr(e, uu(17)); A.position.set(14.904, 12.198, -1.832), A.scale.set(.15, 4.265, 6.331), this.add(A); const p = new pr(e, uu(43)); p.position.set(-.462, 8.89, 14.52), p.scale.set(4.38, 5.441, .088), this.add(p); const f = new pr(e, uu(20)); f.position.set(3.235, 11.486, -12.541), f.scale.set(2.5, 2, .1), this.add(f); const g = new pr(e, uu(100)); g.position.set(0, 20, 0), g.scale.set(1, .1, 1), this.add(g) } dispose() { const e = new Set; this.traverse((t => { t.isMesh && (e.add(t.geometry), e.add(t.material)) })); for (const t of e) t.dispose() } } function uu(e) { const t = new Qn; return t.color.setScalar(e), t } class Au { constructor(e) { this.viewer = e, this.active = !1, this.measurements = [], this.activeMeasurement = null, this.instructions = null, this.onBeforeRender = null, this.previewMarker = null, this.previewLine = null, this.isRotating = !1, this.clickDisabled = !1, this.rotationTimeout = null, this.hasMovedCamera = !1, this.handleClick = this.handleClick.bind(this), this.handleMouseMove = this.handleMouseMove.bind(this), this.handleControlsStart = this.handleControlsStart.bind(this), this.handleControlsChange = this.handleControlsChange.bind(this), this.handleControlsEnd = this.handleControlsEnd.bind(this), this.snapDistance = 15, this.snapPoint = null, this.snapMarker = null } toggle() { this.viewer.content && (this.active = !this.active, this.active ? this.start() : this.clear()) } start() { this.viewer.renderer.domElement.style.cursor = "crosshair", this.viewer.renderer.domElement.addEventListener("click", this.handleClick), this.viewer.renderer.domElement.addEventListener("mousemove", this.handleMouseMove), this.isRotating = !1, this.clickDisabled = !1, this.rotationTimeout = null, this.hasMovedCamera = !1, this.viewer.controls.addEventListener("start", this.handleControlsStart), this.viewer.controls.addEventListener("change", this.handleControlsChange), this.viewer.controls.addEventListener("end", this.handleControlsEnd), this.activeMeasurement = null, this.previewMarker = null, this.previewLine = null, this.showInstructions() } handleControlsStart() { this.hasMovedCamera = !1 } handleControlsChange() { this.hasMovedCamera || (this.hasMovedCamera = !0, this.isRotating = !0, this.clickDisabled = !0) } handleControlsEnd() { this.hasMovedCamera ? (this.isRotating = !1, clearTimeout(this.rotationTimeout), this.rotationTimeout = setTimeout((() => { this.clickDisabled = !1 }), 200)) : (this.isRotating = !1, this.clickDisabled = !1), this.hasMovedCamera = !1 } showInstructions() { this.instructions || (this.instructions = document.createElement("div"), this.instructions.className = "measurement-instructions", this.instructions.style.position = "absolute", this.instructions.style.bottom = "20px", this.instructions.style.left = "50%", this.instructions.style.transform = "translateX(-50%)", this.instructions.style.backgroundColor = "rgba(0, 0, 0, 0.7)", this.instructions.style.color = "white", this.instructions.style.padding = "8px 16px", this.instructions.style.borderRadius = "4px", this.instructions.style.fontSize = "14px", this.instructions.style.zIndex = "999", this.viewer.el.appendChild(this.instructions)), this.instructions.style.display = "block", this.activeMeasurement && 1 === this.activeMeasurement.points.length ? this.instructions.textContent = "Click to set the second point" : this.instructions.textContent = "Click to start a new measurement" } createAxisIndicator(e, t = null, i = !0) { const n = new Rr, r = .02, a = new Oa(.24, 32), s = new Qn({ color: 7368959, transparent: !0, opacity: .7, side: 2 }), o = new pr(a, s), l = new Ga(r, r, .6, 8); l.rotateZ(-Math.PI / 2); const c = new Qn({ color: 16711680 }), h = new pr(l, c), d = new Ga(r, r, .6, 8), u = new Qn({ color: 65280 }), A = new pr(d, u), p = new Ga(r, r, .6, 8); p.rotateX(Math.PI / 2); const f = new Qn({ color: 255 }), g = new pr(p, f); if (n.add(o), n.add(h), n.add(A), n.add(g), i && t && t.length() > 0) { const e = new ci(0, 1, 0); Math.abs(t.dot(e)) > .99 && e.set(1, 0, 0); const i = new li, r = t.clone().normalize(), a = (new ci).crossVectors(e, r).normalize(), s = (new ci).crossVectors(r, a).normalize(), o = (new ki).makeBasis(a, s, r); i.setFromRotationMatrix(o), n.quaternion.copy(i) } return n.position.copy(e), n.userData.maintainConstantSize = !0, n.userData.baseScale = 1, this.updateIndicatorScale(n), n } updateIndicatorScale(e) { if (!e || !e.userData.maintainConstantSize) return; const t = .1 * this.viewer.activeCamera.position.distanceTo(e.position) * e.userData.baseScale; e.scale.set(t, t, t) } updateScales() { this.previewMarker && this.updateIndicatorScale(this.previewMarker); for (const e of this.measurements) e.markers.forEach((e => { this.updateIndicatorScale(e) })); this.onBeforeRender && this.onBeforeRender() } handleMouseMove(e) { if (!this.viewer.content || !this.active || this.isRotating) return; const t = this.viewer.renderer.domElement.getBoundingClientRect(), i = (e.clientX - t.left) / t.width * 2 - 1, n = -(e.clientY - t.top) / t.height * 2 + 1; this.snapPoint = null, this.snapMarker && (this.viewer.scene.remove(this.snapMarker), this.snapMarker.traverse((e => { e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((e => e.dispose())) : e.material.dispose()) })), this.snapMarker = null); const r = e.clientX, a = e.clientY; for (const e of this.measurements) { for (const t of e.points) { const e = this.getScreenPosition(t), i = e.x - r, n = e.y - a; if (Math.sqrt(i * i + n * n) < this.snapDistance) { this.snapPoint = t, this.snapMarker = this.createSnapIndicator(t), this.viewer.scene.add(this.snapMarker); break } } if (this.snapPoint) break } if (this.previewMarker && (this.viewer.scene.remove(this.previewMarker), this.previewMarker.traverse((e => { e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((e => e.dispose())) : e.material.dispose()) })), this.previewMarker = null), this.previewLine && (this.viewer.scene.remove(this.previewLine), this.previewLine.geometry.dispose(), this.previewLine.material.dispose(), this.previewLine = null), this.snapPoint) this.previewMarker = this.createAxisIndicator(this.snapPoint, null, !1), this.previewMarker.traverse((e => { if (e.material) { (Array.isArray(e.material) ? e.material : [e.material]).forEach((e => { e.depthTest = !1, e.transparent = !0, e.hasOwnProperty("opacity") || (e.opacity = 1) })) } })), this.previewMarker.renderOrder = 9999, this.viewer.scene.add(this.previewMarker), this.activeMeasurement && 1 === this.activeMeasurement.points.length && (this.createPreviewLine(this.activeMeasurement.points[0], this.snapPoint), this.previewLine.material.depthTest = !1, this.previewLine.material.transparent = !0, this.previewLine.renderOrder = 9999); else { const e = new to; e.setFromCamera({ x: i, y: n }, this.viewer.activeCamera); const t = e.intersectObject(this.viewer.content, !0); if (t.length > 0) { const e = t[0]; this.previewMarker = this.createAxisIndicator(e.point, null, !1), this.previewMarker.traverse((e => { if (e.material) { (Array.isArray(e.material) ? e.material : [e.material]).forEach((e => { e.depthTest = !1, e.transparent = !0, e.hasOwnProperty("opacity") || (e.opacity = 1) })) } })), this.previewMarker.renderOrder = 9999, this.viewer.scene.add(this.previewMarker), this.activeMeasurement && 1 === this.activeMeasurement.points.length && (this.createPreviewLine(this.activeMeasurement.points[0], e.point), this.previewLine.material.depthTest = !1, this.previewLine.material.transparent = !0, this.previewLine.renderOrder = 9999) } } } createSnapIndicator(e) { const t = new za(10), i = new Qn({ color: 16755200, transparent: !0, opacity: .8, depthTest: !1 }), n = new pr(t, i); return n.position.copy(e), n.userData.maintainConstantSize = !0, n.userData.baseScale = .012, n.renderOrder = 1e4, this.updateIndicatorScale(n), n } createPreviewLine(e, t) { const i = [e, t], n = (new ir).setFromPoints(i), r = new fa({ color: 9879309, linewidth: 1 }); this.previewLine = new xa(n, r), this.viewer.scene.add(this.previewLine) } handleClick(e) { if (!this.viewer.content || !this.active || this.isRotating || this.clickDisabled) return; if (this.snapPoint) { (!this.activeMeasurement || this.activeMeasurement.points.length >= 2) && (this.activeMeasurement = { id: Date.now(), points: [], markers: [], line: null, label: null }, this.measurements.push(this.activeMeasurement)), this.activeMeasurement.points.push(this.snapPoint.clone()); const e = this.createMeasurementPoint(this.snapPoint); return e.material.depthTest = !1, e.renderOrder = 9999, this.viewer.scene.add(e), this.activeMeasurement.markers.push(e), 2 === this.activeMeasurement.points.length && (this.previewLine && (this.viewer.scene.remove(this.previewLine), this.previewLine.geometry.dispose(), this.previewLine.material.dispose(), this.previewLine = null), this.createMeasurementLine(this.activeMeasurement), this.activeMeasurement = null), void this.showInstructions() } const t = this.viewer.renderer.domElement.getBoundingClientRect(), i = (e.clientX - t.left) / t.width * 2 - 1, n = -(e.clientY - t.top) / t.height * 2 + 1, r = new to; r.setFromCamera({ x: i, y: n }, this.viewer.activeCamera); const a = r.intersectObject(this.viewer.content, !0); if (a.length > 0) { const e = a[0]; (!this.activeMeasurement || this.activeMeasurement.points.length >= 2) && (this.activeMeasurement = { id: Date.now(), points: [], markers: [], line: null, label: null }, this.measurements.push(this.activeMeasurement)), this.activeMeasurement.points.push(e.point.clone()); const t = this.createMeasurementPoint(e.point); t.material.depthTest = !1, t.renderOrder = 9999, this.viewer.scene.add(t), this.activeMeasurement.markers.push(t), 2 === this.activeMeasurement.points.length && (this.previewLine && (this.viewer.scene.remove(this.previewLine), this.previewLine.geometry.dispose(), this.previewLine.material.dispose(), this.previewLine = null), this.createMeasurementLine(this.activeMeasurement), this.activeMeasurement = null), this.showInstructions() } } createMeasurementPoint(e) { const t = new za(8), i = new Qn({ color: 9879309 }), n = new pr(t, i); return n.position.copy(e), n.userData.maintainConstantSize = !0, n.userData.baseScale = .01, this.updateIndicatorScale(n), n } createMeasurementLine(e) { if (2 !== e.points.length) return; const t = e.points[0], i = e.points[1], n = t.distanceTo(i), r = (new ci).subVectors(i, t), a = new ci(0, 1, 0), s = r.length(), o = new Ga(.02, .02, s, 8); o.translate(0, s / 2, 0); const l = new li; l.setFromUnitVectors(a, r.clone().normalize()); const c = new Qn({ color: 9879309 }), h = new pr(o, c); h.position.copy(t), h.quaternion.copy(l), h.material.depthTest = !1, h.renderOrder = 9998, this.viewer.scene.add(h), e.line = h, this.createDistanceLabel(e, n) } createDistanceLabel(e, t) { const i = t.toFixed(2) + " m", n = (new ci).addVectors(e.points[0], e.points[1]).multiplyScalar(.5), r = document.createElement("div"); r.className = "distance-label", r.textContent = i, r.style.position = "absolute", r.style.padding = "2px 8px", r.style.backgroundColor = "rgba(150, 191, 13, 1)", r.style.color = "#ffffff", r.style.border = "1px solid #ffffff", r.style.borderRadius = "4px", r.style.fontFamily = "Arial, sans-serif", r.style.fontWeight = "bold", r.style.fontSize = "12px", r.style.pointerEvents = "auto", r.style.zIndex = "2000", r.style.transform = "translate(-50%, -50%)", r.style.boxShadow = "0 0 4px rgba(0, 0, 0, 0.5)", this.viewer.el.appendChild(r), e.label = { element: r, position: n }; const a = this.getScreenPosition(n); r.style.left = `${a.x}px`, r.style.top = `${a.y}px`; const s = document.createElement("span"); s.textContent = "✕", s.style.marginLeft = "8px", s.style.cursor = "pointer", s.style.fontWeight = "bold", s.style.pointerEvents = "auto", s.title = "Delete this measurement", s.addEventListener("click", (t => (t.stopPropagation(), t.preventDefault(), this.deleteMeasurement(e.id), !1))), r.appendChild(s), r.addEventListener("click", (e => { e.stopPropagation() })), this.setupLabelUpdates() } deleteMeasurement(e) { const t = this.measurements.findIndex((t => t.id === e)); if (-1 === t) return; const i = this.measurements[t]; i.markers.forEach((e => { this.viewer.scene.remove(e), e.traverse((e => { e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((e => e.dispose())) : e.material.dispose()) })) })), i.line && (this.viewer.scene.remove(i.line), i.line.geometry.dispose(), i.line.material.dispose()), i.label && i.label.element && i.label.element.parentNode && i.label.element.parentNode.removeChild(i.label.element), this.measurements.splice(t, 1), this.activeMeasurement && this.activeMeasurement.id === e && (this.activeMeasurement = null), this.showInstructions() } setupLabelUpdates() { this.onBeforeRender = () => { for (const e of this.measurements) if (e.label) { const t = this.getScreenPosition(e.label.position); e.label.element.style.left = `${t.x}px`, e.label.element.style.top = `${t.y}px`; const i = this.isPointVisible(e.label.position); e.label.element.style.display = i ? "block" : "none" } } } isPointVisible(e) { const t = e.clone(); return t.project(this.viewer.activeCamera), t.x >= -1 && t.x <= 1 && t.y >= -1 && t.y <= 1 && t.z >= -1 && t.z <= 1 } getScreenPosition(e) { const t = e.clone(); t.project(this.viewer.activeCamera); const i = this.viewer.renderer.domElement.getBoundingClientRect(); return { x: Math.round((.5 * t.x + .5) * i.width + i.left), y: Math.round((.5 * -t.y + .5) * i.height + i.top) } } setMeasurementVisibility(e) { for (const t of this.measurements) t.markers.forEach((t => { t.visible = e })), t.line && (t.line.visible = e), t.label && t.label.element && (t.label.element.style.display = e ? "block" : "none"); this.previewMarker && (this.previewMarker.visible = e), this.previewLine && (this.previewLine.visible = e) } clear() { this.viewer.renderer.domElement.style.cursor = "auto", this.viewer.renderer.domElement.removeEventListener("click", this.handleClick), this.viewer.renderer.domElement.removeEventListener("mousemove", this.handleMouseMove), this.viewer.controls && (this.viewer.controls.removeEventListener("start", this.handleControlsStart), this.viewer.controls.removeEventListener("change", this.handleControlsChange), this.viewer.controls.removeEventListener("end", this.handleControlsEnd)), this.rotationTimeout && (clearTimeout(this.rotationTimeout), this.rotationTimeout = null), this.clearAllMeasurements(), this.instructions && (this.instructions.style.display = "none"), this.snapPoint = null, this.snapMarker && (this.viewer.scene.remove(this.snapMarker), this.snapMarker = null), this.active = !1 } clearAllMeasurements() { for (const e of this.measurements) e.markers.forEach((e => { this.viewer.scene.remove(e), e.traverse((e => { e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((e => e.dispose())) : e.material.dispose()) })) })), e.line && (this.viewer.scene.remove(e.line), e.line.geometry.dispose(), e.line.material.dispose()), e.label && e.label.element && e.label.element.parentNode && e.label.element.parentNode.removeChild(e.label.element); this.previewMarker && (this.viewer.scene.remove(this.previewMarker), this.previewMarker.traverse((e => { e.geometry && e.geometry.dispose(), e.material && (Array.isArray(e.material) ? e.material.forEach((e => e.dispose())) : e.material.dispose()) })), this.previewMarker = null), this.previewLine && (this.viewer.scene.remove(this.previewLine), this.previewLine.geometry.dispose(), this.previewLine.material.dispose(), this.previewLine = null), this.measurements = [], this.activeMeasurement = null, this.onBeforeRender = null } } function pu(e, t) { var i = e.__state.conversionName.toString(), n = Math.round(e.r), r = Math.round(e.g), a = Math.round(e.b), s = e.a, o = Math.round(e.h), l = e.s.toFixed(1), c = e.v.toFixed(1); if (t || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) { for (var h = e.hex.toString(16); h.length < 6;)h = "0" + h; return "#" + h } return "CSS_RGB" === i ? "rgb(" + n + "," + r + "," + a + ")" : "CSS_RGBA" === i ? "rgba(" + n + "," + r + "," + a + "," + s + ")" : "HEX" === i ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === i ? "[" + n + "," + r + "," + a + "]" : "RGBA_ARRAY" === i ? "[" + n + "," + r + "," + a + "," + s + "]" : "RGB_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + a + "}" : "RGBA_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + a + ",a:" + s + "}" : "HSV_OBJ" === i ? "{h:" + o + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === i ? "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + s + "}" : "unknown format" } var fu = Array.prototype.forEach, gu = Array.prototype.slice, mu = { BREAK: {}, extend: function (e) { return this.each(gu.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (i) { this.isUndefined(t[i]) || (e[i] = t[i]) }.bind(this)) }), this), e }, defaults: function (e) { return this.each(gu.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (i) { this.isUndefined(e[i]) && (e[i] = t[i]) }.bind(this)) }), this), e }, compose: function () { var e = gu.call(arguments); return function () { for (var t = gu.call(arguments), i = e.length - 1; i >= 0; i--)t = [e[i].apply(this, t)]; return t[0] } }, each: function (e, t, i) { if (e) if (fu && e.forEach && e.forEach === fu) e.forEach(t, i); else if (e.length === e.length + 0) { var n, r = void 0; for (r = 0, n = e.length; r < n; r++)if (r in e && t.call(i, e[r], r) === this.BREAK) return } else for (var a in e) if (t.call(i, e[a], a) === this.BREAK) return }, defer: function (e) { setTimeout(e, 0) }, debounce: function (e, t, i) { var n = void 0; return function () { var r = this, a = arguments; var s = i || !n; clearTimeout(n), n = setTimeout((function () { n = null, i || e.apply(r, a) }), t), s && e.apply(r, a) } }, toArray: function (e) { return e.toArray ? e.toArray() : gu.call(e) }, isUndefined: function (e) { return void 0 === e }, isNull: function (e) { return null === e }, isNaN: function (e) { function t(t) { return e.apply(this, arguments) } return t.toString = function () { return e.toString() }, t }((function (e) { return isNaN(e) })), isArray: Array.isArray || function (e) { return e.constructor === Array }, isObject: function (e) { return e === Object(e) }, isNumber: function (e) { return e === e + 0 }, isString: function (e) { return e === e + "" }, isBoolean: function (e) { return !1 === e || !0 === e }, isFunction: function (e) { return e instanceof Function } }, _u = [{ litmus: mu.isString, conversions: { THREE_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) } }, write: pu }, SIX_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9]{6})$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) } }, write: pu }, CSS_RGB: { read: function (e) { var t = e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) } }, write: pu }, CSS_RGBA: { read: function (e) { var t = e.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) } }, write: pu } } }, { litmus: mu.isNumber, conversions: { HEX: { read: function (e) { return { space: "HEX", hex: e, conversionName: "HEX" } }, write: function (e) { return e.hex } } } }, { litmus: mu.isArray, conversions: { RGB_ARRAY: { read: function (e) { return 3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] } }, write: function (e) { return [e.r, e.g, e.b] } }, RGBA_ARRAY: { read: function (e) { return 4 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] } }, write: function (e) { return [e.r, e.g, e.b, e.a] } } } }, { litmus: mu.isObject, conversions: { RGBA_OBJ: { read: function (e) { return !!(mu.isNumber(e.r) && mu.isNumber(e.g) && mu.isNumber(e.b) && mu.isNumber(e.a)) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a } }, write: function (e) { return { r: e.r, g: e.g, b: e.b, a: e.a } } }, RGB_OBJ: { read: function (e) { return !!(mu.isNumber(e.r) && mu.isNumber(e.g) && mu.isNumber(e.b)) && { space: "RGB", r: e.r, g: e.g, b: e.b } }, write: function (e) { return { r: e.r, g: e.g, b: e.b } } }, HSVA_OBJ: { read: function (e) { return !!(mu.isNumber(e.h) && mu.isNumber(e.s) && mu.isNumber(e.v) && mu.isNumber(e.a)) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a } }, write: function (e) { return { h: e.h, s: e.s, v: e.v, a: e.a } } }, HSV_OBJ: { read: function (e) { return !!(mu.isNumber(e.h) && mu.isNumber(e.s) && mu.isNumber(e.v)) && { space: "HSV", h: e.h, s: e.s, v: e.v } }, write: function (e) { return { h: e.h, s: e.s, v: e.v } } } } }], bu = void 0, vu = void 0, Eu = function () { vu = !1; var e = arguments.length > 1 ? mu.toArray(arguments) : arguments[0]; return mu.each(_u, (function (t) { if (t.litmus(e)) return mu.each(t.conversions, (function (t, i) { if (bu = t.read(e), !1 === vu && !1 !== bu) return vu = bu, bu.conversionName = i, bu.conversion = t, mu.BREAK })), mu.BREAK })), vu }, yu = void 0, xu = { hsv_to_rgb: function (e, t, i) { var n = Math.floor(e / 60) % 6, r = e / 60 - Math.floor(e / 60), a = i * (1 - t), s = i * (1 - r * t), o = i * (1 - (1 - r) * t), l = [[i, o, a], [s, i, a], [a, i, o], [a, s, i], [o, a, i], [i, a, s]][n]; return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] } }, rgb_to_hsv: function (e, t, i) { var n = Math.min(e, t, i), r = Math.max(e, t, i), a = r - n, s = void 0; return 0 === r ? { h: NaN, s: 0, v: 0 } : (s = e === r ? (t - i) / a : t === r ? 2 + (i - e) / a : 4 + (e - t) / a, (s /= 6) < 0 && (s += 1), { h: 360 * s, s: a / r, v: r / 255 }) }, rgb_to_hex: function (e, t, i) { var n = this.hex_with_component(0, 2, e); return n = this.hex_with_component(n, 1, t), n = this.hex_with_component(n, 0, i) }, component_from_hex: function (e, t) { return e >> 8 * t & 255 }, hex_with_component: function (e, t, i) { return i << (yu = 8 * t) | e & ~(255 << yu) } }, Cu = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Iu = function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }, Su = function () { function e(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, i, n) { return i && e(t.prototype, i), n && e(t, n), t } }(), wu = function e(t, i, n) { null === t && (t = Function.prototype); var r = Object.getOwnPropertyDescriptor(t, i); if (void 0 === r) { var a = Object.getPrototypeOf(t); return null === a ? void 0 : e(a, i, n) } if ("value" in r) return r.value; var s = r.get; return void 0 !== s ? s.call(n) : void 0 }, Mu = function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) }, Bu = function (e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }, Tu = function () { function e() { if (Iu(this, e), this.__state = Eu.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments"); this.__state.a = this.__state.a || 1 } return Su(e, [{ key: "toString", value: function () { return pu(this) } }, { key: "toHexString", value: function () { return pu(this, !0) } }, { key: "toOriginal", value: function () { return this.__state.conversion.write(this) } }]), e }(); function Ru(e, t, i) { Object.defineProperty(e, t, { get: function () { return "RGB" === this.__state.space || Tu.recalculateRGB(this, t, i), this.__state[t] }, set: function (e) { "RGB" !== this.__state.space && (Tu.recalculateRGB(this, t, i), this.__state.space = "RGB"), this.__state[t] = e } }) } function Du(e, t) { Object.defineProperty(e, t, { get: function () { return "HSV" === this.__state.space || Tu.recalculateHSV(this), this.__state[t] }, set: function (e) { "HSV" !== this.__state.space && (Tu.recalculateHSV(this), this.__state.space = "HSV"), this.__state[t] = e } }) } Tu.recalculateRGB = function (e, t, i) { if ("HEX" === e.__state.space) e.__state[t] = xu.component_from_hex(e.__state.hex, i); else { if ("HSV" !== e.__state.space) throw new Error("Corrupted color state"); mu.extend(e.__state, xu.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)) } }, Tu.recalculateHSV = function (e) { var t = xu.rgb_to_hsv(e.r, e.g, e.b); mu.extend(e.__state, { s: t.s, v: t.v }), mu.isNaN(t.h) ? mu.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h }, Tu.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], Ru(Tu.prototype, "r", 2), Ru(Tu.prototype, "g", 1), Ru(Tu.prototype, "b", 0), Du(Tu.prototype, "h"), Du(Tu.prototype, "s"), Du(Tu.prototype, "v"), Object.defineProperty(Tu.prototype, "a", { get: function () { return this.__state.a }, set: function (e) { this.__state.a = e } }), Object.defineProperty(Tu.prototype, "hex", { get: function () { return "HEX" !== this.__state.space && (this.__state.hex = xu.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex }, set: function (e) { this.__state.space = "HEX", this.__state.hex = e } }); var Lu = function () { function e(t, i) { Iu(this, e), this.initialValue = t[i], this.domElement = document.createElement("div"), this.object = t, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0 } return Su(e, [{ key: "onChange", value: function (e) { return this.__onChange = e, this } }, { key: "onFinishChange", value: function (e) { return this.__onFinishChange = e, this } }, { key: "setValue", value: function (e) { return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this } }, { key: "getValue", value: function () { return this.object[this.property] } }, { key: "updateDisplay", value: function () { return this } }, { key: "isModified", value: function () { return this.initialValue !== this.getValue() } }]), e }(), Uu = {}; mu.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, (function (e, t) { mu.each(e, (function (e) { Uu[e] = t })) })); var Pu = /(\d+(\.\d+)?)px/; function Qu(e) { if ("0" === e || mu.isUndefined(e)) return 0; var t = e.match(Pu); return mu.isNull(t) ? 0 : parseFloat(t[1]) } var Fu = { makeSelectable: function (e, t) { void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function () { return !1 } : function () { }, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off") }, makeFullscreen: function (e, t, i) { var n = i, r = t; mu.isUndefined(r) && (r = !0), mu.isUndefined(n) && (n = !0), e.style.position = "absolute", r && (e.style.left = 0, e.style.right = 0), n && (e.style.top = 0, e.style.bottom = 0) }, fakeEvent: function (e, t, i, n) { var r = i || {}, a = Uu[t]; if (!a) throw new Error("Event type " + t + " not supported."); var s = document.createEvent(a); switch (a) { case "MouseEvents": var o = r.x || r.clientX || 0, l = r.y || r.clientY || 0; s.initMouseEvent(t, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, o, l, !1, !1, !1, !1, 0, null); break; case "KeyboardEvents": var c = s.initKeyboardEvent || s.initKeyEvent; mu.defaults(r, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), c(t, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode); break; default: s.initEvent(t, r.bubbles || !1, r.cancelable || !0) }mu.defaults(s, n), e.dispatchEvent(s) }, bind: function (e, t, i, n) { var r = n || !1; return e.addEventListener ? e.addEventListener(t, i, r) : e.attachEvent && e.attachEvent("on" + t, i), Fu }, unbind: function (e, t, i, n) { var r = n || !1; return e.removeEventListener ? e.removeEventListener(t, i, r) : e.detachEvent && e.detachEvent("on" + t, i), Fu }, addClass: function (e, t) { if (void 0 === e.className) e.className = t; else if (e.className !== t) { var i = e.className.split(/ +/); -1 === i.indexOf(t) && (i.push(t), e.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")) } return Fu }, removeClass: function (e, t) { if (t) if (e.className === t) e.removeAttribute("class"); else { var i = e.className.split(/ +/), n = i.indexOf(t); -1 !== n && (i.splice(n, 1), e.className = i.join(" ")) } else e.className = void 0; return Fu }, hasClass: function (e, t) { return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1 }, getWidth: function (e) { var t = getComputedStyle(e); return Qu(t["border-left-width"]) + Qu(t["border-right-width"]) + Qu(t["padding-left"]) + Qu(t["padding-right"]) + Qu(t.width) }, getHeight: function (e) { var t = getComputedStyle(e); return Qu(t["border-top-width"]) + Qu(t["border-bottom-width"]) + Qu(t["padding-top"]) + Qu(t["padding-bottom"]) + Qu(t.height) }, getOffset: function (e) { var t = e, i = { left: 0, top: 0 }; if (t.offsetParent) do { i.left += t.offsetLeft, i.top += t.offsetTop, t = t.offsetParent } while (t); return i }, isActive: function (e) { return e === document.activeElement && (e.type || e.href) } }, Nu = function (e) { function t(e, i) { Iu(this, t); var n = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), r = n; return n.__prev = n.getValue(), n.__checkbox = document.createElement("input"), n.__checkbox.setAttribute("type", "checkbox"), Fu.bind(n.__checkbox, "change", (function () { r.setValue(!r.__prev) }), !1), n.domElement.appendChild(n.__checkbox), n.updateDisplay(), n } return Mu(t, e), Su(t, [{ key: "setValue", value: function (e) { var i = wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i } }, { key: "updateDisplay", value: function () { return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Lu), ku = function (e) { function t(e, i, n) { Iu(this, t); var r = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = n, s = r; if (r.__select = document.createElement("select"), mu.isArray(a)) { var o = {}; mu.each(a, (function (e) { o[e] = e })), a = o } return mu.each(a, (function (e, t) { var i = document.createElement("option"); i.innerHTML = t, i.setAttribute("value", e), s.__select.appendChild(i) })), r.updateDisplay(), Fu.bind(r.__select, "change", (function () { var e = this.options[this.selectedIndex].value; s.setValue(e) })), r.domElement.appendChild(r.__select), r } return Mu(t, e), Su(t, [{ key: "setValue", value: function (e) { var i = wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i } }, { key: "updateDisplay", value: function () { return Fu.isActive(this.__select) ? this : (this.__select.value = this.getValue(), wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)) } }]), t }(Lu), Ou = function (e) { function t(e, i) { Iu(this, t); var n = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), r = n; function a() { r.setValue(r.__input.value) } return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), Fu.bind(n.__input, "keyup", a), Fu.bind(n.__input, "change", a), Fu.bind(n.__input, "blur", (function () { r.__onFinishChange && r.__onFinishChange.call(r, r.getValue()) })), Fu.bind(n.__input, "keydown", (function (e) { 13 === e.keyCode && this.blur() })), n.updateDisplay(), n.domElement.appendChild(n.__input), n } return Mu(t, e), Su(t, [{ key: "updateDisplay", value: function () { return Fu.isActive(this.__input) || (this.__input.value = this.getValue()), wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Lu); function Gu(e) { var t = e.toString(); return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0 } var Hu = function (e) { function t(e, i, n) { Iu(this, t); var r = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = n || {}; return r.__min = a.min, r.__max = a.max, r.__step = a.step, mu.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = Gu(r.__impliedStep), r } return Mu(t, e), Su(t, [{ key: "setValue", value: function (e) { var i = e; return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, i) } }, { key: "min", value: function (e) { return this.__min = e, this } }, { key: "max", value: function (e) { return this.__max = e, this } }, { key: "step", value: function (e) { return this.__step = e, this.__impliedStep = e, this.__precision = Gu(e), this } }]), t }(Lu); var zu = function (e) { function t(e, i, n) { Iu(this, t); var r = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i, n)); r.__truncationSuspended = !1; var a = r, s = void 0; function o() { a.__onFinishChange && a.__onFinishChange.call(a, a.getValue()) } function l(e) { var t = s - e.clientY; a.setValue(a.getValue() + t * a.__impliedStep), s = e.clientY } function c() { Fu.unbind(window, "mousemove", l), Fu.unbind(window, "mouseup", c), o() } return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), Fu.bind(r.__input, "change", (function () { var e = parseFloat(a.__input.value); mu.isNaN(e) || a.setValue(e) })), Fu.bind(r.__input, "blur", (function () { o() })), Fu.bind(r.__input, "mousedown", (function (e) { Fu.bind(window, "mousemove", l), Fu.bind(window, "mouseup", c), s = e.clientY })), Fu.bind(r.__input, "keydown", (function (e) { 13 === e.keyCode && (a.__truncationSuspended = !0, this.blur(), a.__truncationSuspended = !1, o()) })), r.updateDisplay(), r.domElement.appendChild(r.__input), r } return Mu(t, e), Su(t, [{ key: "updateDisplay", value: function () { var e, i, n; return this.__input.value = this.__truncationSuspended ? this.getValue() : (e = this.getValue(), i = this.__precision, n = Math.pow(10, i), Math.round(e * n) / n), wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Hu); function Vu(e, t, i, n, r) { return n + (e - t) / (i - t) * (r - n) } var Wu = function (e) { function t(e, i, n, r, a) { Iu(this, t); var s = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i, { min: n, max: r, step: a })), o = s; function l(e) { e.preventDefault(); var t = o.__background.getBoundingClientRect(); return o.setValue(Vu(e.clientX, t.left, t.right, o.__min, o.__max)), !1 } function c() { Fu.unbind(window, "mousemove", l), Fu.unbind(window, "mouseup", c), o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) } function h(e) { var t = e.touches[0].clientX, i = o.__background.getBoundingClientRect(); o.setValue(Vu(t, i.left, i.right, o.__min, o.__max)) } function d() { Fu.unbind(window, "touchmove", h), Fu.unbind(window, "touchend", d), o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) } return s.__background = document.createElement("div"), s.__foreground = document.createElement("div"), Fu.bind(s.__background, "mousedown", (function (e) { document.activeElement.blur(), Fu.bind(window, "mousemove", l), Fu.bind(window, "mouseup", c), l(e) })), Fu.bind(s.__background, "touchstart", (function (e) { if (1 !== e.touches.length) return; Fu.bind(window, "touchmove", h), Fu.bind(window, "touchend", d), h(e) })), Fu.addClass(s.__background, "slider"), Fu.addClass(s.__foreground, "slider-fg"), s.updateDisplay(), s.__background.appendChild(s.__foreground), s.domElement.appendChild(s.__background), s } return Mu(t, e), Su(t, [{ key: "updateDisplay", value: function () { var e = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = 100 * e + "%", wu(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Hu), ju = function (e) { function t(e, i, n) { Iu(this, t); var r = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = r; return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === n ? "Fire" : n, Fu.bind(r.__button, "click", (function (e) { return e.preventDefault(), a.fire(), !1 })), Fu.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r } return Mu(t, e), Su(t, [{ key: "fire", value: function () { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), t }(Lu), qu = function (e) { function t(e, i) { Iu(this, t); var n = Bu(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)); n.__color = new Tu(n.getValue()), n.__temp = new Tu(0); var r = n; n.domElement = document.createElement("div"), Fu.makeSelectable(n.domElement, !1), n.__selector = document.createElement("div"), n.__selector.className = "selector", n.__saturation_field = document.createElement("div"), n.__saturation_field.className = "saturation-field", n.__field_knob = document.createElement("div"), n.__field_knob.className = "field-knob", n.__field_knob_border = "2px solid ", n.__hue_knob = document.createElement("div"), n.__hue_knob.className = "hue-knob", n.__hue_field = document.createElement("div"), n.__hue_field.className = "hue-field", n.__input = document.createElement("input"), n.__input.type = "text", n.__input_textShadow = "0 1px 1px ", Fu.bind(n.__input, "keydown", (function (e) { 13 === e.keyCode && d.call(this) })), Fu.bind(n.__input, "blur", d), Fu.bind(n.__selector, "mousedown", (function () { Fu.addClass(this, "drag").bind(window, "mouseup", (function () { Fu.removeClass(r.__selector, "drag") })) })), Fu.bind(n.__selector, "touchstart", (function () { Fu.addClass(this, "drag").bind(window, "touchend", (function () { Fu.removeClass(r.__selector, "drag") })) })); var a, s = document.createElement("div"); function o(e) { A(e), Fu.bind(window, "mousemove", A), Fu.bind(window, "touchmove", A), Fu.bind(window, "mouseup", c), Fu.bind(window, "touchend", c) } function l(e) { p(e), Fu.bind(window, "mousemove", p), Fu.bind(window, "touchmove", p), Fu.bind(window, "mouseup", h), Fu.bind(window, "touchend", h) } function c() { Fu.unbind(window, "mousemove", A), Fu.unbind(window, "touchmove", A), Fu.unbind(window, "mouseup", c), Fu.unbind(window, "touchend", c), u() } function h() { Fu.unbind(window, "mousemove", p), Fu.unbind(window, "touchmove", p), Fu.unbind(window, "mouseup", h), Fu.unbind(window, "touchend", h), u() } function d() { var e = Eu(this.value); !1 !== e ? (r.__color.__state = e, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString() } function u() { r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal()) } function A(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = r.__saturation_field.getBoundingClientRect(), i = e.touches && e.touches[0] || e, n = i.clientX, a = i.clientY, s = (n - t.left) / (t.right - t.left), o = 1 - (a - t.top) / (t.bottom - t.top); return o > 1 ? o = 1 : o < 0 && (o = 0), s > 1 ? s = 1 : s < 0 && (s = 0), r.__color.v = o, r.__color.s = s, r.setValue(r.__color.toOriginal()), !1 } function p(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = r.__hue_field.getBoundingClientRect(), i = 1 - ((e.touches && e.touches[0] || e).clientY - t.top) / (t.bottom - t.top); return i > 1 ? i = 1 : i < 0 && (i = 0), r.__color.h = 360 * i, r.setValue(r.__color.toOriginal()), !1 } return mu.extend(n.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), mu.extend(n.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: n.__field_knob_border + (n.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), mu.extend(n.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), mu.extend(n.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), mu.extend(s.style, { width: "100%", height: "100%", background: "none" }), Yu(s, "top", "rgba(0,0,0,0)", "#000"), mu.extend(n.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (a = n.__hue_field).style.background = "", a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", mu.extend(n.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: n.__input_textShadow + "rgba(0,0,0,0.7)" }), Fu.bind(n.__saturation_field, "mousedown", o), Fu.bind(n.__saturation_field, "touchstart", o), Fu.bind(n.__field_knob, "mousedown", o), Fu.bind(n.__field_knob, "touchstart", o), Fu.bind(n.__hue_field, "mousedown", l), Fu.bind(n.__hue_field, "touchstart", l), n.__saturation_field.appendChild(s), n.__selector.appendChild(n.__field_knob), n.__selector.appendChild(n.__saturation_field), n.__selector.appendChild(n.__hue_field), n.__hue_field.appendChild(n.__hue_knob), n.domElement.appendChild(n.__input), n.domElement.appendChild(n.__selector), n.updateDisplay(), n } return Mu(t, e), Su(t, [{ key: "updateDisplay", value: function () { var e = Eu(this.getValue()); if (!1 !== e) { var t = !1; mu.each(Tu.COMPONENTS, (function (i) { if (!mu.isUndefined(e[i]) && !mu.isUndefined(this.__color.__state[i]) && e[i] !== this.__color.__state[i]) return t = !0, {} }), this), t && mu.extend(this.__color.__state, e) } mu.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1; var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0, n = 255 - i; mu.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Yu(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), mu.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + i + "," + i + "," + i + ")", textShadow: this.__input_textShadow + "rgba(" + n + "," + n + "," + n + ",.7)" }) } }]), t }(Lu), Xu = ["-moz-", "-o-", "-webkit-", "-ms-", ""]; function Yu(e, t, i, n) { e.style.background = "", mu.each(Xu, (function (r) { e.style.cssText += "background: " + r + "linear-gradient(" + t + ", " + i + " 0%, " + n + " 100%); " })) } var Ku = function (e, t) { var i = t || document, n = document.createElement("style"); n.type = "text/css", n.innerHTML = e; var r = i.getElementsByTagName("head")[0]; try { r.appendChild(n) } catch (e) { } }, Ju = function (e, t) { var i = e[t]; return mu.isArray(arguments[2]) || mu.isObject(arguments[2]) ? new ku(e, t, arguments[2]) : mu.isNumber(i) ? mu.isNumber(arguments[2]) && mu.isNumber(arguments[3]) ? mu.isNumber(arguments[4]) ? new Wu(e, t, arguments[2], arguments[3], arguments[4]) : new Wu(e, t, arguments[2], arguments[3]) : mu.isNumber(arguments[4]) ? new zu(e, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new zu(e, t, { min: arguments[2], max: arguments[3] }) : mu.isString(i) ? new Ou(e, t) : mu.isFunction(i) ? new ju(e, t, "") : mu.isBoolean(i) ? new Nu(e, t) : null }; var Zu = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60) }, $u = function () { function e() { Iu(this, e), this.backgroundElement = document.createElement("div"), mu.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), Fu.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), mu.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement); var t = this; Fu.bind(this.backgroundElement, "click", (function () { t.hide() })) } return Su(e, [{ key: "show", value: function () { var e = this; this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), mu.defer((function () { e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)" })) } }, { key: "hide", value: function () { var e = this, t = function t() { e.domElement.style.display = "none", e.backgroundElement.style.display = "none", Fu.unbind(e.domElement, "webkitTransitionEnd", t), Fu.unbind(e.domElement, "transitionend", t), Fu.unbind(e.domElement, "oTransitionEnd", t) }; Fu.bind(this.domElement, "webkitTransitionEnd", t), Fu.bind(this.domElement, "transitionend", t), Fu.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)" } }, { key: "layout", value: function () { this.domElement.style.left = window.innerWidth / 2 - Fu.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Fu.getHeight(this.domElement) / 2 + "px" } }]), e }(), eA = function (e) { if (e && "undefined" != typeof window) { var t = document.createElement("style"); return t.setAttribute("type", "text/css"), t.innerHTML = e, document.head.appendChild(t), e } }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"); Ku(eA); var tA = "Default", iA = function () { try { return !!window.localStorage } catch (e) { return !1 } }(), nA = void 0, rA = !0, aA = void 0, sA = !1, oA = [], lA = function e(t) { var i = this, n = t || {}; this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), Fu.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = mu.defaults(n, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH }), n = mu.defaults(n, { resizable: n.autoPlace, hideable: n.autoPlace }), mu.isUndefined(n.load) ? n.load = { preset: tA } : n.preset && (n.load.preset = n.preset), mu.isUndefined(n.parent) && n.hideable && oA.push(this), n.resizable = mu.isUndefined(n.parent) && n.resizable, n.autoPlace && mu.isUndefined(n.scrollable) && (n.scrollable = !0); var r, a = iA && "true" === localStorage.getItem(pA(this, "isLocal")), s = void 0, o = void 0; if (Object.defineProperties(this, { parent: { get: function () { return n.parent } }, scrollable: { get: function () { return n.scrollable } }, autoPlace: { get: function () { return n.autoPlace } }, closeOnTop: { get: function () { return n.closeOnTop } }, preset: { get: function () { return i.parent ? i.getRoot().preset : n.load.preset }, set: function (e) { i.parent ? i.getRoot().preset = e : n.load.preset = e, function (e) { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t) }(this), i.revert() } }, width: { get: function () { return n.width }, set: function (e) { n.width = e, _A(i, e) } }, name: { get: function () { return n.name }, set: function (e) { n.name = e, o && (o.innerHTML = n.name) } }, closed: { get: function () { return n.closed }, set: function (t) { n.closed = t, n.closed ? Fu.addClass(i.__ul, e.CLASS_CLOSED) : Fu.removeClass(i.__ul, e.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED) } }, load: { get: function () { return n.load } }, useLocalStorage: { get: function () { return a }, set: function (e) { iA && (a = e, e ? Fu.bind(window, "unload", s) : Fu.unbind(window, "unload", s), localStorage.setItem(pA(i, "isLocal"), e)) } } }), mu.isUndefined(n.parent)) { if (this.closed = n.closed || !1, Fu.addClass(this.domElement, e.CLASS_MAIN), Fu.makeSelectable(this.domElement, !1), iA && a) { i.useLocalStorage = !0; var l = localStorage.getItem(pA(this, "gui")); l && (n.load = JSON.parse(l)) } this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = e.TEXT_CLOSED, Fu.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON), n.closeOnTop ? (Fu.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Fu.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Fu.bind(this.__closeButton, "click", (function () { i.closed = !i.closed })) } else { void 0 === n.closed && (n.closed = !0); var c = document.createTextNode(n.name); Fu.addClass(c, "controller-name"), o = cA(i, c); Fu.addClass(this.__ul, e.CLASS_CLOSED), Fu.addClass(o, "title"), Fu.bind(o, "click", (function (e) { return e.preventDefault(), i.closed = !i.closed, !1 })), n.closed || (this.closed = !1) } n.autoPlace && (mu.isUndefined(n.parent) && (rA && (aA = document.createElement("div"), Fu.addClass(aA, "dg"), Fu.addClass(aA, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(aA), rA = !1), aA.appendChild(this.domElement), Fu.addClass(this.domElement, e.CLASS_AUTO_PLACE)), this.parent || _A(i, n.width)), this.__resizeHandler = function () { i.onResizeDebounced() }, Fu.bind(window, "resize", this.__resizeHandler), Fu.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), Fu.bind(this.__ul, "transitionend", this.__resizeHandler), Fu.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && mA(this), s = function () { iA && "true" === localStorage.getItem(pA(i, "isLocal")) && localStorage.setItem(pA(i, "gui"), JSON.stringify(i.getSaveObject())) }, this.saveToLocalStorageIfPossible = s, n.parent || ((r = i.getRoot()).width += 1, mu.defer((function () { r.width -= 1 }))) }; function cA(e, t, i) { var n = document.createElement("li"); return t && n.appendChild(t), i ? e.__ul.insertBefore(n, i) : e.__ul.appendChild(n), e.onResize(), n } function hA(e) { Fu.unbind(window, "resize", e.__resizeHandler), e.saveToLocalStorageIfPossible && Fu.unbind(window, "unload", e.saveToLocalStorageIfPossible) } function dA(e, t) { var i = e.__preset_select[e.__preset_select.selectedIndex]; i.innerHTML = t ? i.value + "*" : i.value } function uA(e, t) { var i = e.getRoot(), n = i.__rememberedObjects.indexOf(t.object); if (-1 !== n) { var r = i.__rememberedObjectIndecesToControllers[n]; if (void 0 === r && (r = {}, i.__rememberedObjectIndecesToControllers[n] = r), r[t.property] = t, i.load && i.load.remembered) { var a = i.load.remembered, s = void 0; if (a[e.preset]) s = a[e.preset]; else { if (!a[tA]) return; s = a[tA] } if (s[n] && void 0 !== s[n][t.property]) { var o = s[n][t.property]; t.initialValue = o, t.setValue(o) } } } } function AA(e, t, i, n) { if (void 0 === t[i]) throw new Error('Object "' + t + '" has no property "' + i + '"'); var r = void 0; if (n.color) r = new qu(t, i); else { var a = [t, i].concat(n.factoryArgs); r = Ju.apply(e, a) } n.before instanceof Lu && (n.before = n.before.__li), uA(e, r), Fu.addClass(r.domElement, "c"); var s = document.createElement("span"); Fu.addClass(s, "property-name"), s.innerHTML = r.property; var o = document.createElement("div"); o.appendChild(s), o.appendChild(r.domElement); var l = cA(e, o, n.before); return Fu.addClass(l, lA.CLASS_CONTROLLER_ROW), r instanceof qu ? Fu.addClass(l, "color") : Fu.addClass(l, Cu(r.getValue())), function (e, t, i) { if (i.__li = t, i.__gui = e, mu.extend(i, { options: function (t) { if (arguments.length > 1) { var n = i.__li.nextElementSibling; return i.remove(), AA(e, i.object, i.property, { before: n, factoryArgs: [mu.toArray(arguments)] }) } if (mu.isArray(t) || mu.isObject(t)) { var r = i.__li.nextElementSibling; return i.remove(), AA(e, i.object, i.property, { before: r, factoryArgs: [t] }) } }, name: function (e) { return i.__li.firstElementChild.firstElementChild.innerHTML = e, i }, listen: function () { return i.__gui.listen(i), i }, remove: function () { return i.__gui.remove(i), i } }), i instanceof Wu) { var n = new zu(i.object, i.property, { min: i.__min, max: i.__max, step: i.__step }); mu.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function (e) { var t = i[e], r = n[e]; i[e] = n[e] = function () { var e = Array.prototype.slice.call(arguments); return r.apply(n, e), t.apply(i, e) } })), Fu.addClass(t, "has-slider"), i.domElement.insertBefore(n.domElement, i.domElement.firstElementChild) } else if (i instanceof zu) { var r = function (t) { if (mu.isNumber(i.__min) && mu.isNumber(i.__max)) { var n = i.__li.firstElementChild.firstElementChild.innerHTML, r = i.__gui.__listening.indexOf(i) > -1; i.remove(); var a = AA(e, i.object, i.property, { before: i.__li.nextElementSibling, factoryArgs: [i.__min, i.__max, i.__step] }); return a.name(n), r && a.listen(), a } return t }; i.min = mu.compose(r, i.min), i.max = mu.compose(r, i.max) } else i instanceof Nu ? (Fu.bind(t, "click", (function () { Fu.fakeEvent(i.__checkbox, "click") })), Fu.bind(i.__checkbox, "click", (function (e) { e.stopPropagation() }))) : i instanceof ju ? (Fu.bind(t, "click", (function () { Fu.fakeEvent(i.__button, "click") })), Fu.bind(t, "mouseover", (function () { Fu.addClass(i.__button, "hover") })), Fu.bind(t, "mouseout", (function () { Fu.removeClass(i.__button, "hover") }))) : i instanceof qu && (Fu.addClass(t, "color"), i.updateDisplay = mu.compose((function (e) { return t.style.borderLeftColor = i.__color.toString(), e }), i.updateDisplay), i.updateDisplay()); i.setValue = mu.compose((function (t) { return e.getRoot().__preset_select && i.isModified() && dA(e.getRoot(), !0), t }), i.setValue) }(e, l, r), e.__controllers.push(r), r } function pA(e, t) { return document.location.href + "." + t } function fA(e, t, i) { var n = document.createElement("option"); n.innerHTML = t, n.value = t, e.__preset_select.appendChild(n), i && (e.__preset_select.selectedIndex = e.__preset_select.length - 1) } function gA(e, t) { t.style.display = e.useLocalStorage ? "block" : "none" } function mA(e) { var t = void 0; function i(i) { return i.preventDefault(), e.width += t - i.clientX, e.onResize(), t = i.clientX, !1 } function n() { Fu.removeClass(e.__closeButton, lA.CLASS_DRAG), Fu.unbind(window, "mousemove", i), Fu.unbind(window, "mouseup", n) } function r(r) { return r.preventDefault(), t = r.clientX, Fu.addClass(e.__closeButton, lA.CLASS_DRAG), Fu.bind(window, "mousemove", i), Fu.bind(window, "mouseup", n), !1 } e.__resize_handle = document.createElement("div"), mu.extend(e.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), Fu.bind(e.__resize_handle, "mousedown", r), Fu.bind(e.__closeButton, "mousedown", r), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild) } function _A(e, t) { e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px") } function bA(e, t) { var i = {}; return mu.each(e.__rememberedObjects, (function (n, r) { var a = {}, s = e.__rememberedObjectIndecesToControllers[r]; mu.each(s, (function (e, i) { a[i] = t ? e.initialValue : e.getValue() })), i[r] = a })), i } function vA(e) { 0 !== e.length && Zu.call(window, (function () { vA(e) })), mu.each(e, (function (e) { e.updateDisplay() })) } lA.toggleHide = function () { sA = !sA, mu.each(oA, (function (e) { e.domElement.style.display = sA ? "none" : "" })) }, lA.CLASS_AUTO_PLACE = "a", lA.CLASS_AUTO_PLACE_CONTAINER = "ac", lA.CLASS_MAIN = "main", lA.CLASS_CONTROLLER_ROW = "cr", lA.CLASS_TOO_TALL = "taller-than-window", lA.CLASS_CLOSED = "closed", lA.CLASS_CLOSE_BUTTON = "close-button", lA.CLASS_CLOSE_TOP = "close-top", lA.CLASS_CLOSE_BOTTOM = "close-bottom", lA.CLASS_DRAG = "drag", lA.DEFAULT_WIDTH = 245, lA.TEXT_CLOSED = "Close Controls", lA.TEXT_OPEN = "Open Controls", lA._keydownHandler = function (e) { "text" === document.activeElement.type || 72 !== e.which && 72 !== e.keyCode || lA.toggleHide() }, Fu.bind(window, "keydown", lA._keydownHandler, !1), mu.extend(lA.prototype, { add: function (e, t) { return AA(this, e, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) }, addColor: function (e, t) { return AA(this, e, t, { color: !0 }) }, remove: function (e) { this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1); var t = this; mu.defer((function () { t.onResize() })) }, destroy: function () { if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."); this.autoPlace && aA.removeChild(this.domElement); var e = this; mu.each(this.__folders, (function (t) { e.removeFolder(t) })), Fu.unbind(window, "keydown", lA._keydownHandler, !1), hA(this) }, addFolder: function (e) { if (void 0 !== this.__folders[e]) throw new Error('You already have a folder in this GUI by the name "' + e + '"'); var t = { name: e, parent: this }; t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]); var i = new lA(t); this.__folders[e] = i; var n = cA(this, i.domElement); return Fu.addClass(n, "folder"), i }, removeFolder: function (e) { this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], hA(e); var t = this; mu.each(e.__folders, (function (t) { e.removeFolder(t) })), mu.defer((function () { t.onResize() })) }, open: function () { this.closed = !1 }, close: function () { this.closed = !0 }, hide: function () { this.domElement.style.display = "none" }, show: function () { this.domElement.style.display = "" }, onResize: function () { var e = this.getRoot(); if (e.scrollable) { var t = Fu.getOffset(e.__ul).top, i = 0; mu.each(e.__ul.childNodes, (function (t) { e.autoPlace && t === e.__save_row || (i += Fu.getHeight(t)) })), window.innerHeight - t - 20 < i ? (Fu.addClass(e.domElement, lA.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - 20 + "px") : (Fu.removeClass(e.domElement, lA.CLASS_TOO_TALL), e.__ul.style.height = "auto") } e.__resize_handle && mu.defer((function () { e.__resize_handle.style.height = e.__ul.offsetHeight + "px" })), e.__closeButton && (e.__closeButton.style.width = e.width + "px") }, onResizeDebounced: mu.debounce((function () { this.onResize() }), 50), remember: function () { if (mu.isUndefined(nA) && ((nA = new $u).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'), this.parent) throw new Error("You can only call remember on a top level GUI."); var e = this; mu.each(Array.prototype.slice.call(arguments), (function (t) { 0 === e.__rememberedObjects.length && function (e) { var t = e.__save_row = document.createElement("li"); Fu.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), Fu.addClass(t, "save-row"); var i = document.createElement("span"); i.innerHTML = "&nbsp;", Fu.addClass(i, "button gears"); var n = document.createElement("span"); n.innerHTML = "Save", Fu.addClass(n, "button"), Fu.addClass(n, "save"); var r = document.createElement("span"); r.innerHTML = "New", Fu.addClass(r, "button"), Fu.addClass(r, "save-as"); var a = document.createElement("span"); a.innerHTML = "Revert", Fu.addClass(a, "button"), Fu.addClass(a, "revert"); var s = e.__preset_select = document.createElement("select"); e.load && e.load.remembered ? mu.each(e.load.remembered, (function (t, i) { fA(e, i, i === e.preset) })) : fA(e, tA, !1); if (Fu.bind(s, "change", (function () { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].innerHTML = e.__preset_select[t].value; e.preset = this.value })), t.appendChild(s), t.appendChild(i), t.appendChild(n), t.appendChild(r), t.appendChild(a), iA) { var o = document.getElementById("dg-local-explain"), l = document.getElementById("dg-local-storage"); document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(pA(e, "isLocal")) && l.setAttribute("checked", "checked"), gA(e, o), Fu.bind(l, "change", (function () { e.useLocalStorage = !e.useLocalStorage, gA(e, o) })) } var c = document.getElementById("dg-new-constructor"); Fu.bind(c, "keydown", (function (e) { !e.metaKey || 67 !== e.which && 67 !== e.keyCode || nA.hide() })), Fu.bind(i, "click", (function () { c.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), nA.show(), c.focus(), c.select() })), Fu.bind(n, "click", (function () { e.save() })), Fu.bind(r, "click", (function () { var t = prompt("Enter a new preset name."); t && e.saveAs(t) })), Fu.bind(a, "click", (function () { e.revert() })) }(e), -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t) })), this.autoPlace && _A(this, this.width) }, getRoot: function () { for (var e = this; e.parent;)e = e.parent; return e }, getSaveObject: function () { var e = this.load; return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = bA(this)), e.folders = {}, mu.each(this.__folders, (function (t, i) { e.folders[i] = t.getSaveObject() })), e }, save: function () { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = bA(this), dA(this, !1), this.saveToLocalStorageIfPossible() }, saveAs: function (e) { this.load.remembered || (this.load.remembered = {}, this.load.remembered[tA] = bA(this, !0)), this.load.remembered[e] = bA(this), this.preset = e, fA(this, e, !0), this.saveToLocalStorageIfPossible() }, revert: function (e) { mu.each(this.__controllers, (function (t) { this.getRoot().load.remembered ? uA(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue()) }), this), mu.each(this.__folders, (function (e) { e.revert(e) })), e || dA(this.getRoot(), !1) }, listen: function (e) { var t = 0 === this.__listening.length; this.__listening.push(e), t && vA(this.__listening) }, updateDisplay: function () { mu.each(this.__controllers, (function (e) { e.updateDisplay() })), mu.each(this.__folders, (function (e) { e.updateDisplay() })) } }); var EA = lA; const yA = "[default]"; class xA { constructor(e) { this.viewer = e, this.gui = null, this.cameraCtrl = null, this.cameraFolder = null, this.animFolder = null, this.animCtrls = [], this.morphFolder = null, this.morphCtrls = [], this.initialize() } initialize() { const e = this.gui = new EA({ autoPlace: !1, width: 260, hideable: !0 }), t = (e.add(this.viewer.state, "measure").name("Modalità misura"), e.addFolder("Display")); t.add(this.viewer.state, "autoRotate").onChange((() => this.viewer.updateDisplay())); t.add(this.viewer.state, "wireframe").onChange((() => this.viewer.updateDisplay())); t.add(this.viewer.state, "grid").onChange((() => this.viewer.updateDisplay())), this.animFolder = e.addFolder("Animation"), this.animFolder.domElement.style.display = "none"; this.animFolder.add(this.viewer.state, "playbackSpeed", 0, 1).onChange((e => { this.viewer.mixer && (this.viewer.mixer.timeScale = e) })), this.animFolder.add({ playAll: () => this.viewer.playAllClips() }, "playAll"), this.morphFolder = e.addFolder("Morph Targets"), this.morphFolder.domElement.style.display = "none", this.cameraFolder = e.addFolder("Cameras"), this.cameraFolder.domElement.style.display = "none"; const i = document.createElement("div"); this.viewer.el.appendChild(i), i.classList.add("gui-wrap"), i.appendChild(e.domElement), e.open() } update() { if (!this.gui) return; this.cameraFolder.domElement.style.display = "none", this.morphCtrls.forEach((e => e.remove())), this.morphCtrls.length = 0, this.morphFolder.domElement.style.display = "none", this.animCtrls.forEach((e => e.remove())), this.animCtrls.length = 0, this.animFolder.domElement.style.display = "none"; const e = [], t = []; if (this.viewer.content.traverse((i => { i.geometry && i.morphTargetInfluences && t.push(i), i.isCamera && (i.name = i.name || `VIEWER__camera_${e.length + 1}`, e.push(i.name)) })), e.length) { this.cameraFolder.domElement.style.display = "", this.cameraCtrl && this.cameraCtrl.remove(); const t = [yA].concat(e); this.cameraCtrl = this.cameraFolder.add(this.viewer.state, "camera", t), this.cameraCtrl.onChange((e => this.viewer.setCamera(e))) } if (t.length && (this.morphFolder.domElement.style.display = "", t.forEach((e => { if (e.morphTargetInfluences.length) { const t = this.morphFolder.add({ name: e.name || "Untitled" }, "name"); this.morphCtrls.push(t) } for (let t = 0; t < e.morphTargetInfluences.length; t++) { const i = this.morphFolder.add(e.morphTargetInfluences, t, 0, 1, .01).listen(); Object.keys(e.morphTargetDictionary).forEach((n => { n && e.morphTargetDictionary[n] === t && i.name(n) })), this.morphCtrls.push(i) } }))), this.viewer.clips.length) { this.animFolder.domElement.style.display = ""; const e = this.viewer.state.actionStates = {}; this.viewer.clips.forEach(((t, i) => { let n; t.name = `${i + 1}. ${t.name}`, 0 === i ? (e[t.name] = !0, n = this.viewer.mixer.clipAction(t), n.play()) : e[t.name] = !1; const r = this.animFolder.add(e, t.name).listen(); r.onChange((e => { n = n || this.viewer.mixer.clipAction(t), n.setEffectiveTimeScale(1), e ? n.play() : n.stop() })), this.animCtrls.push(r) })) } } close() { this.gui && this.gui.close() } } function CA(e, t) { e.traverse((e => { if (!e.geometry) return; (Array.isArray(e.material) ? e.material : [e.material]).forEach(t) })) } const IA = [{ id: "", name: "None", path: null }, { id: "neutral", name: "Neutral", path: null }, { id: "venice-sunset", name: "Venice Sunset", path: "https://storage.googleapis.com/donmccurdy-static/venice_sunset_1k.exr", format: ".exr" }, { id: "footprint-court", name: "Footprint Court (HDR Labs)", path: "https://storage.googleapis.com/donmccurdy-static/footprint_court_2k.exr", format: ".exr" }]; var SA = Uint8Array, wA = Uint16Array, MA = Int32Array, BA = new SA([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), TA = new SA([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), RA = new SA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), DA = function (e, t) { for (var i = new wA(31), n = 0; n < 31; ++n)i[n] = t += 1 << e[n - 1]; var r = new MA(i[30]); for (n = 1; n < 30; ++n)for (var a = i[n]; a < i[n + 1]; ++a)r[a] = a - i[n] << 5 | n; return { b: i, r } }, LA = DA(BA, 2), UA = LA.b, PA = LA.r; UA[28] = 258, PA[258] = 28; for (var QA = DA(TA, 0), FA = QA.b, NA = (QA.r, new wA(32768)), kA = 0; kA < 32768; ++kA) { var OA = (43690 & kA) >> 1 | (21845 & kA) << 1; OA = (61680 & (OA = (52428 & OA) >> 2 | (13107 & OA) << 2)) >> 4 | (3855 & OA) << 4, NA[kA] = ((65280 & OA) >> 8 | (255 & OA) << 8) >> 1 } var GA = function (e, t, i) { for (var n = e.length, r = 0, a = new wA(t); r < n; ++r)e[r] && ++a[e[r] - 1]; var s, o = new wA(t); for (r = 1; r < t; ++r)o[r] = o[r - 1] + a[r - 1] << 1; if (i) { s = new wA(1 << t); var l = 15 - t; for (r = 0; r < n; ++r)if (e[r]) for (var c = r << 4 | e[r], h = t - e[r], d = o[e[r] - 1]++ << h, u = d | (1 << h) - 1; d <= u; ++d)s[NA[d] >> l] = c } else for (s = new wA(n), r = 0; r < n; ++r)e[r] && (s[r] = NA[o[e[r] - 1]++] >> 15 - e[r]); return s }, HA = new SA(288); for (kA = 0; kA < 144; ++kA)HA[kA] = 8; for (kA = 144; kA < 256; ++kA)HA[kA] = 9; for (kA = 256; kA < 280; ++kA)HA[kA] = 7; for (kA = 280; kA < 288; ++kA)HA[kA] = 8; var zA = new SA(32); for (kA = 0; kA < 32; ++kA)zA[kA] = 5; var VA = GA(HA, 9, 1), WA = GA(zA, 5, 1), jA = function (e) { for (var t = e[0], i = 1; i < e.length; ++i)e[i] > t && (t = e[i]); return t }, qA = function (e, t, i) { var n = t / 8 | 0; return (e[n] | e[n + 1] << 8) >> (7 & t) & i }, XA = function (e, t) { var i = t / 8 | 0; return (e[i] | e[i + 1] << 8 | e[i + 2] << 16) >> (7 & t) }, YA = function (e) { return (e + 7) / 8 | 0 }, KA = function (e, t, i) { return (null == t || t < 0) && (t = 0), (null == i || i > e.length) && (i = e.length), new SA(e.subarray(t, i)) }, JA = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], ZA = function (e, t, i) { var n = new Error(t || JA[e]); if (n.code = e, Error.captureStackTrace && Error.captureStackTrace(n, ZA), !i) throw n; return n }, $A = function (e, t, i, n) { var r = e.length, a = n ? n.length : 0; if (!r || t.f && !t.l) return i || new SA(0); var s = !i, o = s || 2 != t.i, l = t.i; s && (i = new SA(3 * r)); var c = function (e) { var t = i.length; if (e > t) { var n = new SA(Math.max(2 * t, e)); n.set(i), i = n } }, h = t.f || 0, d = t.p || 0, u = t.b || 0, A = t.l, p = t.d, f = t.m, g = t.n, m = 8 * r; do { if (!A) { h = qA(e, d, 1); var _ = qA(e, d + 1, 3); if (d += 3, !_) { var b = e[(T = YA(d) + 4) - 4] | e[T - 3] << 8, v = T + b; if (v > r) { l && ZA(0); break } o && c(u + b), i.set(e.subarray(T, v), u), t.b = u += b, t.p = d = 8 * v, t.f = h; continue } if (1 == _) A = VA, p = WA, f = 9, g = 5; else if (2 == _) { var E = qA(e, d, 31) + 257, y = qA(e, d + 10, 15) + 4, x = E + qA(e, d + 5, 31) + 1; d += 14; for (var C = new SA(x), I = new SA(19), S = 0; S < y; ++S)I[RA[S]] = qA(e, d + 3 * S, 7); d += 3 * y; var w = jA(I), M = (1 << w) - 1, B = GA(I, w, 1); for (S = 0; S < x;) { var T, R = B[qA(e, d, M)]; if (d += 15 & R, (T = R >> 4) < 16) C[S++] = T; else { var D = 0, L = 0; for (16 == T ? (L = 3 + qA(e, d, 3), d += 2, D = C[S - 1]) : 17 == T ? (L = 3 + qA(e, d, 7), d += 3) : 18 == T && (L = 11 + qA(e, d, 127), d += 7); L--;)C[S++] = D } } var U = C.subarray(0, E), P = C.subarray(E); f = jA(U), g = jA(P), A = GA(U, f, 1), p = GA(P, g, 1) } else ZA(1); if (d > m) { l && ZA(0); break } } o && c(u + 131072); for (var Q = (1 << f) - 1, F = (1 << g) - 1, N = d; ; N = d) { var k = (D = A[XA(e, d) & Q]) >> 4; if ((d += 15 & D) > m) { l && ZA(0); break } if (D || ZA(2), k < 256) i[u++] = k; else { if (256 == k) { N = d, A = null; break } var O = k - 254; if (k > 264) { var G = BA[S = k - 257]; O = qA(e, d, (1 << G) - 1) + UA[S], d += G } var H = p[XA(e, d) & F], z = H >> 4; H || ZA(3), d += 15 & H; P = FA[z]; if (z > 3) { G = TA[z]; P += XA(e, d) & (1 << G) - 1, d += G } if (d > m) { l && ZA(0); break } o && c(u + 131072); var V = u + O; if (u < P) { var W = a - P, j = Math.min(P, V); for (W + u < 0 && ZA(3); u < j; ++u)i[u] = n[W + u] } for (; u < V; ++u)i[u] = i[u - P] } } t.l = A, t.p = N, t.b = u, t.f = h, A && (h = 1, t.m = f, t.d = p, t.n = g) } while (!h); return u != i.length && s ? KA(i, 0, u) : i.subarray(0, u) }, ep = new SA(0), tp = function (e, t) { return (8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31) && ZA(6, "invalid zlib data"), (e[1] >> 5 & 1) == +!t && ZA(6, "invalid zlib data: " + (32 & e[1] ? "need" : "unexpected") + " dictionary"), 2 + (e[1] >> 3 & 4) }; function ip(e, t) { return $A(e.subarray(tp(e, t && t.dictionary), -4), { i: 2 }, t && t.out, t && t.dictionary) } var np = "undefined" != typeof TextDecoder && new TextDecoder; try { np.decode(ep, { stream: !0 }) } catch (e) { } "function" == typeof queueMicrotask ? queueMicrotask : "function" == typeof setTimeout && setTimeout; class rp extends Es { constructor(e) { super(e), this.type = ce } parse(e) { const t = 65536, i = 14, n = 65537, r = 16384, a = Math.pow(2.7182818, 2.2); const s = { l: 0, c: 0, lc: 0 }; function o(e, t, i, n, r) { for (; i < e;)t = t << 8 | G(n, r), i += 8; i -= e, s.l = t >> i & (1 << e) - 1, s.c = t, s.lc = i } const l = new Array(59); function c(e, t, i, r, a, c) { const h = t; let d = 0, u = 0; for (; r <= a; r++) { if (h.value - t.value > i) return !1; o(6, d, u, e, h); const n = s.l; if (d = s.c, u = s.lc, c[r] = n, 63 == n) { if (h.value - t.value > i) throw new Error("Something wrong with hufUnpackEncTable"); o(8, d, u, e, h); let n = s.l + 6; if (d = s.c, u = s.lc, r + n > a + 1) throw new Error("Something wrong with hufUnpackEncTable"); for (; n--;)c[r++] = 0; r-- } else if (n >= 59) { let e = n - 59 + 2; if (r + e > a + 1) throw new Error("Something wrong with hufUnpackEncTable"); for (; e--;)c[r++] = 0; r-- } } !function (e) { for (let e = 0; e <= 58; ++e)l[e] = 0; for (let t = 0; t < n; ++t)l[e[t]] += 1; let t = 0; for (let e = 58; e > 0; --e) { const i = t + l[e] >> 1; l[e] = t, t = i } for (let t = 0; t < n; ++t) { const i = e[t]; i > 0 && (e[t] = i | l[i]++ << 6) } }(c) } function h(e) { return 63 & e } function d(e) { return e >> 6 } const u = { c: 0, lc: 0 }; function A(e, t, i, n) { e = e << 8 | G(i, n), t += 8, u.c = e, u.lc = t } const p = { c: 0, lc: 0 }; function f(e, t, i, n, r, a, s, o, l) { if (e == t) { n < 8 && (A(i, n, r, a), i = u.c, n = u.lc); let e = i >> (n -= 8); if (e = new Uint8Array([e])[0], o.value + e > l) return !1; const t = s[o.value - 1]; for (; e-- > 0;)s[o.value++] = t } else { if (!(o.value < l)) return !1; s[o.value++] = e } p.c = i, p.lc = n } function g(e) { return 65535 & e } function m(e) { const t = g(e); return t > 32767 ? t - 65536 : t } const _ = { a: 0, b: 0 }; function b(e, t) { const i = m(e), n = m(t), r = i + (1 & n) + (n >> 1), a = r, s = r - n; _.a = a, _.b = s } function v(e, t) { const i = g(e), n = g(t), r = i - (n >> 1) & 65535, a = n + r - 32768 & 65535; _.a = a, _.b = r } function E(e, t, i, n, r, a, s) { const o = s < 16384, l = i > r ? r : i; let c, h, d = 1; for (; d <= l;)d <<= 1; for (d >>= 1, c = d, d >>= 1; d >= 1;) { h = 0; const s = h + a * (r - c), l = a * d, u = a * c, A = n * d, p = n * c; let f, g, m, E; for (; h <= s; h += u) { let r = h; const a = h + n * (i - c); for (; r <= a; r += p) { const i = r + A, n = r + l, a = n + A; o ? (b(e[r + t], e[n + t]), f = _.a, m = _.b, b(e[i + t], e[a + t]), g = _.a, E = _.b, b(f, g), e[r + t] = _.a, e[i + t] = _.b, b(m, E), e[n + t] = _.a, e[a + t] = _.b) : (v(e[r + t], e[n + t]), f = _.a, m = _.b, v(e[i + t], e[a + t]), g = _.a, E = _.b, v(f, g), e[r + t] = _.a, e[i + t] = _.b, v(m, E), e[n + t] = _.a, e[a + t] = _.b) } if (i & d) { const i = r + l; o ? b(e[r + t], e[i + t]) : v(e[r + t], e[i + t]), f = _.a, e[i + t] = _.b, e[r + t] = f } } if (r & d) { let r = h; const a = h + n * (i - c); for (; r <= a; r += p) { const i = r + A; o ? b(e[r + t], e[i + t]) : v(e[r + t], e[i + t]), f = _.a, e[i + t] = _.b, e[r + t] = f } } c = d, d >>= 1 } return h } function y(e, t, a, s, o, l) { const g = a.value, m = O(t, a), _ = O(t, a); a.value += 4; const b = O(t, a); if (a.value += 4, m < 0 || m >= n || _ < 0 || _ >= n) throw new Error("Something wrong with HUF_ENCSIZE"); const v = new Array(n), E = new Array(r); !function (e) { for (let t = 0; t < r; t++)e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null }(E); if (c(e, a, s - (a.value - g), m, _, v), b > 8 * (s - (a.value - g))) throw new Error("Something wrong with hufUncompress"); !function (e, t, n, r) { for (; t <= n; t++) { const n = d(e[t]), a = h(e[t]); if (n >> a) throw new Error("Invalid table entry"); if (a > i) { const e = r[n >> a - i]; if (e.len) throw new Error("Invalid table entry"); if (e.lit++, e.p) { const t = e.p; e.p = new Array(e.lit); for (let i = 0; i < e.lit - 1; ++i)e.p[i] = t[i] } else e.p = new Array(1); e.p[e.lit - 1] = t } else if (a) { let e = 0; for (let s = 1 << i - a; s > 0; s--) { const s = r[(n << i - a) + e]; if (s.len || s.p) throw new Error("Invalid table entry"); s.len = a, s.lit = t, e++ } } } }(v, m, _, E), function (e, t, n, r, a, s, o, l, c) { let g = 0, m = 0; const _ = o, b = Math.trunc(r.value + (a + 7) / 8); for (; r.value < b;)for (A(g, m, n, r), g = u.c, m = u.lc; m >= i;) { const a = t[g >> m - i & 16383]; if (a.len) m -= a.len, f(a.lit, s, g, m, n, r, l, c, _), g = p.c, m = p.lc; else { if (!a.p) throw new Error("hufDecode issues"); let t; for (t = 0; t < a.lit; t++) { const i = h(e[a.p[t]]); for (; m < i && r.value < b;)A(g, m, n, r), g = u.c, m = u.lc; if (m >= i && d(e[a.p[t]]) == (g >> m - i & (1 << i) - 1)) { m -= i, f(a.p[t], s, g, m, n, r, l, c, _), g = p.c, m = p.lc; break } } if (t == a.lit) throw new Error("hufDecode issues") } } const v = 8 - a & 7; for (g >>= v, m -= v; m > 0;) { const e = t[g << i - m & 16383]; if (!e.len) throw new Error("hufDecode issues"); m -= e.len, f(e.lit, s, g, m, n, r, l, c, _), g = p.c, m = p.lc } }(v, E, e, a, b, _, l, o, { value: 0 }) } function x(e) { for (let t = 1; t < e.length; t++) { const i = e[t - 1] + e[t] - 128; e[t] = i } } function C(e, t) { let i = 0, n = Math.floor((e.length + 1) / 2), r = 0; const a = e.length - 1; for (; !(r > a || (t[r++] = e[i++], r > a));)t[r++] = e[n++] } function I(e) { let t = e.byteLength; const i = new Array; let n = 0; const r = new DataView(e); for (; t > 0;) { const e = r.getInt8(n++); if (e < 0) { const a = -e; t -= a + 1; for (let e = 0; e < a; e++)i.push(r.getUint8(n++)) } else { const a = e; t -= 2; const s = r.getUint8(n++); for (let e = 0; e < a + 1; e++)i.push(s) } } return i } function S(e, t, i) { let n, r = 1; for (; r < 64;)n = t[e.value], 65280 == n ? r = 64 : n >> 8 == 255 ? r += 255 & n : (i[r] = n, r++), e.value++ } function w(e, t) { t[0] = j(e[0]), t[1] = j(e[1]), t[2] = j(e[5]), t[3] = j(e[6]), t[4] = j(e[14]), t[5] = j(e[15]), t[6] = j(e[27]), t[7] = j(e[28]), t[8] = j(e[2]), t[9] = j(e[4]), t[10] = j(e[7]), t[11] = j(e[13]), t[12] = j(e[16]), t[13] = j(e[26]), t[14] = j(e[29]), t[15] = j(e[42]), t[16] = j(e[3]), t[17] = j(e[8]), t[18] = j(e[12]), t[19] = j(e[17]), t[20] = j(e[25]), t[21] = j(e[30]), t[22] = j(e[41]), t[23] = j(e[43]), t[24] = j(e[9]), t[25] = j(e[11]), t[26] = j(e[18]), t[27] = j(e[24]), t[28] = j(e[31]), t[29] = j(e[40]), t[30] = j(e[44]), t[31] = j(e[53]), t[32] = j(e[10]), t[33] = j(e[19]), t[34] = j(e[23]), t[35] = j(e[32]), t[36] = j(e[39]), t[37] = j(e[45]), t[38] = j(e[52]), t[39] = j(e[54]), t[40] = j(e[20]), t[41] = j(e[22]), t[42] = j(e[33]), t[43] = j(e[38]), t[44] = j(e[46]), t[45] = j(e[51]), t[46] = j(e[55]), t[47] = j(e[60]), t[48] = j(e[21]), t[49] = j(e[34]), t[50] = j(e[37]), t[51] = j(e[47]), t[52] = j(e[50]), t[53] = j(e[56]), t[54] = j(e[59]), t[55] = j(e[61]), t[56] = j(e[35]), t[57] = j(e[36]), t[58] = j(e[48]), t[59] = j(e[49]), t[60] = j(e[57]), t[61] = j(e[58]), t[62] = j(e[62]), t[63] = j(e[63]) } function M(e) { const t = .5 * Math.cos(.7853975), i = .5 * Math.cos(3.14159 / 16), n = .5 * Math.cos(3.14159 / 8), r = .5 * Math.cos(3 * 3.14159 / 16), a = .5 * Math.cos(.981746875), s = .5 * Math.cos(3 * 3.14159 / 8), o = .5 * Math.cos(1.374445625), l = new Array(4), c = new Array(4), h = new Array(4), d = new Array(4); for (let u = 0; u < 8; ++u) { const A = 8 * u; l[0] = n * e[A + 2], l[1] = s * e[A + 2], l[2] = n * e[A + 6], l[3] = s * e[A + 6], c[0] = i * e[A + 1] + r * e[A + 3] + a * e[A + 5] + o * e[A + 7], c[1] = r * e[A + 1] - o * e[A + 3] - i * e[A + 5] - a * e[A + 7], c[2] = a * e[A + 1] - i * e[A + 3] + o * e[A + 5] + r * e[A + 7], c[3] = o * e[A + 1] - a * e[A + 3] + r * e[A + 5] - i * e[A + 7], h[0] = t * (e[A + 0] + e[A + 4]), h[3] = t * (e[A + 0] - e[A + 4]), h[1] = l[0] + l[3], h[2] = l[1] - l[2], d[0] = h[0] + h[1], d[1] = h[3] + h[2], d[2] = h[3] - h[2], d[3] = h[0] - h[1], e[A + 0] = d[0] + c[0], e[A + 1] = d[1] + c[1], e[A + 2] = d[2] + c[2], e[A + 3] = d[3] + c[3], e[A + 4] = d[3] - c[3], e[A + 5] = d[2] - c[2], e[A + 6] = d[1] - c[1], e[A + 7] = d[0] - c[0] } for (let u = 0; u < 8; ++u)l[0] = n * e[16 + u], l[1] = s * e[16 + u], l[2] = n * e[48 + u], l[3] = s * e[48 + u], c[0] = i * e[8 + u] + r * e[24 + u] + a * e[40 + u] + o * e[56 + u], c[1] = r * e[8 + u] - o * e[24 + u] - i * e[40 + u] - a * e[56 + u], c[2] = a * e[8 + u] - i * e[24 + u] + o * e[40 + u] + r * e[56 + u], c[3] = o * e[8 + u] - a * e[24 + u] + r * e[40 + u] - i * e[56 + u], h[0] = t * (e[u] + e[32 + u]), h[3] = t * (e[u] - e[32 + u]), h[1] = l[0] + l[3], h[2] = l[1] - l[2], d[0] = h[0] + h[1], d[1] = h[3] + h[2], d[2] = h[3] - h[2], d[3] = h[0] - h[1], e[0 + u] = d[0] + c[0], e[8 + u] = d[1] + c[1], e[16 + u] = d[2] + c[2], e[24 + u] = d[3] + c[3], e[32 + u] = d[3] - c[3], e[40 + u] = d[2] - c[2], e[48 + u] = d[1] - c[1], e[56 + u] = d[0] - c[0] } function B(e) { for (let t = 0; t < 64; ++t) { const i = e[0][t], n = e[1][t], r = e[2][t]; e[0][t] = i + 1.5747 * r, e[1][t] = i - .1873 * n - .4682 * r, e[2][t] = i + 1.8556 * n } } function T(e, t, i) { for (let n = 0; n < 64; ++n)t[i + n] = Gn.toHalfFloat(R(e[n])) } function R(e) { return e <= 1 ? Math.sign(e) * Math.pow(Math.abs(e), 2.2) : Math.sign(e) * Math.pow(a, Math.abs(e) - 1) } function D(e) { return new DataView(e.array.buffer, e.offset.value, e.size) } function L(e) { const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size), i = new Uint8Array(I(t)), n = new Uint8Array(i.length); return x(i), C(i, n), new DataView(n.buffer) } function U(e) { const t = ip(e.array.slice(e.offset.value, e.offset.value + e.size)), i = new Uint8Array(t.length); return x(t), C(t, i), new DataView(i.buffer) } function P(e) { const i = e.viewer, n = { value: e.offset.value }, r = new Uint16Array(e.columns * e.lines * (e.inputChannels.length * e.type)), a = new Uint8Array(8192); let s = 0; const o = new Array(e.inputChannels.length); for (let t = 0, i = e.inputChannels.length; t < i; t++)o[t] = {}, o[t].start = s, o[t].end = o[t].start, o[t].nx = e.columns, o[t].ny = e.lines, o[t].size = e.type, s += o[t].nx * o[t].ny * o[t].size; const l = q(i, n), c = q(i, n); if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"); if (l <= c) for (let e = 0; e < c - l + 1; e++)a[e + l] = H(i, n); const h = new Uint16Array(t), d = function (e, i) { let n = 0; for (let r = 0; r < t; ++r)(0 == r || e[r >> 3] & 1 << (7 & r)) && (i[n++] = r); const r = n - 1; for (; n < t;)i[n++] = 0; return r }(a, h), u = O(i, n); y(e.array, i, n, u, r, s); for (let t = 0; t < e.inputChannels.length; ++t) { const e = o[t]; for (let i = 0; i < o[t].size; ++i)E(r, e.start + i, e.nx, e.size, e.ny, e.nx * e.size, d) } !function (e, t, i) { for (let n = 0; n < i; ++n)t[n] = e[t[n]] }(h, r, s); let A = 0; const p = new Uint8Array(r.buffer.byteLength); for (let t = 0; t < e.lines; t++)for (let t = 0; t < e.inputChannels.length; t++) { const e = o[t], i = e.nx * e.size, n = new Uint8Array(r.buffer, 2 * e.end, 2 * i); p.set(n, A), A += 2 * i, e.end += i } return new DataView(p.buffer) } function Q(e) { const t = ip(e.array.slice(e.offset.value, e.offset.value + e.size)), i = e.inputChannels.length * e.lines * e.columns * e.totalBytes, n = new ArrayBuffer(i), r = new DataView(n); let a = 0, s = 0; const o = new Array(4); for (let i = 0; i < e.lines; i++)for (let i = 0; i < e.inputChannels.length; i++) { let n = 0; switch (e.inputChannels[i].pixelType) { case 1: o[0] = a, o[1] = o[0] + e.columns, a = o[1] + e.columns; for (let i = 0; i < e.columns; ++i) { n += t[o[0]++] << 8 | t[o[1]++], r.setUint16(s, n, !0), s += 2 } break; case 2: o[0] = a, o[1] = o[0] + e.columns, o[2] = o[1] + e.columns, a = o[2] + e.columns; for (let i = 0; i < e.columns; ++i) { n += t[o[0]++] << 24 | t[o[1]++] << 16 | t[o[2]++] << 8, r.setUint32(s, n, !0), s += 4 } } } return r } function F(e) { const t = e.viewer, i = { value: e.offset.value }, n = new Uint8Array(e.columns * e.lines * (e.inputChannels.length * e.type * 2)), r = { version: z(t, i), unknownUncompressedSize: z(t, i), unknownCompressedSize: z(t, i), acCompressedSize: z(t, i), dcCompressedSize: z(t, i), rleCompressedSize: z(t, i), rleUncompressedSize: z(t, i), rleRawSize: z(t, i), totalAcUncompressedCount: z(t, i), totalDcUncompressedCount: z(t, i), acCompression: z(t, i) }; if (r.version < 2) throw new Error("EXRLoader.parse: " + ne.compression + " version " + r.version + " is unsupported"); const a = new Array; let s = q(t, i) - 2; for (; s > 0;) { const e = N(t.buffer, i), n = H(t, i), r = n >> 2 & 3, o = new Int8Array([(n >> 4) - 1])[0], l = H(t, i); a.push({ name: e, index: o, type: l, compression: r }), s -= e.length + 3 } const o = ne.channels, l = new Array(e.inputChannels.length); for (let t = 0; t < e.inputChannels.length; ++t) { const i = l[t] = {}, n = o[t]; i.name = n.name, i.compression = 0, i.decoded = !1, i.type = n.pixelType, i.pLinear = n.pLinear, i.width = e.columns, i.height = e.lines } const c = { idx: new Array(3) }; for (let t = 0; t < e.inputChannels.length; ++t) { const e = l[t]; for (let i = 0; i < a.length; ++i) { const n = a[i]; e.name == n.name && (e.compression = n.compression, n.index >= 0 && (c.idx[n.index] = t), e.offset = t) } } let h, d, u; if (r.acCompressedSize > 0) switch (r.acCompression) { case 0: h = new Uint16Array(r.totalAcUncompressedCount), y(e.array, t, i, r.acCompressedSize, h, r.totalAcUncompressedCount); break; case 1: const n = ip(e.array.slice(i.value, i.value + r.totalAcUncompressedCount)); h = new Uint16Array(n.buffer), i.value += r.totalAcUncompressedCount }if (r.dcCompressedSize > 0) { const t = { array: e.array, offset: i, size: r.dcCompressedSize }; d = new Uint16Array(U(t).buffer), i.value += r.dcCompressedSize } if (r.rleRawSize > 0) { u = I(ip(e.array.slice(i.value, i.value + r.rleCompressedSize)).buffer), i.value += r.rleCompressedSize } let A = 0; const p = new Array(l.length); for (let e = 0; e < p.length; ++e)p[e] = new Array; for (let t = 0; t < e.lines; ++t)for (let t = 0; t < l.length; ++t)p[t].push(A), A += l[t].width * e.type * 2; !function (e, t, i, n, r, a) { let s = new DataView(a.buffer); const o = i[e.idx[0]].width, l = i[e.idx[0]].height, c = Math.floor(o / 8), h = Math.ceil(o / 8), d = Math.ceil(l / 8), u = o - 8 * (h - 1), A = l - 8 * (d - 1), p = { value: 0 }, f = new Array(3), g = new Array(3), m = new Array(3), _ = new Array(3), b = new Array(3); for (let i = 0; i < 3; ++i)b[i] = t[e.idx[i]], f[i] = i < 1 ? 0 : f[i - 1] + h * d, g[i] = new Float32Array(64), m[i] = new Uint16Array(64), _[i] = new Uint16Array(64 * h); for (let t = 0; t < d; ++t) { let a = 8; t == d - 1 && (a = A); let o = 8; for (let e = 0; e < h; ++e) { e == h - 1 && (o = u); for (let e = 0; e < 3; ++e)m[e].fill(0), m[e][0] = r[f[e]++], S(p, n, m[e]), w(m[e], g[e]), M(g[e]); B(g); for (let t = 0; t < 3; ++t)T(g[t], _[t], 64 * e) } let l = 0; for (let n = 0; n < 3; ++n) { const r = i[e.idx[n]].type; for (let e = 8 * t; e < 8 * t + a; ++e) { l = b[n][e]; for (let t = 0; t < c; ++t) { const i = 64 * t + 8 * (7 & e); s.setUint16(l + 0 * r, _[n][i + 0], !0), s.setUint16(l + 2 * r, _[n][i + 1], !0), s.setUint16(l + 4 * r, _[n][i + 2], !0), s.setUint16(l + 6 * r, _[n][i + 3], !0), s.setUint16(l + 8 * r, _[n][i + 4], !0), s.setUint16(l + 10 * r, _[n][i + 5], !0), s.setUint16(l + 12 * r, _[n][i + 6], !0), s.setUint16(l + 14 * r, _[n][i + 7], !0), l += 16 * r } } if (c != h) for (let e = 8 * t; e < 8 * t + a; ++e) { const t = b[n][e] + 8 * c * 2 * r, i = 64 * c + 8 * (7 & e); for (let e = 0; e < o; ++e)s.setUint16(t + 2 * e * r, _[n][i + e], !0) } } } const v = new Uint16Array(o); s = new DataView(a.buffer); for (let t = 0; t < 3; ++t) { i[e.idx[t]].decoded = !0; const n = i[e.idx[t]].type; if (2 == i[t].type) for (let e = 0; e < l; ++e) { const i = b[t][e]; for (let e = 0; e < o; ++e)v[e] = s.getUint16(i + 2 * e * n, !0); for (let e = 0; e < o; ++e)s.setFloat32(i + 2 * e * n, j(v[e]), !0) } } }(c, p, l, h, d, n); for (let t = 0; t < l.length; ++t) { const i = l[t]; if (!i.decoded) { if (2 !== i.compression) throw new Error("EXRLoader.parse: unsupported channel compression"); { let r = 0, a = 0; for (let s = 0; s < e.lines; ++s) { let e = p[t][r]; for (let t = 0; t < i.width; ++t) { for (let t = 0; t < 2 * i.type; ++t)n[e++] = u[a + t * i.width * i.height]; a++ } r++ } } } } return new DataView(n.buffer) } function N(e, t) { const i = new Uint8Array(e); let n = 0; for (; 0 != i[t.value + n];)n += 1; const r = (new TextDecoder).decode(i.slice(t.value, t.value + n)); return t.value = t.value + n + 1, r } function k(e, t) { const i = e.getInt32(t.value, !0); return t.value = t.value + 4, i } function O(e, t) { const i = e.getUint32(t.value, !0); return t.value = t.value + 4, i } function G(e, t) { const i = e[t.value]; return t.value = t.value + 1, i } function H(e, t) { const i = e.getUint8(t.value); return t.value = t.value + 1, i } const z = function (e, t) { let i; return i = "getBigInt64" in DataView.prototype ? Number(e.getBigInt64(t.value, !0)) : e.getUint32(t.value + 4, !0) + Number(e.getUint32(t.value, !0) << 32), t.value += 8, i }; function V(e, t) { const i = e.getFloat32(t.value, !0); return t.value += 4, i } function W(e, t) { return Gn.toHalfFloat(V(e, t)) } function j(e) { const t = (31744 & e) >> 10, i = 1023 & e; return (e >> 15 ? -1 : 1) * (t ? 31 === t ? i ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + i / 1024) : i / 1024 * 6103515625e-14) } function q(e, t) { const i = e.getUint16(t.value, !0); return t.value += 2, i } function X(e, t) { return j(q(e, t)) } function Y(e, t, i, n, r) { return "string" === n || "stringvector" === n || "iccProfile" === n ? function (e, t, i) { const n = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + i)); return t.value = t.value + i, n }(t, i, r) : "chlist" === n ? function (e, t, i, n) { const r = i.value, a = []; for (; i.value < r + n - 1;) { const n = N(t, i), r = k(e, i), s = H(e, i); i.value += 3; const o = k(e, i), l = k(e, i); a.push({ name: n, pixelType: r, pLinear: s, xSampling: o, ySampling: l }) } return i.value += 1, a }(e, t, i, r) : "chromaticities" === n ? function (e, t) { return { redX: V(e, t), redY: V(e, t), greenX: V(e, t), greenY: V(e, t), blueX: V(e, t), blueY: V(e, t), whiteX: V(e, t), whiteY: V(e, t) } }(e, i) : "compression" === n ? function (e, t) { return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][H(e, t)] }(e, i) : "box2i" === n ? function (e, t) { return { xMin: k(e, t), yMin: k(e, t), xMax: k(e, t), yMax: k(e, t) } }(e, i) : "envmap" === n ? function (e, t) { return ["ENVMAP_LATLONG", "ENVMAP_CUBE"][H(e, t)] }(e, i) : "tiledesc" === n ? function (e, t) { const i = O(e, t), n = O(e, t), r = H(e, t); return { xSize: i, ySize: n, levelMode: ["ONE_LEVEL", "MIPMAP_LEVELS", "RIPMAP_LEVELS"][15 & r], roundingMode: ["ROUND_DOWN", "ROUND_UP"][r >> 4] } }(e, i) : "lineOrder" === n ? function (e, t) { return ["INCREASING_Y", "DECREASING_Y", "RANDOM_Y"][H(e, t)] }(e, i) : "float" === n ? V(e, i) : "v2f" === n ? function (e, t) { return [V(e, t), V(e, t)] }(e, i) : "v3f" === n ? function (e, t) { return [V(e, t), V(e, t), V(e, t)] }(e, i) : "int" === n ? k(e, i) : "rational" === n ? function (e, t) { return [k(e, t), O(e, t)] }(e, i) : "timecode" === n ? function (e, t) { return [O(e, t), O(e, t)] }(e, i) : "preview" === n ? (i.value += r, "skipped") : void (i.value += r) } function K(e, t, i) { let n = 0; switch (e.levelMode) { case "ONE_LEVEL": n = 1; break; case "MIPMAP_LEVELS": n = function (e, t) { const i = Math.log2(e); return "ROUND_DOWN" == t ? Math.floor(i) : Math.ceil(i) }(Math.max(t, i), e.roundingMode) + 1; break; case "RIPMAP_LEVELS": throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.") }return n } function J(e, t, i, n) { const r = new Array(e); for (let a = 0; a < e; a++) { const e = 1 << a; let s = t / e | 0; "ROUND_UP" == n && s * e < t && (s += 1); const o = Math.max(s, 1); r[a] = (o + i - 1) / i | 0 } return r } function Z() { const e = this, t = e.offset, i = { value: 0 }; for (let n = 0; n < e.tileCount; n++) { const n = k(e.viewer, t), r = k(e.viewer, t); t.value += 8, e.size = O(e.viewer, t); const a = n * e.blockWidth, s = r * e.blockHeight; e.columns = a + e.blockWidth > e.width ? e.width - a : e.blockWidth, e.lines = s + e.blockHeight > e.height ? e.height - s : e.blockHeight; const o = e.columns * e.totalBytes, l = e.size < e.lines * o ? e.uncompress(e) : D(e); t.value += e.size; for (let t = 0; t < e.lines; t++) { const n = t * e.columns * e.totalBytes; for (let r = 0; r < e.inputChannels.length; r++) { const o = ne.channels[r].name, c = e.channelByteOffsets[o] * e.columns, h = e.decodeChannels[o]; if (void 0 === h) continue; i.value = n + c; const d = (e.height - (1 + s + t)) * e.outLineWidth; for (let t = 0; t < e.columns; t++) { const n = d + (t + a) * e.outputChannels + h; e.byteArray[n] = e.getter(l, i) } } } } } function $() { const e = this, t = e.offset, i = { value: 0 }; for (let n = 0; n < e.height / e.blockHeight; n++) { const r = k(e.viewer, t) - ne.dataWindow.yMin; e.size = O(e.viewer, t), e.lines = r + e.blockHeight > e.height ? e.height - r : e.blockHeight; const a = e.columns * e.totalBytes, s = e.size < e.lines * a ? e.uncompress(e) : D(e); t.value += e.size; for (let t = 0; t < e.blockHeight; t++) { const r = n * e.blockHeight, o = t + e.scanOrder(r); if (o >= e.height) continue; const l = t * a, c = (e.height - 1 - o) * e.outLineWidth; for (let t = 0; t < e.inputChannels.length; t++) { const n = ne.channels[t].name, r = e.channelByteOffsets[n] * e.columns, a = e.decodeChannels[n]; if (void 0 !== a) { i.value = l + r; for (let t = 0; t < e.columns; t++) { const n = c + t * e.outputChannels + a; e.byteArray[n] = e.getter(s, i) } } } } } } const ee = { value: 0 }, te = new DataView(e), ie = new Uint8Array(e), ne = function (e, t, i) { const n = {}; if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format."); n.version = e.getUint8(4); const r = e.getUint8(5); n.spec = { singleTile: !!(2 & r), longName: !!(4 & r), deepFormat: !!(8 & r), multiPart: !!(16 & r) }, i.value = 8; let a = !0; for (; a;) { const r = N(t, i); if ("" === r) a = !1; else { const a = Y(e, t, i, N(t, i), O(e, i)); void 0 === a || (n[r] = a) } } if (-7 & r) throw new Error("THREE.EXRLoader: Provided file is currently unsupported."); return n }(te, e, ee), re = function (e, t, i, n, r) { const a = { size: 0, viewer: t, array: i, offset: n, width: e.dataWindow.xMax - e.dataWindow.xMin + 1, height: e.dataWindow.yMax - e.dataWindow.yMin + 1, inputChannels: e.channels, channelByteOffsets: {}, scanOrder: null, totalBytes: null, columns: null, lines: null, type: null, uncompress: null, getter: null, format: null, colorSpace: lt }; switch (e.compression) { case "NO_COMPRESSION": a.blockHeight = 1, a.uncompress = D; break; case "RLE_COMPRESSION": a.blockHeight = 1, a.uncompress = L; break; case "ZIPS_COMPRESSION": a.blockHeight = 1, a.uncompress = U; break; case "ZIP_COMPRESSION": a.blockHeight = 16, a.uncompress = U; break; case "PIZ_COMPRESSION": a.blockHeight = 32, a.uncompress = P; break; case "PXR24_COMPRESSION": a.blockHeight = 16, a.uncompress = Q; break; case "DWAA_COMPRESSION": a.blockHeight = 32, a.uncompress = F; break; case "DWAB_COMPRESSION": a.blockHeight = 256, a.uncompress = F; break; default: throw new Error("EXRLoader.parse: " + e.compression + " is unsupported") }const s = {}; for (const t of e.channels) switch (t.name) { case "Y": case "R": case "G": case "B": case "A": s[t.name] = !0, a.type = t.pixelType }let o = !1; if (s.R && s.G && s.B) o = !s.A, a.outputChannels = 4, a.decodeChannels = { R: 0, G: 1, B: 2, A: 3 }; else { if (!s.Y) throw new Error("EXRLoader.parse: file contains unsupported data channels."); a.outputChannels = 1, a.decodeChannels = { Y: 0 } } if (1 == a.type) switch (r) { case le: a.getter = X; break; case ce: a.getter = q } else { if (2 != a.type) throw new Error("EXRLoader.parse: unsupported pixelType " + a.type + " for " + e.compression + "."); switch (r) { case le: a.getter = V; break; case ce: a.getter = W } } a.columns = a.width; const l = a.width * a.height * a.outputChannels; switch (r) { case le: a.byteArray = new Float32Array(l), o && a.byteArray.fill(1, 0, l); break; case ce: a.byteArray = new Uint16Array(l), o && a.byteArray.fill(15360, 0, l) }let c = 0; for (const t of e.channels) void 0 !== a.decodeChannels[t.name] && (a.channelByteOffsets[t.name] = c), c += 2 * t.pixelType; if (a.totalBytes = c, a.outLineWidth = a.width * a.outputChannels, "INCREASING_Y" === e.lineOrder ? a.scanOrder = e => e : a.scanOrder = e => a.height - 1 - e, 4 == a.outputChannels ? (a.format = pe, a.colorSpace = lt) : (a.format = me, a.colorSpace = st), e.spec.singleTile) { a.blockHeight = e.tiles.ySize, a.blockWidth = e.tiles.xSize; const i = K(e.tiles, a.width, a.height), r = J(i, a.width, e.tiles.xSize, e.tiles.roundingMode), s = J(i, a.height, e.tiles.ySize, e.tiles.roundingMode); a.tileCount = r[0] * s[0]; for (let e = 0; e < i; e++)for (let i = 0; i < s[e]; i++)for (let i = 0; i < r[e]; i++)z(t, n); a.decode = Z.bind(a) } else { a.blockWidth = a.width; const e = Math.ceil(a.height / a.blockHeight); for (let i = 0; i < e; i++)z(t, n); a.decode = $.bind(a) } return a }(ne, te, ie, ee, this.type); return re.decode(), { header: ne, width: re.width, height: re.height, data: re.byteArray, format: re.format, colorSpace: re.colorSpace, type: this.type } } setDataType(e) { return this.type = e, this } load(e, t, i, n) { return super.load(e, (function (e, i) { e.colorSpace = i.colorSpace, e.minFilter = $, e.magFilter = $, e.generateMipmaps = !1, e.flipY = !1, t && t(e, i) }), i, n) } } const ap = new ps, sp = `https://unpkg.com/three@0.${r}.x`, op = new class extends gs { constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, i, n) { const r = new bs(this.manager); r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (e => { this.parse(e, t, n) }), i, n) } parse(e, t, i = () => { }) { this.decodeDracoFile(e, t, null, null, ot, i).catch(i) } decodeDracoFile(e, t, i, n, r = lt, a = () => { }) { const s = { attributeIDs: i || this.defaultAttributeIDs, attributeTypes: n || this.defaultAttributeTypes, useUniqueIDs: !!i, vertexColorSpace: r }; return this.decodeGeometry(e, s).then(t).catch(a) } decodeGeometry(e, t) { const i = JSON.stringify(t); if (Dd.has(e)) { const t = Dd.get(e); if (t.key === i) return t.promise; if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let n; const r = this.workerNextTaskID++, a = e.byteLength, s = this._getWorker(r, a).then((i => (n = i, new Promise(((i, a) => { n._callbacks[r] = { resolve: i, reject: a }, n.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]) }))))).then((e => this._createGeometry(e.geometry))); return s.catch((() => !0)).then((() => { n && r && this._releaseTask(n, r) })), Dd.set(e, { key: i, promise: s }), s } _createGeometry(e) { const t = new ir; e.index && t.setIndex(new Wn(e.index.array, 1)); for (let i = 0; i < e.attributes.length; i++) { const n = e.attributes[i], r = n.name, a = n.array, s = n.itemSize, o = new Wn(a, s); "color" === r && (this._assignVertexColorSpace(o, n.vertexColorSpace), o.normalized = a instanceof Float32Array == !1), t.setAttribute(r, o) } return t } _assignVertexColorSpace(e, t) { if (t !== ot) return; const i = new Dn; for (let t = 0, n = e.count; t < n; t++)i.fromBufferAttribute(e, t), qt.toWorkingColorSpace(i, ot), e.setXYZ(t, i.r, i.g, i.b) } _loadLibrary(e, t) { const i = new bs(this.manager); return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise(((t, n) => { i.load(e, t, void 0, n) })) } preload() { return this._initDecoder(), this } _initDecoder() { if (this.decoderPending) return this.decoderPending; const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => { const i = t[0]; e || (this.decoderConfig.wasmBinary = t[1]); const n = Ld.toString(), r = ["/* draco decoder */", i, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([r])) })), this.decoderPending } _getWorker(e, t) { return this._initDecoder().then((() => { if (this.workerPool.length < this.workerLimit) { const e = new Worker(this.workerSourceURL); e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e.onmessage = function (t) { const i = t.data; switch (i.type) { case "decode": e._callbacks[i.id].resolve(i); break; case "error": e._callbacks[i.id].reject(i) } }, this.workerPool.push(e) } else this.workerPool.sort((function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 })); const i = this.workerPool[this.workerPool.length - 1]; return i._taskCosts[e] = t, i._taskLoad += t, i })) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this } }(ap).setDecoderPath(`${sp}/examples/jsm/libs/draco/gltf/`), lp = new wd(ap).setTranscoderPath(`${sp}/examples/jsm/libs/basis/`), cp = "assetgenerator"; As.enabled = !0; class hp { constructor(e, t = {}) { this.el = e, this.options = t, this.lights = [], this.content = null, this.mixer = null, this.clips = [], this.state = { environment: t.preset === cp ? IA.find((e => "footprint-court" === e.id)).name : IA[1].name, background: !1, playbackSpeed: 1, actionStates: {}, camera: yA, wireframe: !1, skeleton: !1, grid: !1, autoRotate: !1, punctualLights: !0, exposure: -1.5, toneMapping: 1, ambientIntensity: 1, ambientColor: "#e3e3e3", directIntensity: .8 * Math.PI, directColor: "#FFFFFF", bgColor: "#f7f5f3", pointSize: 1 }, this.prevTime = 0, this.stats = new $c, this.stats.dom.height = "48px", [].forEach.call(this.stats.dom.children, (e => e.style.display = "")), this.backgroundColor = new Dn(this.state.bgColor), this.scene = new Ur, this.scene.background = this.backgroundColor; const i = t.preset === cp ? 144 / Math.PI : 60, n = e.clientWidth / e.clientHeight; this.defaultCamera = new Sr(i, n, .01, 1e3), this.activeCamera = this.defaultCamera, this.scene.add(this.defaultCamera), this.renderer = new Jc({ antialias: !0 }), this.renderer.setClearColor(13421772), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(e.clientWidth, e.clientHeight), this.pmremGenerator = new Go(this.renderer), this.pmremGenerator.compileEquirectangularShader(), this.neutralEnvironment = this.pmremGenerator.fromScene(new du).texture, this.controls = new Zd(this.defaultCamera, this.renderer.domElement), this.controls.screenSpacePanning = !1, this.controls.zoomToCursor = !0, this.controls.enablePan = !0, this.controls.enableZoom = !0, this.controls.enableRotate = !0, this.controls.zoomSpeed = 2.5, this.controls.panSpeed = 1, this.controls.rotateSpeed = 1, this.el.appendChild(this.renderer.domElement), this.skeletonHelpers = [], this.gridHelper = null, this.axesHelper = null, this.measurement = new Au(this), !1 !== t.addGui && (this.state.measure = this.measurement.toggle.bind(this.measurement), this.gui = new xA(this), t.kiosk && this.gui.close()), this.animate = this.animate.bind(this), this.resize = this.resize.bind(this), this.addAxesHelper(), requestAnimationFrame(this.animate), window.addEventListener("resize", this.resize, !1) } animate(e) { requestAnimationFrame(this.animate); const t = (e - this.prevTime) / 1e3; this.controls.update(), this.stats.update(), this.mixer && this.mixer.update(t), this.render(), this.prevTime = e } render() { this.measurement && this.measurement.updateScales(), this.renderer.render(this.scene, this.activeCamera), this.state.grid && (this.axesCamera.position.copy(this.defaultCamera.position), this.axesCamera.lookAt(this.axesScene.position), this.axesRenderer.render(this.axesScene, this.axesCamera)) } resize() { const { clientHeight: e, clientWidth: t } = this.el.parentElement || this.el; this.defaultCamera.aspect = t / e, this.defaultCamera.updateProjectionMatrix(), this.renderer.setSize(t, e), this.axesCamera && (this.axesCamera.aspect = this.axesDiv.clientWidth / this.axesDiv.clientHeight, this.axesCamera.updateProjectionMatrix(), this.axesRenderer.setSize(this.axesDiv.clientWidth, this.axesDiv.clientHeight)) } load(e, t, i) { const n = Os.extractUrlBase(e); return new Promise(((r, a) => { ap.setURLModifier(((e, r) => { const a = t + decodeURI(e).replace(n, "").replace(/^(\.?\/)/, ""); if (i.has(a)) { const e = i.get(a), t = URL.createObjectURL(e); return o.push(t), t } return (r || "") + e })); const s = new th(ap).setCrossOrigin("anonymous").setDRACOLoader(op).setKTX2Loader(lp.detectSupport(this.renderer)).setMeshoptDecoder(Ud), o = []; s.load(e, (e => { const t = e.scene || e.scenes[0], i = e.animations || []; if (!t) throw new Error("This model contains no scene, and cannot be viewed here. However, it may contain individual 3D resources."); this.setContent(t, i), o.forEach(URL.revokeObjectURL), r(e) }), void 0, a) })) } setContent(e, t) { this.clear(), e.updateMatrixWorld(); const i = (new ui).setFromObject(e), n = i.getSize(new ci).length(), r = new ci; i.getCenter(r), r.y = i.min.y, e.position.sub(r), r.add(e.position), this.controls.reset(), this.controls.minDistance = .01, this.controls.maxDistance = 10 * n, this.controls.zoomSpeed = 2.5, this.controls.target.copy(r); const a = new ci(1, .2, 1).normalize(); this.defaultCamera.position.copy(r).add(a.multiplyScalar(1.5 * n)), this.defaultCamera.lookAt(r), this.defaultCamera.near = n / 1e3, this.defaultCamera.far = 1e3 * n, this.defaultCamera.updateProjectionMatrix(), this.controls.update(), this.controls.saveState(), this.setCamera(yA), this.axesCamera.position.copy(this.defaultCamera.position), this.axesCamera.lookAt(this.axesScene.position), this.axesCamera.near = n / 1e3, this.axesCamera.far = 1e3 * n, this.axesCamera.updateProjectionMatrix(), this.axesCorner.scale.set(n, n, n), this.scene.add(e), this.content = e, this.state.punctualLights = !0, this.content.traverse((e => { e.isLight && (this.state.punctualLights = !1) })), this.setClips(t), this.updateLights(), this.gui && this.gui.update(), this.updateEnvironment(), this.updateDisplay(), window.VIEWER && (window.VIEWER.scene = this.content) } setClips(e) { this.mixer && (this.mixer.stopAllAction(), this.mixer.uncacheRoot(this.mixer.getRoot()), this.mixer = null), this.clips = e, e.length && (this.mixer = new $s(this.content)) } playAllClips() { this.clips.forEach((e => { this.mixer.clipAction(e).reset().play(), this.state.actionStates[e.name] = !0 })) } setCamera(e) { e === yA ? (this.controls.enabled = !0, this.activeCamera = this.defaultCamera) : (this.controls.enabled = !1, this.content.traverse((t => { t.isCamera && t.name === e && (this.activeCamera = t) }))) } updateLights() { const e = this.state, t = this.lights; e.punctualLights && !t.length ? this.addLights() : !e.punctualLights && t.length && this.removeLights(), this.renderer.toneMapping = Number(e.toneMapping), this.renderer.toneMappingExposure = Math.pow(2, e.exposure), 2 === t.length && (t[0].intensity = e.ambientIntensity, t[0].color.set(e.ambientColor), t[1].intensity = e.directIntensity, t[1].color.set(e.directColor)) } addLights() { const e = this.state; if (this.options.preset === cp) { const e = new Cs; return e.name = "hemi_light", this.scene.add(e), void this.lights.push(e) } const t = new ks(e.ambientColor, e.ambientIntensity); t.name = "ambient_light", this.defaultCamera.add(t); const i = new Ns(e.directColor, e.directIntensity); i.position.set(.5, 0, .866), i.name = "main_light", this.defaultCamera.add(i), this.lights.push(t, i) } removeLights() { this.lights.forEach((e => e.parent.remove(e))), this.lights.length = 0 } updateEnvironment() { (function (e, t, i, n) { const r = IA.filter((t => t.name === e))[0]; if (!r) return Promise.resolve({ envMap: null }); const { id: a, path: s } = r; return "neutral" === a ? Promise.resolve({ envMap: n }) : "" === a ? Promise.resolve({ envMap: null }) : new Promise(((e, t) => { (new rp).load(s, (t => { const n = i.fromEquirectangular(t).texture; i.dispose(), e({ envMap: n }) }), void 0, t) })) })(this.state.environment, this.renderer, this.pmremGenerator, this.neutralEnvironment).then((({ envMap: e }) => { this.scene.environment = e, this.scene.background = this.state.background ? e : this.backgroundColor })) } updateDisplay() { this.skeletonHelpers.length && this.skeletonHelpers.forEach((e => this.scene.remove(e))), CA(this.content, (e => { e.wireframe = this.state.wireframe, e instanceof Ba && (e.size = this.state.pointSize) })), this.content.traverse((e => { if (e.geometry && e.skeleton && this.state.skeleton) { const t = new lo(e.skeleton.bones[0].parent); t.material.linewidth = 3, this.scene.add(t), this.skeletonHelpers.push(t) } })), this.state.grid !== Boolean(this.gridHelper) && (this.state.grid ? (this.gridHelper = new ho, this.axesHelper = new uo, this.axesHelper.renderOrder = 999, this.axesHelper.onBeforeRender = e => e.clearDepth(), this.scene.add(this.gridHelper), this.scene.add(this.axesHelper)) : (this.scene.remove(this.gridHelper), this.scene.remove(this.axesHelper), this.gridHelper = null, this.axesHelper = null, this.axesRenderer.clear())), this.controls.autoRotate = this.state.autoRotate } updateBackground() { this.backgroundColor.set(this.state.bgColor) } addAxesHelper() { this.axesDiv = document.createElement("div"), this.el.appendChild(this.axesDiv), this.axesDiv.classList.add("axes"); const { clientWidth: e, clientHeight: t } = this.axesDiv; this.axesScene = new Ur, this.axesCamera = new Sr(50, e / t, .1, 10), this.axesScene.add(this.axesCamera), this.axesRenderer = new Jc({ alpha: !0 }), this.axesRenderer.setPixelRatio(window.devicePixelRatio), this.axesRenderer.setSize(this.axesDiv.clientWidth, this.axesDiv.clientHeight), this.axesCamera.up = this.defaultCamera.up, this.axesCorner = new uo(5), this.axesScene.add(this.axesCorner), this.axesDiv.appendChild(this.axesRenderer.domElement) } clear() { this.content && (this.scene.remove(this.content), this.content.traverse((e => { e.geometry && e.geometry.dispose() })), CA(this.content, (e => { for (const t in e) "envMap" !== t && e[t] && e[t].isTexture && e[t].dispose() }))) } } var dp = i(72), up = i.n(dp), Ap = i(825), pp = i.n(Ap), fp = i(659), gp = i.n(fp), mp = i(56), _p = i.n(mp), bp = i(540), vp = i.n(bp), Ep = i(113), yp = i.n(Ep), xp = i(208), Cp = {}; Cp.styleTagTransform = yp(), Cp.setAttributes = _p(), Cp.insert = gp().bind(null, "head"), Cp.domAPI = pp(), Cp.insertStyleElement = vp(); up()(xp.A, Cp); xp.A && xp.A.locals && xp.A.locals; class Ip { static instances = new WeakMap; constructor(e = {}) { if (this.options = { addGui: !0, model: null, preset: null, cameraPosition: null, validate: !1, autoRotate: !1, defaultEnvironment: "Neutral", showGrid: !1, background: "#f7f5f3", ...e }, !this.options.container) throw new Error("A container element is required to initialize the viewer"); this.container = this.options.container; const t = Ip.instances.get(this.container); t && t.dispose(), Ip.instances.set(this.container, this), this.container.classList.add("gltf-viewer-container"), this.viewer = null, this.spinnerEl = this._createSpinner(), this.viewerEl = this._createViewerElement(), this._initViewer(), this.options.model && this.loadModel(this.options.model), this.createdObjectURLs = [] } _createSpinner() { const e = document.createElement("div"); return e.classList.add("spinner"), e.style.display = "none", this.container.appendChild(e), e } _createViewerElement() { const e = document.createElement("div"); return e.classList.add("viewer"), this.container.appendChild(e), e } _initViewer() { const e = { preset: this.options.preset, cameraPosition: this.options.cameraPosition, addGui: this.options.addGui }; return this.viewer = new hp(this.viewerEl, e), this.options.autoRotate && (this.viewer.state.autoRotate = !0, this.viewer.updateDisplay()), this.options.showGrid && (this.viewer.state.grid = !0, this.viewer.updateDisplay()), this.options.background && "#f7f5f3" !== this.options.background && (this.viewer.state.bgColor = this.options.background, this.viewer.updateBackground()), this.viewer } showSpinner() { this.spinnerEl && (this.spinnerEl.style.display = "") } hideSpinner() { this.spinnerEl && (this.spinnerEl.style.display = "none") } loadModel(e, t = "") { this.viewer || this._initViewer(), this.showSpinner(); const i = new Map; return this.viewer.load(e, t, i).then((e => (this.hideSpinner(), e))).catch((e => { throw this.hideSpinner(), this._handleError(e), e })) } _handleError(e) { let t = (e || {}).message || e.toString(); t.match(/ProgressEvent/) ? t = "Unable to retrieve this file. Check browser console and network tab." : t.match(/Unexpected token/) ? t = `Unable to parse file content. Verify that this file is valid. Error: "${t}"` : e && e.target && e.target instanceof Image && (t = "Missing texture: " + e.target.src.split("/").pop()), this.container.dispatchEvent(new CustomEvent("gltferror", { detail: { error: e, message: t } })) } dispose() { if (this.container && Ip.instances.delete(this.container), this.createdObjectURLs.forEach((e => URL.revokeObjectURL(e))), this.createdObjectURLs = [], this.viewer && (this.viewer.clear(), this.viewer.renderer && this.viewer.renderer.dispose(), window.removeEventListener("resize", this.viewer.resize)), this.container) { for (; this.container.firstChild;)this.container.removeChild(this.container.firstChild); this.container.classList.remove("gltf-viewer-container") } this.spinnerEl = null, this.viewerEl = null, this.viewer = null } addEventListener(e, t) { this.container.addEventListener(`gltf${e}`, t) } removeEventListener(e, t) { this.container.removeEventListener(`gltf${e}`, t) } static getInstance(e) { return Ip.instances.get(e) || null } } return n })()));
//# sourceMappingURL=three-gltf-viewer-lib.min.js.map